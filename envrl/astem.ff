      subroutine binomx(y,iyp,iyt,z,izp,izt,f,ifp,ift,iofrom,ioto,
     1  myp,myt,mzp,mzt,mfp,mft,itype )
c
$if def,in32,1
       implicit real*8(a-h,o-z)
c
c
c     for y*z=f, where y,z, and f are functions of (p,t), compute the
c     derivatives of:
c
c      y, if itype.eq.0
c        partial to the m+n-2 of y with respect to the partial of p
c        to the m-1 and the partial of t to the n-1 and stores the
c        answer in y(m,n)
c
c      f, if itype.gt.0
c        partial to the m+n-2 of f with respect to the partial of p
c        to the m-1 and the partial of t to the n-1 and stores the
c        answer in f(m,n)
c
c
c     required input
c     iofrom is the initial order of the precalculated derivatives
c        if iofrom.eq.0 and itype.eq.0, then y(1,1) is calculated
c        if iofrom.eq.0 and itype.gt.0, then f(1,1) is calculated
c        if iofrom.gt.0, then all previous derivatives must exist in
c        the y or f array
c        if iofrom=-1, then p index held at 1
c        if iofrom=-2, then t index held at 1
c     ioto is the highest ordered derivatives to be calculated
c        if itype.eq.0, then y(m,n) is calculated
c        if itype.gt.0, then f(m,n) is calculated
c     z array to z(m,n)     if non-zero
c     dimensions of the y array   y(iyp,iyt)
c     dimensions of the z array   z(izp,izt)
c     dimensions of the f array   f(ifp,ift)
c
c     in general y can be a derivative of z or f by using specific
c        array locations in the calling arguments for y, z, or f
c        example:  let y(1,1) = x sub p,tt and z(1,1) = x
c                  then z(i+1,j+2) = y(i,j)
c     myp and myt are the y array increments
c     mzp and mzt are the z array increments
c     mfp and mft are the f array increments
c        ex. f(m+mfp,n+mft) is actually used
c
c     internally the double array i,j is treated as a single array
c        dimensioned lmax where lmax=ip*it-m*(m-1)/2 and where
c        m=min0(ip,it)
c     any element of the array (i,j) ( max of (im,jm) )
c        is m=j*im-l*(l-1)/2-k
c        where l=min(j,max(im-jm+j,0))
c        and k=iprim-i
c        where j is .ge.1 and .le.jm
c        and i is .ge.1 and .le.iprim
c            where iprim=min((max(im,jm)-j),im-1)+1
c
      logical logit
c
      common / binfac / binomc(66), fktorl(10)
c
      dimension y(1), z(1), f(1)
c
      external indexx
c
      logit = itype.eq.0
      lioto = abs(ioto)
      i2 = lioto + 1
      lt1 = iyt + ift
      lp1 = iyp + ifp
      if( iofrom.eq.-1 ) lp1 = 1
      if( iofrom.eq.-2 ) lt1 = 1
      if( logit )  go to 10
      lp = min0( lp1, ifp )
      lt = min0( lt1, ift )
      go to 20
   10 continue
      lp = min0( lp1, iyp )
      lt = min0( lt1, iyt )
      mz = indexx(mzp+1,izp,mzt+1,izt,idum)
      rz = 1.0/z(mz)
   20 continue
      i6 = min( i2, lt )
      iofro = max( iofrom, 0 )
      i1 = iofro + 2
      nh0 = iofro + 1
      i5 = i2 + 1
      do 90  n = nh0,i6
      i3 = max(1,i1-n )
      i4 = min(i5-n, lp )
      if( i3.gt.i4 )  return
      nh = n
      n1 = n + 1
      do 80  m = i3,i4
      mh = m
      m1 = m + 1
      jfp = m + mfp
      jft = n + mft
      jyp = m + myp
      jyt = n + myt
      jf = indexx(jfp,ifp,jft,ift,idum)
      sum = 0.0
      if( logit )  go to 30
      if( ( jfp.gt.ifp ) .or. ( jft.gt.ift ) )  return
      f(jf) = 0.0
      go to 40
   30 continue
      if( ( jyp.gt.iyp ) .or. ( jyt.gt.iyt ) )  return
      jy = indexx(jyp,iyp,jyt,iyt,idum)
      y(jy) = 0.0
   40 continue
      do 60  j = 1,nh
      l = n1 - j
      lyt = l + myt
      lzt = j + mzt
      if( ( lyt.gt.iyt ) .or. ( lzt.gt.izt ) )  go to 60
      lca = j + (n*(n-1))/2
      a = binomc(lca)
      do 50  i = 1,mh
      lyp = m1 - i + myp
      lzp = i + mzp
      if( ( lyp.gt.iyp ) .or. ( lzp.gt.izp ) )  go to 50
      lcb = i + (m*(m-1))/2
      b = binomc(lcb)
      ly = indexx(lyp,iyp,lyt,iyt,idum)
      lz = indexx(lzp,izp,lzt,izt,idum)
      sum = sum + b*a*y(ly)*z(lz)
   50 continue
   60 continue
      if( logit )  go to 70
      f(jf) = sum
      go to 80
   70 continue
      q = 0.0
      if( ( ifp.ge.jfp ) .and. ( ift.ge.jft ) )  q = f(jf)
      y(jy) = ( q-sum )*rz
   80 continue
   90 continue
      return
      end
      subroutine cona(aa,ioa,a,ib,jb,ca,ci,cj)
$if def,in32,1
       implicit real*8(a-h,o-z)
      dimension aa(1),a(1)
c
c
c        convert units of input array aa to output array a
c             aa must be single dimensioned array equivalent to a
c             double-dimensioned triangular array (ioa+1)x(ioa+1)
c
c             the output array a is a single dimensioned array
c             equivalent to (ioa+1-ib-jb)x(ioa+1-ib-jb)
c                  where ioa is the order of the array aa
c      ib and jb are index biases
c
c        ex.       aa(1) = v
c                  aa(2) = pv/pp
c                  aa(5) = p2v/pp*pt
c        then      a(1) = v*ca
c                  a(2) = (pv/pp)*(ca/ci)
c                  a(5) = (p2v/pp*pt)*(ca/(ci*cj))
c
      external indexx
      laa = ioa + 1
      io = ioa - ib - jb
      la = io + 1
      call binomx(aa,laa,laa,1.0,1,1,a,la,la,0,io,ib,jb,0,0,0,0,1)
      do 10  j = 1,la
      imax = la - j + 1
      c = ca/(cj**(j-1))
      do 10  i = 1,imax
      l = indexx(i,la,j,la,idum)
      a(l) = a(l)*c/(ci**(i-1))
   10 continue
      return
      end
      subroutine conu(j,c,x1,i1,x2,i2,x3,i3,x4,i4,x5,i5,x6,i6,x7,i7,
     1                x8,i8,x9,i9,x10,i10)
$if def,in32,1
       implicit real*8(a-h,o-z)
      dimension c(6), x(10), i(10)
      dimension j(1),x1(1),i1(1),x2(1),i2(1),x3(1),i3(1),x4(1),i4(1),
     1          x5(1),i5(1),x6(1),i6(1),x7(1),i7(1),x8(1),i8(1),
     2          x9(1),i9(1),x10(1),i10(1)
c
c        j is the number of x"s in list      1.ge.j.le.10
c
c        converts units of variables x from those defined by c to asme
c        reduced when i"s are negative or from reduced to c units
c        when i"s are positive
c
c        i = 1, pressure
c        i = 2, change in temperature
c        i = 3, specific volume
c        i = 4 enthalpy, specific internal energy, gibbs, or helmholtz
c        i = 5, entropy
c        i = 6, non incremental temperature
c
c
c        input units c array as
c        c(1) = critical pressure, crp
c        c(2) = critical absolute temperature, crt
c        c(3) = critical specific volume, crv
c        c(4) = enthalpy multiplier, crh
c        c(5) = entropy, crs
c        c(6) = "zero" temperature, t0
c
c
      jj = j(1)
      go to (50,45,40,35,30,25,20,15,10,5),jj
      call fabend
    5 x(10) = x 10(1)
      i(10) = i10(1)
   10 x( 9) = x9 (1)
      i( 9) = i9 (1)
   15 x( 8) = x8 (1)
      i( 8) = i8 (1)
   20 x( 7) = x7 (1)
      i( 7) = i7 (1)
   25 x( 6) = x6 (1)
      i( 6) = i6 (1)
   30 x( 5) = x5 (1)
      i( 5) = i5 (1)
   35 x( 4) = x4 (1)
      i( 4) = i4 (1)
   40 x( 3) = x3 (1)
      i( 3) = i3 (1)
   45 x( 2) = x2 (1)
      i( 2) = i2 (1)
   50 x( 1) = x1 (1)
      i( 1) = i1 (1)
      do 120 l=1,jj
      kk = i(l)
      k = abs(kk)
      if( k.eq.6 )  k = 2
      if( kk.le.0 )  go to 110
      x(l) = x(l)*c(k)
      if( kk.eq.6 )  x(l) = x(l) - c(6)
      go to 120
  110 if( kk.eq.-6 )  x(l) = x(l) + c(6)
      x(l) = x(l)/c(k)
  120 continue
      go to (250,245,240,235,230,225,220,215,210,205),jj
      call fabend
  205 x10(1) = x(10)
  210 x9 (1) = x( 9)
  215 x8 (1) = x( 8)
  220 x7 (1) = x( 7)
  225 x6 (1) = x( 6)
  230 x5 (1) = x( 5)
  235 x4 (1) = x( 4)
  240 x3 (1) = x( 3)
  245 x2 (1) = x( 2)
  250 x1 (1) = x( 1)
      return
      end
      subroutine eder(zz,x,b,bl,m,n,io)
c
$if def,in32,1
       implicit real*8(a-h,o-z)
c     calculate the t derivatives to order io of the sum from 1 to m
c        of b(i)*x**n(i) where x=exp(bl*(1.-t))
c     m is limited to be 7 or less
c     input b,m,n,io,bl, and x
c
      dimension zz(1),b(1),n(1)
      dimension z(7),a(7),c(7)
c
      do 10  i = 1,m
      s = n(i)
      a(i) = -bl * s
      c(i) = 1.0
      z(i) = b(i) * (x**n(i))
   10 continue
      il = io + 1
      do 30  i = 1,il
      s = 0.0
      do 20  j = 1,m
      s = s + c(j)*z(j)
      c(j) = c(j)*a(j)
   20 continue
      zz(i) = s
   30 continue
      return
      end
           function funx   (x,a,b,c,d,ii)
c
$if def,in32,1
       implicit real*8(a-h,o-z)
c     ii defines the type of equation for the root routine
c
c     ii = 1 or 2    given (v,t) compute p for region 1 or 2
c     ii = -1 or -2  given (p,u) compute t for region 1 or 2
c     ii = 3 or 4    given (p,t) compute v for region 3 or 4
c     ii = -3 or -4  given (u,v) compute t for region 3 or 4
c     ii =      6    given (u,v) compute tsat for region 6
c     ii = -5 or -6  given psat compute tsat for region 5 or 6
c
      dimension f(3)
c
c
      i = abs( ii )
      go to (100,100,200,200,300,300),i
      call fabend
  100 if( ii.lt.0 )  go to 150
c
c     given (v,t) compute p for region 1 or 2
c     p = x  (pressure)                          input
c     v = a  (specific volume)                   input
c     t = b  (temperature)                       input
c     u = c  (specific internal energy)          output
c
      call gibbab(f,x,b,1,i)
      c = f(1) - b*f(3) - x*f(2)
      funx = (a-f(2))/a
      return
c
c
c     given (p,u) compute t for region 1 or 2
c     t = x  (temperature)                       input
c     p = a  (pressure)                          input
c     u = b  (specific internal energy)          input
c     v = c  (specific volume)                   output
c
  150 call gibbab(f,a,x,1,i)
      c = f(2)
      funx = (b - f(1) + x*f(3) + a*f(2))/b
      return
  200 if( ii.lt.0 )  go to 250
c
c     given (p,t) compute v for region 3 or 4
c     v = x  (specific volume)                   input
c     p = a  (pressure)                          input
c     t = b  (temperature)                       input
c     u = c  (specific internal energy)          output
c     s = d  (entropy)                           output
c
      call helmcd(f,x,b,1,i)
      d = -f(3)
      c = f(1) - b*f(3)
      funx = (a + f(2))/a
      return
c
c     given (u,v) compute t for region 3 or 4
c     t = x  (temperature)                       input
c     u = a  (specific internal energy)          input
c     v = b  (specific volume)                   input
c     p = c  (pressure)                          output
c
  250 call helmcd(f,b,x,1,i)
      c = -f(2)
      funx = (a - f(1) + x*f(3))/a
      return
  300 if( ii.lt.0 )  go to 400
      if( i.eq.5 )  go to 350
c
c     given (u,v) compute tsat for region 6
c     t = x  (temperature)                       input
c     u = a  (specific internal energy)          input
c     v = b  (specific volume)                   input
c     x = c  (quality)                           output
c     p = d  (pressure)                          output
c
      call psatk(d,x,0)
      call gibbab(f,d,x,1,1)
      vf = f(2)
      uf = f(1) - d*vf - x*f(3)
      call gibbab(f,d,x,1,2)
      vg = f(2)
      ug = f(1) - d*vg - x*f(3)
      xu = (a-uf)/(ug-uf)
      xv = (b-vf)/(vg-vf)
      c = (xu + xv)*0.5
      funx = xu - xv
      return
c
  350 continue
      return
c
c
c     given psat compute tsat for region 5 or 6
c     t = x  (temperature)                       input
c     p = a  (pressure)                          input
c
  400 call psatk(p,x,0)
      funx = (a - p)/a
      return
      end
      subroutine gibbab( gibbs, pin, tin, l, ireg )
c
$if def,in32,1
       implicit real*8(a-h,o-z)
c     calculates various derivatives of the gibbs function from the
c     1967 asme formulea for water in sub region ireg with pressure (p)
c     and temperature (t) as independent variables
c
c     all quantities are normalized to the critical point
c
c     gibbs(i,j) = partial (to the i+j-1 order) of gibbs with respect
c     to pressure (i-1) and temperature (j-1)
c
c     pin is the input pressure
c     tin is the input temperature
c     l is the highest order derivatives of the gibbs function
c     to be calculated
c
      common / asme1 / a0,sa(10),a11,taza(3),a15,a16,paa(3),a20,a21,
     1  a22,al1,al2,al3,al4,al5,al6,al7,al8,al9,al10,al11,al12,
     2                 b0,sb(5),b1(2),b2(3),b3(2),b4(2),b5(3),b6(2),
     3 b7(2),b8(2),b9(7),bl,bl61,bl71,bl8(2),
     4 p1(2),tapa(2),tbpa(2),ya(3),tca(2),td(2),gpower,a1117,t1(2),
     5 twelve,sevent,twnty9
c
      common /asmcon/ thetat,theta1,theta2,theta3,betaa1,betaa2,
     1 betaat,alpha0,alpha1,xiota1
c
      dimension gibbs(1)
c
c     the following dimensions limit the order to 9 or less
c     z, zz, and y should be dimensioned at least (o+2)*(o+3)/2
c     h,ta,tb,te,pb,xz, and xs should be dimensioned at least (o+2)
c        total common dimensions should be at least 5*(o+1)*(o+2)/2
      common / dumzzz / z(66),zz(66),y(66),h(11),ta(11),tb(11),te(11),
     1 pb(11), xz(11), xs(11)
c
c     the following variables have fixed dimensions
      dimension itazb(3), itapb(2), itbpb(2), itcb(2), isb(10),
     1  ipab(3), iyb(3)
      dimension tax(11),tap(20),tbp(12),tc(21),s(10),taz(3),p4(5),
     1 p3(4),pa(4)
      dimension p2(3),p5(6),p6(7),p11(12)
      dimension jx1(2),jx2(3),jx3(2),jx4(2),jx5(3),jx6(2),jx7(2),
     1 jx8(2),jlx8(2)
c
      external indexx
      data itazb / 0,1,2 /
      data itapb / 0,19 /
      data itbpb / 0,11 /
      data itcb / 18,20 /
      data isb / 0,1,2,3,4,5,6,7,8,9 /
      data ipab / 1,2,3 /
      data iyb / 0,2,-6 /
      data jx1 / 13,3 /
      data jx2 / 18,2,1 /
      data jx3 / 18,10 /
      data jx4 / 25,14 /
      data jx5 / 32,28,24 /
      data jx6 / 12,11 /
      data jx7 / 24,18 /
      data jx8 / 24,14 /
      data jlx8 / 54,27 /
c
      i = l + 1
      order2 = l + 2
      p = pin
      t = tin
      l3 = min0( i,3 )
      l4 = min0( i,4 )
      l5 = min0( i,5 )
      l12 = min0( i,12 )
      l21 = min0( i,21 )
      call polyn( p, p4, 1.0, 4, 1, l5 )
      call polyn( p, p3, 1.0, 3, 1, l4 )
      p1(1) = p
      a = a0
      if( ireg.eq.2 )  a = b0
      h(2) = -a * log(t)
      h(1) = t * ( a  + h(2) )
      i2 = i - 2
      if( i2 .gt.0 )  call polyn( t, h(3), -a , -1, 1, i2  )
      if( ireg.eq.2 )  go to 80
c
c     region 1
c
      l10 = min0( i,10 )
      l11 = min0( i,11 )
      l20 = min0( i,20 )
      call polyn( t, taz, taza, itazb, 3, l3 )
      r = t - al6
      call polyn( r, tax, a15, 10, 1, l11 )
      call polyn( t, tap, tapa, itapb, 2, l20 )
      call binomx(ta,1,i,tap,1,l20,a16,1,1,-1,l,0,0,0,0,0,0,0)
      do 30  j = 1,i
      if( j.le.3 )  ta(j) = ta(j) + taz(j)
      if( j.le.11 )  ta(j) = ta(j) + tax(j)
   30 continue
      call polyn( t, tbp, tbpa, itbpb, 2, l12 )
      x1 = -1.0
      call binomx(tb,1,i,tbp,1,l12,x1,1,1,-1,l,0,0,0,0,0,0,0)
      call polyn( t, tc, tca, itcb, 2, l21 )
      td(1) = a21 * ( al12 - t )
      call polyn( t, s, sa, isb, 10, l10 )
      call polyn( p, pa, paa, ipab, 3, l4 )
      r = al10 + p
      call polyn( r, pb, 1.0 , -3, 1, i )
      pb(1) = pb(1) + al11 * p
      pb(2) = pb(2) + al11
      call polyn(t,te,ya,iyb,3,i)
      call binomx(te,1,i,te,1,i,zz,1,i,0,i2,0,1,0,0,0,0,1)
      do 40  j = 1,l
   40 zz(j) = al3 * zz(j)
      zz(1) = zz(1) - al4
      z(1) =  sqrt(al3*te(1)*te(1) - 2.0*( al4*t-al5*p) )
      call binomx(z,i,i,z,i,i,al5,1,1,-2,i2,1,0,0,0,0,0,0)
      call binomx(z,i,i,z,i,i,zz,1,i,0,i2,0,1,0,0,0,0,0)
      do 50  j = 1,i
      ij = indexx(1,i,j,i,idum)
      z(ij) = z(ij) + te(j)
   50 continue
      call binomx(z,i,i,gpower,1,1,zz,i,i,0,l,0,0,0,0,0,0,1)
      lm1 = l - 1
      call binomx(xz,l,1,z,i,i,zz,i,i,0,lm1,0,0,0,0,1,0,0)
      xs(1) = z(1)**gpower
      call binomx(xs,i,1,xz,l,1,xs,i,1,0,lm1,0,0,0,0,1,0,1)
      call binomx(y,l,l,z,i,i,zz,i,i,0,lm1,0,0,0,0,0,1,0)
      do 55 k=1,i
   55 zz(k) = xs(k)
      call binomx(zz,i,i,y,l,l,zz,i,i,0,lm1,0,0,0,0,0,1,1)
      call binomx(z,i,i,zz,i,i,gibbs,i,i,0,l,0,0,0,0,0,0,1)
      call binomx(te,1,i,zz,i,i,z,i,i,0,l,0,0,0,0,0,0,1)
      call polyn(t,te,a22,-20,1,i)
      do 70  k = 1,i
      jorder = order2 - k
      do 60  j = 1,jorder
      ij = indexx(j,i,k,i,idum)
      x = a1117 * ( gibbs(ij) /twnty9- z(ij) /twelve)
      if( j.eq.1 )  x = x + h(k)
      if( j.le.2 )  x = x + p1(j) * ta(k)
      if( ( j.eq.1 ) .and. ( k.le.10 ) )  x = x + s(k)
      if( j.le.4 )  x = x + tb(k) * pa(j)
      if( k.le.21 )  x = x + tc(k) * pb(j)
      if( ( k.le.2 ) .and. ( j.le.4 ) )  x = x + td(k) * p3(j)
      if( j.le.5 )  x = x + te(k) * p4(j)
      gibbs(ij) = x
   60 continue
   70 continue
   75 gibbs(1) = gibbs(1) + (alpha0 + alpha1*t)
      if( l.le.0 )  return
      ij = indexx(1,i,2,i,idum)
      gibbs(ij) = gibbs(ij) + alpha1
      return
c     region 2
c
   80 continue
      l2 = min0( i,2 )
      l6 = min0( i,6 )
      l7 = min0( i,7 )
      call polyn(p,p2,1.0,2,1,l3)
      call polyn(p,p5,1.0,5,1,l6)
      call polyn(p,p6,1.0,6,1,l7)
      call polyn(p,p11,1.0,11,1,l12)
      t1(1) = xiota1 * t
      t1(2) = xiota1
      x =  exp(bl*(1.0-t))
      pb(1) = log( p )
      i1 = i - 1
      call polyn(p,pb(2),1.0,-1,1,i1)
      call polyn(t,s,sb,isb,5,l5)
      call eder(ta,x,b6,bl,2,jx6,l)
      call binomx(ta,1,i,p4,l5,1,z,l5,i,0,l,0,0,0,0,0,0,1)
      call eder(ta,x,bl61,bl,1,14,l)
      call binomx(ta,1,i,p4,l5,1,zz,l5,i,0,l,0,0,0,0,0,0,1)
      zz(1) = 1.0 + zz(1)
      call binomx(gibbs,i,i,zz,l5,i,z,l5,i,0,l,0,0,0,0,0,0,0)
      call eder(ta,x,b7,bl,2,jx7,l)
      call binomx(ta,1,i,p5,l6,1,z,l6,i,0,l,0,0,0,0,0,0,1)
      call eder(ta,x,bl71,bl,1,19,l)
      call binomx(ta,1,i,p5,l6,1,zz,l6,i,0,l,0,0,0,0,0,0,1)
      zz(1) = 1.0 + zz(1)
      call binomx(y,i,i,zz,l6,i,z,l6,i,0,l,0,0,0,0,0,0,0)
      call binomx(pb,i,1,t1,1,l2,z,i,i,0,l,0,0,0,0,0,0,1)
      imax = (i*(i+1))/2
      do 82  j = 1,imax
   82 gibbs(j) = gibbs(j) + y(j) + z(j)
      call eder(ta,x,b8,bl,2,jx8,l)
      call binomx(ta,1,i,p6,l7,1,z,l7,i,0,l,0,0,0,0,0,0,1)
      call eder(ta,x,bl8,bl,2,jlx8,l)
      call binomx(ta,1,i,p6,l7,1,zz,l7,i,0,l,0,0,0,0,0,0,1)
      zz(1) = 1.0 + zz(1)
      call binomx(y,i,i,zz,l7,i,z,l7,i,0,l,0,0,0,0,0,0,0)
      do 84  j = 1,imax
   84 gibbs(j) = gibbs(j) + y(j)
      call eder(ta,x,b9,bl,7,isb,l)
      call binomx(ta,1,i,p11,l12,1,zz,l12,i,0,l,0,0,0,0,0,0,1)
      ipsl = l3 - 1
      call psatl(taz,t,ipsl)
      call binomx(taz,1,l3,taz,1,l3,y,1,l21,0,l,0,0,0,0,0,0,1)
      call binomx(y,1,l21,y,1,l21,ta,1,l21,0,l,0,0,0,0,0,0,1)
      call binomx(ta,1,l21,ta,1,l21,z,1,l21,0,l,0,0,0,0,0,0,1)
      call binomx(z,1,l21,y,1,l21,ta,1,l21,0,l,0,0,0,0,0,0,1)
      call binomx(z,i,i,ta,1,l21,zz,l12,i,0,l,0,0,0,0,0,0,0)
      call eder(ta,x,b5,bl,3,jx5,l)
      call binomx(ta,1,i,p5,l6,1,zz,i,i,0,l,0,0,0,0,0,0,1)
      call eder(ta,x,b4,bl,2,jx4,l)
      call binomx(ta,1,i,p4,l5,1,y,i,i,0,l,0,0,0,0,0,0,1)
      do 90  j = 1,imax
   90 gibbs(j) = gibbs(j) + z(j) + zz(j) + y(j)
      call eder(ta,x,b3,bl,2,jx3,l)
      call binomx(ta,1,i,p3,l4,1,z,i,i,0,l,0,0,0,0,0,0,1)
      call eder(ta,x,b2,bl,3,jx2,l)
      call binomx(ta,1,i,p2,l3,1,y,i,i,0,l,0,0,0,0,0,0,1)
      call eder(ta,x,b1,bl,2,jx1,l)
      call binomx(ta,1,i,p1,l2,1,zz,i,i,0,l,0,0,0,0,0,0,1)
      do 95  j = 1,imax
   95 gibbs(j) = gibbs(j) + z(j) + y(j) + zz(j)
      do 110  k = 1,i
      jorder = order2 - k
      do 100  j = 1,jorder
      ij = indexx(j,i,k,i,idum)
      x = gibbs(ij)
      if(j.eq.1)  x = x + h(k)
      if((j.eq.1).and.(k.le.l5)) x = x + s(k)
      gibbs(ij) = x
  100 continue
  110 continue
      go to 75
      end
      subroutine helmcd ( helms,vin,tin,l,ireg )
c
$if def,in32,1
       implicit real*8(a-h,o-z)
c     computes the v and t derivatives to order l of the helmholtz
c        function for region ireg ( 3 or 4 )
c
      common /asmcon/ thetat,theta1,theta2,theta3,betaa1,betaa2,
     1 betaat,alpha0,alpha1,xiota1
c
      common / asme34 / c0(13),c1(7),c2(8),c3(10),c4(2),c50,c6(5),c7(9),
     1                 d3(5),d4(5),d5(3)
c
      dimension helms(1)
c     the following dimensions limit the order to 9 or less
c     w, q, and x should be dimensioned at least (o+2)*(o+3)/2
c     p, r, s, and u should be dimensioned at least (o+2)
c        total common dimensions should be at least 5*(o+1)*(o+2)/2
      common / dumzzz / q(66),w(66),x(66),p(11),r(11),s(11),
     1 u(11),dduumm(33)
c
      dimension tm1d(2),tm2d(3),tm3d(4),tm9d(10),vx6(7)
      dimension jc(12),jc4(2),jc7(10),jd(5)
c
      data jc / 0,1,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10 /
      data jc4 / 0,-5 /
      data jc7 / 0,1,2,3,4,5,6,7,8,9 /
      data jd / 0,-1,-2,-3,-4 /
c
c
      v = vin
      t = tin
      i = l + 1
c
c     region 3 and 4
c
      l2 = min0( i,2 )
      l3 = min0( i,3 )
      l4 = min0( i,4 )
      l7 = min0( i,7 )
      l10 = min0( i,10 )
      imax = (i*(i+1))/2
      tm1 = t - 1.0
      call polyn(tm1,tm1d,1.0,1,1,l2)
      call polyn(tm1,tm2d,1.0,2,1,l3)
      call polyn(tm1,tm3d,1.0,3,1,l4)
      call polyn(tm1,tm9d,c7,jc7(2),9,l10)
      call polyn(v,vx6,1.0,6,1,l7)
      call polyn(v,p,c0,jc,12,i)
      q(1) = log(v)
      if( l.gt.0 )  call polyn(v,q(2),1.0,-1,1,l)
      call polyn(v,r,c1,jc(2),6,i)
      call polyn(v,s,c2,jc(2),7,i)
      call polyn(v,u,c3,jc(2),9,i)
      do 10  j = 1,i
      p(j) = p(j) + c0(13)*q(j)
      r(j) = r(j) + c1(7)*q(j)
      s(j) = s(j) + c2(8)*q(j)
   10 u(j) = u(j) + c3(10)*q(j)
      call binomx(p,i,1,1.0,1,1,helms,i,i,0,l,0,0,0,0,0,0,1)
      call binomx(r,i,1,tm1d,1,l2,w,i,i,0,l,0,0,0,0,0,0,1)
      call binomx(s,i,1,tm2d,1,l3,q,i,i,0,l,0,0,0,0,0,0,1)
      call binomx(u,i,1,tm3d,1,l4,x,i,i,0,l,0,0,0,0,0,0,1)
      do 15  j = 1,imax
   15 helms(j) = helms(j) + w(j) + q(j) + x(j)
      qxx = log(t)
      p(2) = c50*( qxx + 1.0 ) + alpha1
      p(1) = alpha0 + t*(c50*qxx + alpha1)
      i2 = i - 2
      if( i2.gt.0 )  call polyn(t,p(3),c50,-1,1,i2)
      call polyn(t,r,1.0,-23,1,i)
      call polyn(v,s,c4,jc4,2,i)
      call binomx(s,i,1,r,1,i,w,i,i,0,l,0,0,0,0,0,0,1)
      call binomx(w,i,i,tm1d,1,l2,q,i,i,0,l,0,0,0,0,0,0,1)
      do 20  j = 1,imax
   20 helms(j) = helms(j) + q(j)
      call polyn(t,r,c6,jc(4),5,i)
      call binomx(p,1,i,1.0,1,1,w,i,i,0,l,0,0,0,0,0,0,1)
      call binomx(tm9d,1,l10,1.0,1,1,q,i,i,0,l,0,0,0,0,0,0,1)
      call binomx(vx6,l7,1,r,1,i,x,i,i,0,l,0,0,0,0,0,0,1)
      do 30  j = 1,imax
   30 helms(j) = helms(j) + w(j) + x(j) + q(j)
      if( ireg.eq.3) go to 70
c
c
c     region 4
c
      y0 = 1.0/(theta1-1.0)
      y032 = y0**32
      y03 = y0**3
      y04 = y0**4
      l5 = min0( i,5 )
      l33 = min0( i,33 )
      call polyn(tm1,p,y032,32,1,l33)
      call polyn(tm1,tm3d,y03,3,1,l4)
      call polyn(tm1,tm9d,y04,4,1,l5)
      call polyn(v,tm2d,d5,jc7,3,l3)
      call polyn(v,r,d3,jd,5,i)
      call polyn(v,s,d4,jd,5,i)
      call binomx(tm3d,1,l4,r,i,1,q,i,i,0,l,0,0,0,0,0,0,1)
      call binomx(tm9d,1,l5,s,i,1,w,i,i,0,l,0,0,0,0,0,0,1)
      call binomx(p,1,l33,tm2d,l3,1,x,i,i,0,l,0,0,0,0,0,0,1)
      do 60  j = 1,imax
      helms(j) = helms(j) + q(j) + w(j) + x(j)
   60 continue
   70 continue
      return
      end
      function indexx(i,im,j,jm,ip)
c
$if def,in32,1
       implicit real*8(a-h,o-z)
c     this routine computes the location index of a packed single
c     dimensioned array that cooresponds to a double-dimensioned
c     array (i,j) where only the upper portion of the 2-d array is used
c
c     ip is the maximum number of elements in the j-th row
c     im is the maximum dimension in the i-th direction
c     jm is the maximum dimension in the j-th direction
c
      ip = min((max(jm,im) - j), im - 1) + 1
      k = max((ip-i), 0 )
      l = min(j, max(im-jm+j, 0) )
      indexx = j*im - k - (l*(l-1))/2
      return
      end
      function polatt(xy,xx,nn,kk)
c
$if def,in32,1
       implicit real*8(a-h,o-z)
      dimension xy(2*nn)
c
c      xy is a table of y(1),x(1),y(2),x(2),...y(nn),x(nn)
c      xx is the given x
c      nn is the number of pairs of (y,x)
c        note...nn is treated as a positive integer greater than zero
c            if nn.lt.1, assume nn=1
c            if nn.eq.1, return y(1)
c      kk is both the initial position guess and the final returned
c        position index value
c
c      if x is out if the range x(1) to x(nn), then a straight line
c        interpolation is made from the nearest pair of points
c
      x = xx
      n = abs(nn)
      k = max(1,min(n-1,kk))
      if( n.gt.1 )  go to 10
c
c        only one pair
      polatt= xy(1)
      kk = 1
      return
c
c        check index memory
c
c        decrease index if necessary
   10 if( xy(2*k)-x )  30,30,20
   20 if( k.eq.1 )  go to 100
      k = k - 1
      go to 10
c
c        increase index if necessary
   30 if( x-xy(2*k+2) )  100,100,40
   40 if( k.eq.n-1 )  go to 100
      k = k + 1
      go to 30
c
c        interpolate straight line
  100 kk = k
      polatt = xy(2*k-1) + (x-xy(2*k))*(xy(2*k+1)-xy(2*k-1))/
     1                                 (xy(2*k+2)-xy(2*k))
      return
      end
      subroutine polyn ( x,f,a,ib,m,n )
c
$if def,in32,1
       implicit real*8(a-h,o-z)
c     for the function f=sum from 1 to m of a(i)*x**ib(i)
c        calculate the n-1 derivatives
c
c     note:  the number of terms in the sum, m, is limited by the
c        dimensions of the intermediate variable z
c     which is 20
c
c     x is the main variable
c     f is the function      computed
c     a is the array a(i)
c     ib is the array ib(i)
c     m is the limit of the sum and also the dimensions of a and ib
c     n is the dimensions of f where derivatives to the order n-1
c        are calculated
c
      dimension f(1), a(1), ib(1)
      dimension z(20)
c
      limit = n
      msum = m
      if( x.eq.0.0 )  go to 40
      sum = 0.0
      do 10  i = 1,msum
      c = a(i)
      k = ib(i)
      c = c * x**k
      sum = sum + c
      z(i) = c
   10 continue
      f(1) = sum
      if( limit.le.1 )  return
      rx = 1.0/x
   15 do 30 j = 2,limit
      c = 2 - j
      sum = 0.0
      do 20  i = 1,msum
      e = ib(i)
      d = ( c+e ) * z(i) * rx
      sum = sum + d
      z(i) = d
   20 continue
      f(j) = sum
   30 continue
      return
   40 do 70  j = 1,limit
      sum = 0.0
      do 60  i = 1,msum
      c = 0.0
      k = ib(i)
      if( (k-j+1).ne.0 )  go to 60
      c = a(i)
      do 50  l = 1,j
      icz = k-l+1
      if( icz.eq.0 )  go to 55
      cz = icz
   50 c = c*cz
   55 sum = sum + c
   60 continue
   70 f(j) = sum
      return
      end
      subroutine psatk(p,t,io)
$if def,in32,1
       implicit real*8(a-h,o-z)
c
      common / asmesl / ak(10), be(4), f(2), blx(3)
c
c     the following dimensions limit the order to 9 or less
c        total common dimensions should be at least 5*(o+1)*(o+2)/2
      common / dumzzz / ddzzm(253),z(11),dduumm(11)
c
      dimension p(1)
      dimension d(6),e(4),g(3),ik(6)
c
      data ik / 0,1,2,3,4,5/
c
      k = io + 1
      x = t - 1.0
      x2 = x * x
      f(1) = x
      g(1) = ak(9) + ak(8) * x2
      g(3) = 2.0 * ak(8)
      g(2) = x* g(3)
      j6 = min0(k,6)
c     calculate the derivatives of sum( (-1)**i * k(i)*(t-1)**2   into d
      call polyn(x,d,ak,ik(2),5,j6)
      j4 = min0(k,4)
c     derivatives of t*(1-k6*(t-1)+k7*(t-1)**2)    into e
      call polyn(x,e,be,ik,4,j4)
c     calculate the derivatives of d/e and store in p
      call binomx(p,1,k,e,1,j4,d,1,j6,-1,io,0,0,0,0,0,0,0)
c     derivatives of (t-1)/(k9+k8*(t-1)**2)   into z
      call binomx(z,1,k,g,1,3,f,1,2,-1,io,0,0,0,0,0,0,0)
c     calculate the derivatives of the exponent and store in z
      do 20  i = 1,k
      z(i) = p(i) + z(i)
   20 continue
c     calculate the derivatives of psat and store in p
      p(1) =  exp(z(1))
      call binomx(p,1,k,z,1,k,p,1,k,-1,io,0,0,0,1,0,1,1)
      return
      end
      subroutine psatl(p,t,iorder)
c
$if def,in32,1
       implicit real*8(a-h,o-z)
c     this routine calculates the l function (pressure) and the
c     derivatives with respect to temperature
c
      common / asmesl / ak(10), be(4), f(2), blx(3)
c
      dimension ibl(3)
      dimension p(1)
      data ibl/ 0,1,2 /
c
      k = iorder + 1
      j3 = min0(k,3)
      call polyn(t,p,blx,ibl,3,j3)
      return
      end
      subroutine root(xroot,a,b,c,d,ieq,nogo)
$if def,in32,1
       implicit real*8(a-h,o-z)
      logical nogo , test
c        nogo is returned true if iteration fails....output only
c
c     compute the root of f(x,a,b,c,d) bounded between (xmin,xmax)
c
c     the function is defined by the value of ieq
c     the iteration precision is error
c     if the entered value of x is zero, then the limit average is used
c
c
      common / errpvt / stater(10),erpres,erair,amagz,btmp(10),
     1 topp(10),btmm(10),topm(10),ixpcn
c
      common / rootlm / vmin4(22),vmax4(22),vmin3m(22),vmax3m(22),
     1 vmin3p(22),vmax3p(22),ptop(3),i4s,i3ps,i3ms,nvpair
c
      common / satlin / tpsat(42), itpsat, ntpsat
c
cxxx  this and following line and sign function following end
cxxx  are to be removed when compiler error on masscomp is fixed.
      dimension tp23(8)
*call efiless
*call efilesd
      data tp23/.962, .7475, 1.07, 1.27, 1.2, 2.55
     1 ,1.334 , 4.525 /
      data ntp23 / 4 /
      data intp23 / 1 /
      data im,i,m /-1,1,100/
c
      nogo = .false.
      x = xroot
      ityp = 0
      xold = 0.0
      x1old = 0.0
      x2old = 0.0
      f = 0.0
      xest = 0.0
      iea = abs( ieq )
      if( ieq.lt.0 )  go to 10
      xmin = btmp( ieq )
      xmax = topp( ieq )
      go to 20
   10 xmin = btmm( iea )
      xmax = topm( iea )
      if( ieq.ne.-2 )  go to 14
      if( a.le.tpsat(2) )  go to 20
      if( a.gt.tp23(2) )  go to 12
      xmin = (1.0-1.0e-2)*polatt(tpsat,a,ntpsat,itpsat)
      go to 20
   12 xmin = polatt(tp23,a,ntp23,intp23)
      go to 20
   14 if( ieq.ne.-1 )  go to 20
      if( a.gt.tp23(2) )  go to 20
      xmax = (1.0+1.0e-2)*polatt(tpsat,a,ntpsat,itpsat)
   20 j = 0
      zpp = ptop(1)
      if( ieq.ne.3 )  go to 60
      if( b.lt.1.0 )  go to 50
      x1m = polatt(vmin3p,b,nvpair,i3ps)
      x2m = polatt(vmax3p,b,nvpair,i3ps)
      call psatl(zpz,b,0)
      if( b.gt.vmax3p(14) )  go to 40
      pz = ptop(2)*b + ptop(3)
      if( a.lt.pz )  go to 30
      x2m = 1.0
      zpz = pz
      go to 40
   30 x1m = 1.0
      zpp = pz
   40 x = zpz
      if( zpz.eq.zpp )  go to 80
      x = (a*(x2m-x1m)+zpz*x1m-zpp*x2m)/(zpz-zpp)
      go to 80
   50 x1m = polatt(vmin3m,b,nvpair,i3ms)
      x2m = polatt(vmax3m,b,nvpair,i3ms)
      xmin = btmp(10)
      call psatl(zpz,b,0)
      call psatk(zpp,b,0)
      go to 40
   60 if( ieq.ne.4 )  go to 70
      x1m = polatt(vmin4,b,nvpair,i4s)
      x2m = polatt(vmax4,b,nvpair,i4s)
      call psatk(zpz,b,0)
      go to 40
   70 if( ieq.gt.-5 )  go to 80
      x = polatt(tpsat,a,ntpsat,itpsat)
   80 dx = (xmax-xmin)*1.0e-2
      if( (x.gt.xmin).and.(x.lt.xmax) )  go to 90
      x = (xmin + xmax)*0.5
   90 x1 = max( x-dx,xmin )
      x2 = min( x+dx,xmax )
      if( j.ne.0 )  go to 95
      if( (xroot.lt.xmin).or.(xroot.gt.xmax) )  go to 95
      if( xroot.gt.x )  x2 = xroot
      if( xroot.lt.x )  x1 = xroot
   95 continue
      if( x1.eq.x1old )  go to 100
      f1 = funx(x1,a,b,c,d,ieq)
      x1old = x1
      f1s = sign(1.0,f1)
      if(  abs(f1).gt.stater(10) ) go to 100
      x = x1
      go to 320
  100 if( x2.eq.x2old )  go to 110
      f2 = funx(x2,a,b,c,d,ieq)
      x2old = x2
      f2s = sign(1.0,f2)
      if(  abs(f2).gt.stater(10) ) go to 110
      x = x2
      go to 320
  110 if( x.eq.xold )  go to 130
  120 f = funx(x,a,b,c,d,ieq)
      fs = sign(1.0,f)
      if(  abs(f).le.stater(10) ) go to 320
  130 continue
      if( (f1.eq.f).or.(f.eq.f2).or.(f2.eq.f1) )  go to 140
      z1 = f2/(f1-f)
      z2 = f1/(f-f2)
      z3 = f/(f2-f1)
      xest = -(x*z1*z2+x1*z1*z3+x2*z2*z3)
      go to 150
  140 xest = -1.0e10
  150 test = .false.
      xold = x
      if( fs*f1s.lt.0.0 )  go to 170
      if( fs*f2s.lt.0.0 )  go to 160
      test = .true.
      if( (xest.lt.xmin).or.(xest.gt.xmax) )  go to 200
      x = xest
      go to 220
  160 f1 = f
      f1s = fs
      x1 = x
      go to 180
  170 f2 = f
      f2s = fs
      x2 = x
  180 if( (xest.lt.x1).or.(xest.gt.x2) )  go to 190
      ityp = 1
      x = xest
      go to 220
  190 i = i*im
      if( i.gt.0 )  go to 210
  200 if( f2.eq.f1 )  go to 210
      x = (x1*f2-x2*f1)/(f2-f1)
      ityp = 2
      go to 220
  210 x = (x1+x2)*0.5
      ityp = 3
  220 j = j + 1
      if( j.gt.m )  go to 310
      if( x.ne.0.0 )  go to 230
      e =  abs(x-xold)
      go to 240
  230 e =  abs( (x-xold)/x  )
  240 if( e.gt.stater(iea) )  go to 250
      if( test )  go to 310
      if( ityp.gt.2 )  go to 200
      go to 320
  250 if( .not.test )  go to 120
c     solution is not bracketed
      dx = dx*2.0
      ityp = 4
      fest = 1.0e10
      xest = x
      x = xold
      if( (xest.gt.xmin).and.(xest.lt.xmax) )
     1 fest = funx(xest,a,b,c,d,ieq)
      if(  abs(fest).gt.stater(10) )  go to 260
      x = xest
      go to 320
  260 festdb =  abs( fest )
      fdb1 =  abs( f1 )
      fdb2 =  abs( f2 )
      fdb  =  abs( f  )
      fmin = min(fdb1,fdb2,fdb,festdb)
      if( fmin.ne.fdb1 )  go to 270
      x = x1
      f = f1
      fs = f1s
      go to 290
  270 if( fmin.ne.fdb2 )  go to 280
      x = x2
      f = f2
      fs = f2s
      go to 290
  280 if( fmin.ne.festdb )  go to 300
      x = xest
      f = fest
      fs =  sign(1.0,fest)
  290 xold = x
  300 if( (x1.ne.xmin).or .(x2.ne.xmax) )  go to 90
  310 nogo = .true.
      write (output,101) ieq,j,x,f,x1,f1,x2,f2,xest,xold,xmax,xmin,dx,
     1 stater(iea),x,a,b,c,d
  101 format(1h ,22hiteration fail in root,10x,16hequation number=,
     1 i5,10x,17hiteration number=,i5//1h ,27x,1hx,19x,4hf(x)/1h ,
     212x,7hcurrent,1x,e15.8,5x,e15.8/1h ,12x,5hlower,3x,e15.8,5x,e15.8/
     3 1h ,12x,5hupper,3x,e15.8,5x,e15.8/1h ,12x,5hxest=,3x,e15.8/1h ,
     412x,6hold x=,2x,e15.8/1h ,12x,6hmax x=,2x,e15.8/1h ,12x,6hmin x=,
     5 2x,e15.8/1h ,12x,6hdel x=,2x,e15.8/1h ,12x,6herror=,2x,e15.8/1h0,
     6 10x,9hx,a,b,c,d/1h ,10x,5e20.8)
  320 xroot = x
      return
      end
      subroutine units(c,i)
$if def,in32,1
       implicit real*8(a-h,o-z)
      dimension c(10)
c
c      given type i, return units conversion constants
c            where
c                i=1, english
c                i=2, metric (mks)
c
      common /eunits/ crp,crt,crv,crh,crs,t0,jc,gc,sqjc,sonic2
      real   jc
c        english units
c
      common / munits / crpm,crtm,crvm,crhm,crsm,t0m,jcm,gcm,sqjcm,
     1 sonicm
      real   jcm
c        munits contains metric units (mks) conversion factors
c        pressure in n/m2, temperature in k, specivic volume in m3/kg,
c        enthalpy in j/kg, entropy in j/kg-k, gravity in m/sec2,
c        velocity in m/sec
c
      if (i .eq. 2) go to 20
      c(1) = crp
      c(2) = crt
      c(3) = crv
      c(4) = crh
      c(5) = crs
      c(6) = t0
      c(7) = jc
      c(8) = gc
      c(9) = sqjc
      c(10) = sonic2
      return
   20 c(1) = crpm
      c(2) = crtm
      c(3) = crvm
      c(4) = crhm
      c(5) = crsm
      c(6) = t0m
      c(7) = jcm
      c(8) = gcm
      c(9) = sqjcm
      c(10) = sonicm
      return
      end
      subroutine writea(a,i,j,ipage)
$if def,in32,1
       implicit real*8(a-h,o-z)
      logical nopage
c     input ipage (page number), if negative then no page
      dimension a(1)
c     print the triangular array a(i,j) when a is single dimension
c     of m=i*j-l*(l-1)/2, l=min0(i,j)
c
c
c     if j.ge.0, then the normal array is written
c     if j.lt.0, then the binomial square array is written
c     normal array      1 2 3 4
c                       5 6 7
c                       8 9
c                       10
c
c     binomial array    1
c                       2 3
c                       4 5 6
c                       7 8 9 10
c
c
      external indexx
*call efiless
*call efilesd
      data lpp, npl / 57, 10 /
      nopage = .false.
      if( ipage.lt.0 )  nopage = .true.
      ja = j
      if( j.lt.0 )  ja = i
      il = (i-1)/npl + 1
      jl = (ja-1)/lpp + 1
      do 60  ix = 1,il
      mi = (ix-1) * npl + 1
      iq2 = min0( npl*ix, i )
      do 50  jx = 1,jl
      n1 = (jx-1) * lpp + 1
      n2 = min0( n1 + lpp - 1, ja )
      if( nopage )  go to 5
      ipage = ipage + 1
      write (output,101) ipage, (iw, iw=mi,iq2)
  101 format(1h1,120x,5hpage=,i5/1h ,2x,5hj / i,3x,i3,9(9x,i3))
      go to 8
    5 write (output,104) (iw,iw=mi,iq2)
  104 format(1h ,2x,5hj / i,3x,i3,9(9x,i3))
    8 continue
      do 40  nx = n1,n2
      if( j.ge.0 )  go to 10
      mn = (nx*(nx-1))/2
      m1 = mi + mn
      mz = min0(nx,npl)
      mz = min0(m1+mz-1,mn+nx)
      md = mz - m1
      go to 20
   10 m1 = indexx(mi,i,nx,ja,iele)
      md = min0(iele-mi,npl-1)
   20 if(md.ge.0)  go to 30
      write (output,103) nx
  103 format(1h ,i3)
      go to 40
   30 m2 = m1 + md
      write (output,102) nx, (a(m),m=m1,m2)
  102 format (' ',i3,3x,1p,10e12.5)
   40 continue
   50 continue
   60 continue
      return
      end
      subroutine iasme(ioi)
c
$if def,in32,1
       implicit real*8(a-h,o-z)
c     asme steam table initialization routine
c     this routine must be called once for proper initialization
c
c     this subroutine computes the binomial coefficients
c       binomc(i,m) = (m-1)(m-2)(m-3)...(m-i+1)/(i-1)
c        and stores the results in binomc(l) where l=i+m(m-1)/2
c     factorials are computed
c        fktorl(k)=(k-1)
c
c
c     let ioi=order of the expansion, then
c        the binomial coefficients should be dimensioned at least
c        as large as (io+2)*(io+3)/2
c        and the factorials by (io+1)
c     dimensions limit expansion to 9-th order or less
c
c
c        constants appearing in the common blocks refer to the 1967
c        asme data using the same basic nomenclature.
c        common block names refer to the subregions as defined by asme.
c
      common / asme1 / a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,
     1 a14,a15,a16,a17,a18,a19,a20,a21,a22,al1,al2,al3,al4,al5,al6,al7,
     2 al8,al9,al10,al11,al12,
     3                 b0,b01,b02,b03,b04,b05,b11,b12,b21,b22,b23,b31,
     4 b32,b41,b42,b51,b52,b53,b61,b62,b71,b72,b81,b82,b90,b91,b92,
     5 b93,b94,b95,b96,bl,bl61,bl71,bl81,bl82,
     6 p1(2),tapa(2),tbpa(2),ya(3),tca(2),td(2),gpower,a1117,t1(2),
     7 twelve,sevent,twnty9
      dimension a(35)
      dimension b(36)
      equivalence ( a0,a(1) )
      equivalence ( b0,b(1) )
c     signs are reversed from the asme for b11,b12,b21,b22,b23,b31,b32,
c      b41,b42,b51,b52,b53,b61,b62,b71,b72,b81,b82
c
      common / asme34 / c00,c01,c02,c03,c04,c05,c06,c07,c08,c09,c010,
     1 c011,c012,c11,c12,c13,c14,c15,c16,c17,c21,c22,c23,c24,c25,c26,
     2 c27,c28,c31,c32,c33,c34,c35,c36,c37,c38,c39,c310,c40,c41,c50,
     3 c60,c61,c62,c63,c64,c70,c71,c72,c73,c74,c75,c76,c77,c78,
     4                 d30,d31,d32,d33,d34,d40,d41,d42,d43,d44,d50,
     5 d51,d52
      dimension c(55)
      equivalence ( c00,c(1) )
      dimension d(13)
      equivalence ( d30,d(1) )
c
      common / asmesl / ak1,ak2,ak3,ak4,ak5,ak6,ak7,ak8,ak9,akl,
     1 be(4), f(2), blx(3)
      dimension ak(10)
      equivalence ( ak1,ak(1) )
c     signs of k1,k3,k5, and k6 are reversed from asme
c     akl or ak(10) is the "l" from asme
c
      common / errpvt / stater(10),erpres,erair,amagz,btmp(10),
     1 topp(10),btmm(10),topm(10),ixpcn
c     stater is the error limits for root
c     erpres is the accuracy in press (p,t) calculation
c     erair is the accuracy in state (air head) calculation
c     amagz is 1.e-30. if du**n or dr**n is less than this in press
c        the result is set to zero to prevent underflow
c     btmp,topp,btmm,topm are the limits on root equations
c     ixpcn is the number of expansions (calls to xpndr)
c
      common / rootlm / vmin4(22),vmax4(22),vmin3m(22),vmax3m(22),
     1 vmin3p(22),vmax3p(22),ptop(3),i4s,i3ps,i3ms,nvpair
c
c     rootlm contains pairs of v,t which define the boundries
c        of regions 3 and 4
c
      common / satlin / tpsat(42), itpsat, ntpsat
c     tpsat contains approximate tsat as a function of psat for root
c
      common /asmcox/ ca,cb,cc,cd,ce,cf,cg,ch,ci
c
c     data values are input for iasme which calculates thetat, etc.
c     note that iasme calculates the residuals alpha0 and alpha1
c        which depend upon the actual digital machine used
c
      common /asmcon/ thetat,theta1,theta2,theta3,betaa1,betaa2,
     1 betaat,alpha0,alpha1,xiota1
c     these are various boundry values of p and t as given by the asme
c
      common / eunits / crp, crt, crv, crh, crs, t0, jc, gc, sqjc,
     1 sonic2
      real   jc
c     eunits contains english conversion constants
c        crp = critical pressure (3208.__) lbf/in2
c        crt = critical temperature (1165.14) r
c        crv = critical specific volume (.05078__) ft3/lbm
c        crh = specific enthalpy multiplier (30.14--btu/lb)
c              (crh=sqjc*crv*crp)
c        crs = entropy multiplier (.02587--btu/lb-f)  (crs=crh/crt)
c        t0 = temperature difference between r and f (459.67)
c        jc = mechanical equivalent of heat energy (778.16__)
c                                             ft-lbf/btu
c        gc = gravitional conversion factor (32.174__)
c                                      ft-lbm/(sec2-lbf)
c        sqjc = pressure conversion factor, 144/jc
c                                      (in2/ft2)/((ft-lbf)/btu)
c        sonic2=conversion for normalized sonic velocity squared
c
      common / munits / crpm,crtm,crvm,crhm,crsm,t0m,jcm,gcm,sqjcm,
     1 sonicm
      real   jcm
c        munits contains metric units (mks) conversion factors
c        pressure in n/m2, temperature in k, specivic volume in m3/kg,
c        enthalpy in j/kg, entropy in j/kg-k, gravity in m/sec2,
c        velocity in m/sec
c
      common / binfac / binomc(66), fktorl(10)
c
      dimension g(3)
c
$if -def,blkdta,1
       call asmebd
c     calculate factorials
      fktorl(1) = 1.0
      do 10  i = 1,ioi
      x = i
   10 fktorl(i+1) = fktorl(i) * x
c
c     calculate binomial coefficients
      jo = ioi + 2
      do 30  m = 1,jo
      j = 1+(m*(m-1))/2
      binomc(j) = 1.0
      al = 1.0
      am = m
      il = m
      if( m.eq.1 ) go to 30
      do 20  i = 2,il
      x = i - 1
      al = ( al * ( am-x ) ) / x
      k = i+j-1
      binomc(k) = al
   20 continue
   30 continue
      thetat = ca/ce
      theta1 = cb/ce
      theta2 = cc/ce
      theta3 = cd/ce
      betaa2 = ch/cf
      xiota1 = ci/cg
      alpha0 = 0.0
      alpha1 = 0.0
      call psatk(betaat,thetat,0)
      call psatk(betaa1,theta1,0)
      call gibbab(g,betaat,thetat,1,1)
      alpha1 = -g(3)
      alpha0 = -(g(1) - betaat*g(2) - thetat*g(3))
      return
      end
$if -def,blkdta,1
       subroutine asmebd
$if def,blkdta,1
       block data asmebd
c  Contains data statements for data loaded into common blocks in asme
c  subroutines.
c
$if def,in32,1
       implicit real*8(a-h,o-z)
c
      common / asme1 / a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,
     1 a14,a15,a16,a17,a18,a19,a20,a21,a22,al1,al2,al3,al4,al5,al6,al7,
     2 al8,al9,al10,al11,al12,
     3                 b0,b01,b02,b03,b04,b05,b11,b12,b21,b22,b23,b31,
     4 b32,b41,b42,b51,b52,b53,b61,b62,b71,b72,b81,b82,b90,b91,b92,
     5 b93,b94,b95,b96,bl,bl61,bl71,bl81,bl82,
     6 p1(2),tapa(2),tbpa(2),ya(3),tca(2),td(2),gpower,a1117,t1(2),
     7 twelve,sevent,twnty9
      dimension a(35)
      dimension b(36)
      equivalence ( a0,a(1) )
      equivalence ( b0,b(1) )
c
      common / asme34 / c00,c01,c02,c03,c04,c05,c06,c07,c08,c09,c010,
     1 c011,c012,c11,c12,c13,c14,c15,c16,c17,c21,c22,c23,c24,c25,c26,
     2 c27,c28,c31,c32,c33,c34,c35,c36,c37,c38,c39,c310,c40,c41,c50,
     3 c60,c61,c62,c63,c64,c70,c71,c72,c73,c74,c75,c76,c77,c78,
     4                 d30,d31,d32,d33,d34,d40,d41,d42,d43,d44,d50,
     5 d51,d52
      dimension c(55)
      equivalence ( c00,c(1) )
      dimension d(13)
      equivalence ( d30,d(1) )
c
      common / asmesl / ak1,ak2,ak3,ak4,ak5,ak6,ak7,ak8,ak9,akl,
     1 be(4), f(2), blx(3)
      dimension ak(10)
      equivalence ( ak1,ak(1) )
c
      common / errpvt / stater(10),erpres,erair,amagz,btmp(10),
     1 topp(10),btmm(10),topm(10),ixpcn
c
      common / rootlm / vmin4(22),vmax4(22),vmin3m(22),vmax3m(22),
     1 vmin3p(22),vmax3p(22),ptop(3),i4s,i3ps,i3ms,nvpair
c
      common / satlin / tpsat(42), itpsat, ntpsat
c     tpsat contains approximate tsat as a function of psat for root
c
      common /asmcox/ ca,cb,cc,cd,ce,cf,cg,ch,ci
c
      common /asmcon/ thetat,theta1,theta2,theta3,betaa1,betaa2,
     1 betaat,alpha0,alpha1,xiota1
c
      common / eunits / crp, crt, crv, crh, crs, t0, jc, gc, sqjc,
     1 sonic2
      real   jc
c
      common / munits / crpm,crtm,crvm,crhm,crsm,t0m,jcm,gcm,sqjcm,
     1 sonicm
      real   jcm
c
c     initial constants for the gibbs function
      data  a /         6.824687741e+3,-5.422063673e+2,-2.096666205e+4,
     1  3.941286787e+4,-6.733277739e+4, 9.902381028e+4,-1.093911774e+5,
     2  8.590841667e+4,-4.511168742e+4, 1.418138926e+4,-2.017271113e+3,
     3  7.982692717,   -2.616571843e-2, 1.522411790e-3, 2.284279054e-2,
     4  2.421647003e+2, 1.269716088e-10,2.074838328e-7, 2.174020350e-8,
     5  1.105710498e-9, 1.293441934e+1, 1.308119072e-5,6.047626338e-14,
     6  8.438375405e-1, 5.362162162e-4, 1.720000000,    7.342278489e-2,
     7  4.975858870e-2, 6.537154300e-1, 1.150000000e-6, 1.510800000e-5,
     8  1.418800000e-1, 7.002753165,    2.995284926e-4, 2.040000000e-1/
c
      data  b /         1.683599274e+1, 2.856067796e+1,-5.438923329e+1,
     1  4.330662834e-1,-6.547711697e-1, 8.565182058e-2,-6.670375918e-2,
     2 -1.388983801,   -8.390104328e-2,-2.614670893e-2, 3.373439453e-2,
     3 -4.520918904e-1,-1.069036614e-1, 5.975336707e-1, 8.847535804e-2,
     4 -5.958051609e-1, 5.159303373e-1,-2.075021122e-1,-1.190610271e-1,
     5  9.867174132e-2,-1.683998803e-1, 5.809438001e-2,-6.552390126e-3,
     6 -5.710218649e-4, 1.936587558e+2,-1.388522425e+3, 4.126607219e+3,
     7 -6.508211677e+3, 5.745984054e+3,-2.693088365e+3, 5.235718623e+2,
     8  7.633333333e-1, 4.006073948e-1, 8.636081627e-2,-8.532322921e-1,
     9  3.460208861e-1/
      data p1,tapa,tbpa,ya/0.0,1.0,.115e-5,1.0,.15108e-4,1.0,1.0,
     1 -.8438375405,-.5362162162e-3/
      data tca,td/-.18351354159592e1,-.1293441934e2,0.0,
     1 -.1308119072e-4/
      data gpower,a1117,t1/.7058823529411765,.135705776189e3,0.0,
     1 .4260321147626083e1/
      data twelve,sevent,twnty9/12.0,17.0,29.0/
c
      data c /         -6.839900000,   -1.722604200e-2,-7.771750390,
     1  4.204607520,   -2.768070380,    2.104197070,   -1.146495880,
     2  2.231380850e-1, 1.162503630e-1,-8.209005440e-2, 1.941292390e-2,
     3 -1.694705760e-3,-4.311577033,    7.086360850e-1, 1.236794550e+1,
     4 -1.203890040e+1, 5.404374220,   -9.938650430e-1, 6.275231820e-2,
     5 -7.747430160,   -4.298850920,    4.314305380e+1,-1.416193130e+1,
     6  4.041724590,    1.555463260,   -1.665689350,    3.248811580e-1,
     7  2.936553250e+1, 7.948418420e-6, 8.088597470e+1,-8.361533800e+1,
     8  3.586365170e+1, 7.518959540,   -1.261606400e+1, 1.097174620,
     9  2.121454920,   -5.465295660e-1, 8.328754130,    2.759717760e-6,
     a -5.090739850e-4, 2.106363320e+2, 5.528935335e-2,-2.336365955e-1,
     b  3.697071420e-1,-2.596415470e-1, 6.828087013e-2,-2.571600553e+2,
     c -1.518783715e+2, 2.220723208e+1,-1.802039570e+2, 2.357096220e+3,
     d -1.462335698e+4, 4.542916630e+4,-7.053556432e+4, 4.381571428e+4/
c
      data  d /        -1.717616747,    3.526389875,   -2.690899373,
     1  9.070982605e-1,-1.138791156e-1, 1.301023613,   -2.642777743,
     2  1.996765362,   -6.661557013e-1, 8.270860589e-2, 3.426663535e-4,
     3 -1.236521258e-3, 1.155018309e-3/
c
      data ak/          7.691234564,   -2.608023696e+1, 1.681706546e+2,
     1  6.423285504e+1, 1.189646225e+2,-4.167117320,    2.097506760e+1,
     2  1.000000000e+9, 6.000000000,    7.160997524/
      data be / 1.0,-.316711732e1,.1680795028e2,.209750676e2/
      data blx / .1574373327164132e2,-.3417061978495166e2,
     1 .1931380707202167e2/
      data f / 0.0,1.0 /
c
      data stater / 10*1.e-14 /
      data erpres,erair,amagz / 1.e-8, 2.e-8, 1.e-30 /
      data btmm / 4.17e-1, 4.17e-1, 9.5e-1, 9.5e-1, 4.17e-1,
     1 4.17e-1, 3*0.0,.99 /
      data btmp / 2.7e-5,0.0,.42,.39,0.0,.42,3*0.0,1.0/
      data topm / 9.73e-1,1.675,1.347,3*1.01,4*0.0 /
      data topp / 2*4.57,3.03,1.01,0.,9.73e-1,4*0.0 /
      data ixpcn / 1 /
c
      data ptop / 4.5208, 8.0, -7.0 /
      data vmin4 / .4147,.96269,.4165,.96642,.4183,.97015,
     1 .4202,.97388,.422,.97761,.4239,.98134,.4257,
     2 .98507,.4276,.9888,.4295,.99253,.4315,.99626,
     3 .433472,1.0 /
      data vmax4 / .5491,.96269,.5589,.96642,.5697,.97015,
     1 .582,.97388,.596,.97761,.6122,.98134,.6314,
     2 .98507,.6552,.9888,.6869,.99253,.7675,.99626,
     3 1.0,1.0 /
      data vmin3m / 2.775,.96269,2.489,.97015,2.208,.97761,1.926,
     2 .98507,1.618,.99253,1.425,.99626,
     3 1.37,.9972,1.3,.998,1.23,.9989,1.16,.9996,
     4 1.0,1.0 /
      data vmax3m / 2.775,.96269,2.763,.97015,2.724,.97761,2.667,
     2 .98507,2.599,.99253,2.561,.99626,
     3 2.55,.9972,2.543,.998,2.535,.9989,2.53,.9996,
     4 2.523,1.0 /
      data vmin3p / .4334,1.0,.4522,1.0333,.4737,1.0667,
     1 .499,1.1,.529,1.1333,.5641,1.1667,.6044,1.2,
     2 .6499,1.2334,.7005,1.2667,.7556,1.3001,.8138,
     3 1.3335 /
      data vmax3p / 2.523,1.0,2.1473,1.0333,1.7885,1.0667,
     1 1.49722,1.1,1.2864,1.1333,1.141104,1.1667,
     2 1.03912,1.2,.96374,1.2334,.9047,1.2667,
     3 .85595,1.3001,.81386,1.3335 /
      data nvpair,i4s,i3ps,i3ms / 11,6,6,6 /
c
      data tpsat/.4219990730727638,2.763311031525152e-5,.476068,
     1   .254266e-3,  .530137,  .140926e-2,  .584207,
     2   .546246e-2,  .638276,  .1634e-1,  .692345,
     3   .403503e-1,  .746414,  .862519e-1,  .800484,
     4   .165122,  .854553,  .290252,  .908622,
     5.477451,.9626911787424687,.7475191707224011,.966422,
     6   .769969,  .970153,  .792987,  .973884,
     7   .816593,  .977615,  .840803,  .981346,
     8   .865640,  .985076,  .891123,  .988807,
     9   .917276,  .992538,  .944122,  .996269,
     a   .971687,  .1e1,  .100000001e1 /
      data itpsat,ntpsat / 10,21 /
c
      data ca,cb,cc,cd,ce,cf,cg,ch,ci /
     1                27316., 62315., 86315., 107315.,
     2 64730., 2212., 70120400.,1.e4,      298735423. /
c
      data thetat,theta1,theta2,theta3,betaa1,betaa2,betaat,alpha0,
     1 alpha1,xiota1 /   4.219990730727638e-1,9.626911787424687e-1,
     2 1.333462073227251, 1.657886605901437, 7.475191707224011e-1,
     3 4.520795660036166, 2.763311031525152e-5, 1.041870889323091e-8,
     4 -1.592894943832957e-6, 4.260321147626083 /
c
      data crp, crt, crv, crh, crs, t0, jc, gc, sqjc /
     1 3208.234758592227, 1165.14, .5077852889545364e-1,
     2 30.14634565778160, .2587358228005365e-1, 459.67,
     3 778.1692622659650, 32.17404855643044, .1850497147377472 /
      data sonic2 / .7547697039838524e+6 /
c
      data crpm,crtm,crvm,crhm,crsm,t0m,jcm,gcm,sqjcm,sonicm/
     1 2.212e+7,647.3,.00317,70120.4,108.3275142901282,
     2 273.15,1.0,9.80665,1.0,1.0/
c
$if -def,blkdta,1
       return
       end
