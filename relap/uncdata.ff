        module uncdata
$if def,iua
!  Module holds data needed to support uncertainty analysis.
!
*in32 init
*in32 initu
*in32 ihldr
*in32end
!
!  Cognizant engineer: mpf, rjw.
!
       implicit none
       integer, parameter, private :: kr=selected_real_kind(12,200)
       integer, allocatable :: irunno(:)
       integer krun
       integer :: seed(1)=298341
!       integer*8 :: seedx(1)=298341
       logical tpost,uncrstrt
!  irruno : array containing run numbers for post processing.
!  ktemp : number of runs for post processing (irunno dimension).
!
!  Source uncertainty information matrix.
       type uncdatt
         character*16 unvarnm
         character*2 distrtp
         real(kr) chparam(4)
         real(kr) uncwt
         real(kr) extra
         logical uncw
       end type uncdatt
!
!  Input uncertainty information matrix.
       type uncinpp
         character*2 distrtp
         real(kr) chparam(4)
         real(kr) uncwt
       end type uncinpp
!
       type uncoutt
         real(kr) wt,baseval
         integer cardno,cardw
       end type uncoutt
!
!  unvarnm: alphanumeric name for the multiplier, XXX.YYY.ZZZ where: 
!  XXX represents the affected model; YYY represents correlation;
!  ZZZ represents a correlation subdivision.
!
!  distrtp: distribution type, TT where: TT = ND for Normal 
!  Distribution; TT = UD for Uniform Distribution; TT = TD for 
!  Trapezoidal Distribution; TT = LD for LogNormal Distribution.
!
!  chparam: characteristic parameters for the distributions: 
!    (TT = ND) (1): mean value, (2): standard deviation, (3) and (4)
!    lower and upper truncation in number of standard deviations.
!    (TT = UD) (1): minimum value, (2): maximum value, (3) and (4)
!    not used.
!    (TT = TD) (1): lower left value, (2): upper left value, 
!    (3): upper right value, (4): lower right value.
!    (TT = LD) (1): mean value, (2): standard deviation, (3) and (4)
!    lower and upper truncation in number of standard deviations.
!    corresponding Normal distribution.
!
!  uncwt: uncertainty weight
!
       integer, parameter :: nfrv = 78
       integer, parameter :: nhtc = 60
       integer, parameter :: nchf = 13
       integer, parameter :: ngap = 3
       integer, parameter :: nvis = 4
       integer, parameter :: ncon = 4
       integer, parameter :: nsft = 2
       integer, parameter :: ntungs = 1
       integer, parameter :: noxid = 1
       type (uncdatt) uncfrv (nfrv)
       type (uncdatt) unchtc (nhtc)
       type (uncdatt) uncchf (nchf)
       type (uncdatt) uncgap (ngap)
       type (uncdatt) uncvis (nvis)
       type (uncdatt) unccon (ncon)
       type (uncdatt) uncsft (nsft)
       type (uncdatt) unctungs (ntungs)
       type (uncdatt) uncoxid (noxid)
       type (uncinpp) uncinp (99)
!
!  Data statements
!
!  Flow regime.
       data uncfrv(:)%unvarnm/
     &  'FRV.CTB.HIF', 'FRV.CTB.HIG', 'FRV.CTB.HGF',
     &  'FRV.CTT.HIF', 'FRV.CTT.HIG', 'FRV.CTT.HGF', 
     &  'FRV.CTM.HIF', 'FRV.CTM.HIG', 'FRV.CTM.HGF',
     &  'FRV.BBY.HIF', 'FRV.BBY.HIG', 'FRV.BBY.HGF',
     &  'FRV.SLG.HIF', 'FRV.SLG.HIG', 'FRV.SLG.HGF', 
     &  'FRV.ANM.HIF', 'FRV.ANM.HIG', 'FRV.ANM.HGF',
     &  'FRV.MPR.HIF', 'FRV.MPR.HIG', 'FRV.MPR.HGF',
     &  'FRV.IAN.HIF', 'FRV.IAN.HIG', 'FRV.IAN.HGF',
     &  'FRV.ISL.HIF', 'FRV.ISL.HIG', 'FRV.ISL.HGF',
     &  'FRV.MST.HIF', 'FRV.MST.HIG', 'FRV.MST.HGF', 
     &  'FRV.MPO.HIF', 'FRV.MPO.HIG', 'FRV.MPO.HGF', 
     &  'FRV.HST.HIF', 'FRV.HST.HIG', 'FRV.HST.HGF',
     &  'FRV.VST.HIF', 'FRV.VST.HIG', 'FRV.VST.HGF',
     &  'FRV.LEV.HIF', 'FRV.LEV.HIG', 'FRV.LEV.HGF',
     &  'FRV.JET.HIF', 'FRV.JET.HIG', 'FRV.JET.HGF', 
     &  'FRV.MWY.HIF', 'FRV.MWY.HIG', 'FRV.MWY.HGF', 
     &  'FRV.MWA.HIF', 'FRV.MWA.HIG', 'FRV.MWA.HGF',
     &  'FRV.MAM.HIF', 'FRV.MAM.HIG', 'FRV.MAM.HGF', 
     &  'FRV.MMS.HIF', 'FRV.MMS.HIG', 'FRV.MMS.HGF',
     &  'FRV.MWS.HIF', 'FRV.MWS.HIG', 'FRV.MWS.HGF', 
     &  'FRV.MWP.HIF', 'FRV.MWP.HIG', 'FRV.MWP.HGF', 
     &  'FRV.MPL.HIF', 'FRV.MPL.HIG', 'FRV.MPL.HGF',
     &  'FRV.MPS.HIF', 'FRV.MPS.HIG', 'FRV.MPS.HGF',
     &  'FRV.MSL.HIF', 'FRV.MSL.HIG', 'FRV.MSL.HGF',
     &  'FRV.MPB.HIF', 'FRV.MPB.HIG', 'FRV.MPB.HGF', 
     &  'FRV.MBB.HIF', 'FRV.MBB.HIG', 'FRV.MBB.HGF'/
       data uncfrv(:)%distrtp/nfrv*'UD'/
       data uncfrv(:)%chparam(1) /nfrv*1.0e0/
       data uncfrv(:)%chparam(2) /nfrv*1.0e0/
       data uncfrv(:)%chparam(3) /nfrv*0.0e0/
       data uncfrv(:)%chparam(4) /nfrv*0.0e0/
       data uncfrv(:)%uncwt/nfrv*1.0e0/
       data uncfrv(:)%extra/nfrv*0.0e0/
!uncpackalt       data uncfrv(:)%uncw/nfrv*.false./
       data uncfrv(:)%uncw/nfrv*.true./
!
!  Wall to fluid heat transfer.
       data unchtc(:)%unvarnm/
     & 'HTC.00.101', 'HTC.01.101', 'HTC.02.101', 'HTC.03.101', 
     & 'HTC.04.101', 'HTC.05.101', 'HTC.06.101', 'HTC.07.101', 
     & 'HTC.08.101', 'HTC.09.101', 'HTC.10.101', 'HTC.11.101',
     & 'HTC.00.110', 'HTC.01.110', 'HTC.02.110', 'HTC.03.110', 
     & 'HTC.04.110', 'HTC.05.110', 'HTC.06.110', 'HTC.07.110', 
     & 'HTC.08.110', 'HTC.09.110', 'HTC.10.110', 'HTC.11.110',
     & 'HTC.00.111', 'HTC.01.111', 'HTC.02.111', 'HTC.03.111', 
     & 'HTC.04.111', 'HTC.05.111', 'HTC.06.111', 'HTC.07.111', 
     & 'HTC.08.111', 'HTC.09.111', 'HTC.10.111', 'HTC.11.111',
     & 'HTC.00.130', 'HTC.01.130', 'HTC.02.130', 'HTC.03.130', 
     & 'HTC.04.130', 'HTC.05.130', 'HTC.06.130', 'HTC.07.130', 
     & 'HTC.08.130', 'HTC.09.130', 'HTC.10.130', 'HTC.11.130',
     & 'HTC.00.134', 'HTC.01.134', 'HTC.02.134', 'HTC.03.134', 
     & 'HTC.04.134', 'HTC.05.134', 'HTC.06.134', 'HTC.07.134', 
     & 'HTC.08.134', 'HTC.09.134', 'HTC.10.134', 'HTC.11.134'/
       data unchtc(:)%distrtp/nhtc*'UD'/
       data unchtc(:)%chparam(1)/nhtc*1.0e0/
       data unchtc(:)%chparam(2)/nhtc*1.0e0/
       data unchtc(:)%chparam(3)/nhtc*0.0e0/
       data unchtc(:)%chparam(4)/nhtc*0.0e0/
       data unchtc(:)%uncwt/nhtc*1.0e0/
       data unchtc(:)%extra/nhtc*0.0e0/
!uncpackalt       data unchtc(:)%uncw/nhtc*.false./
       data unchtc(:)%uncw/nhtc*.true./
!
!  Critical heat flux.
       data uncchf(:)%unvarnm/
     & 'CHF.PG.PT', 'CHF.PG.PA', 'CHF.PG.PB',
     & 'CHF.PG.GT', 'CHF.PG.GA', 'CHF.PG.GB',
     & 'CHF.PG.FT', 'CHF.PG.FA', 'CHF.PG.FB', 
     & 'CHF.PG.BT', 'CHF.PG.BA', 'CHF.PG.BB',
     & 'CHF.LT.GR'/
       data uncchf(1:12)%distrtp/12*'ND'/
       data uncchf(13)%distrtp/'UD'/
!  PG-CHF correlations, Volume 4, table 4.3-2 in p.189.
       data uncchf(1)%chparam(1)/1.003e0/
       data uncchf(2)%chparam(1)/0.999e0/
       data uncchf(3)%chparam(1)/1.009797093e0/
       data uncchf(4:10:3)%chparam(1)/3*1.001e0/
       data uncchf(5:11:3)%chparam(1)/3*0.998e0/
       data uncchf(13)%chparam(1)/1.0e0/
       data uncchf(6:12:3)%chparam(1)/3*0.991058553e0/
       data uncchf(1)%chparam(2)/0.103e0/
       data uncchf(2)%chparam(2)/0.126e0/
       data uncchf(3)%chparam(2)/0.175112711e0/
       data uncchf(4:10:3)%chparam(2)/3*0.056e0/
       data uncchf(5:11:3)%chparam(2)/3*0.052e0/
       data uncchf(6:12:3)%chparam(2)/3*0.077154564e0/
       data uncchf(13)%chparam(2)/1.0e0/
       data uncchf(:)%chparam(3)/nchf*0.0e0/
       data uncchf(:)%chparam(4)/nchf*0.0e0/
       data uncchf(:)%uncwt/nchf*1.0e0/
       data uncchf(:)%extra/nchf*0.0e0/
!uncpackalt       data uncchf(:)%uncw/nchf*.false./
       data uncchf(:)%uncw/nchf*.true./
!
!  Gap thermal conductivity from gap conductance model.
       data uncgap(:)%unvarnm/'GAP.CON.AT','GAP.CON.LE','GAP.CON.GT'/
       data uncgap(:)%distrtp/ngap*'UD'/
       data uncgap(:)%chparam(1)/ngap*1.0e0/
       data uncgap(:)%chparam(2)/ngap*1.0e0/
       data uncgap(:)%chparam(3)/ngap*0.0e0/
       data uncgap(:)%chparam(4)/ngap*0.0e0/
       data uncgap(:)%uncwt/ngap*1.0e0/
       data uncgap(1)%extra/ -1.0e0 /
       data uncgap(2)%extra/ -1.0e0 /
       data uncgap(3)%extra/ -1.0e0 /
!uncpackalt       data uncgap(:)%uncw/ngap*.false./
       data uncgap(:)%uncw/ngap*.true./
!
!  Viscosity.
       data uncvis(:)%unvarnm/'VIS.LW.LIQ','VIS.LW.VAP',
     &                        'VIS.HW.LIQ','VIS.HW.VAP'/
       data uncvis(:)%distrtp/nvis*'UD'/
       data uncvis(:)%chparam(1)/nvis*1.0e0/
       data uncvis(:)%chparam(2)/nvis*1.0e0/
       data uncvis(:)%chparam(3)/nvis*0.0e0/
       data uncvis(:)%chparam(4)/nvis*0.0e0/
       data uncvis(:)%uncwt/nvis*1.0e0/
       data uncvis(:)%extra/nvis*0.0e0 /
!uncpackalt       data uncvis(:)%uncw/nvis*.false./
       data uncvis(:)%uncw/nvis*.true./
!
!  Thermal conducitivty
       data unccon(:)%unvarnm/'CON.LW.LIQ','CON.LW.VAP',
     &                        'CON.HW.LIQ','CON.HW.VAP'/
       data unccon(:)%distrtp/ncon*'UD'/
       data unccon(:)%chparam(1)/ncon*1.0e0/
       data unccon(:)%chparam(2)/ncon*1.0e0/
       data unccon(:)%chparam(3)/ncon*0.0e0/
       data unccon(:)%chparam(4)/ncon*0.0e0/
       data unccon(:)%uncwt/ncon*1.0e0/
       data unccon(:)%extra/ncon*0.0e0 /
!uncpackalt       data unccon(:)%uncw/ncon*.false./
       data unccon(:)%uncw/ncon*.true./
!
!  Surface tension.
       data uncsft(:)%unvarnm/'SFT.LW.LV','SFT.HW.LV'/
       data uncsft(:)%distrtp/nsft*'UD'/
       data uncsft(:)%chparam(1)/nsft*1.0e0/
       data uncsft(:)%chparam(2)/nsft*1.0e0/
       data uncsft(:)%chparam(3)/nsft*0.0e0/
       data uncsft(:)%chparam(4)/nsft*0.0e0/
       data uncsft(:)%uncwt/nsft*1.0e0/
       data uncsft(:)%extra/nsft*0.0e0 /
!uncpackalt       data uncsft(:)%uncw/nsft*.false./
       data uncsft(:)%uncw/nsft*.true./
!
!  Resistivity for CORA elements: tungsten (wolfhe)
       data unctungs(:)%unvarnm/'RES.COR.TUNG'/ 
       data unctungs(:)%distrtp/ntungs*'UD'/ 
       data unctungs(:)%chparam(1)/ntungs*1.0e0/
       data unctungs(:)%chparam(2)/ntungs*1.0e0/
       data unctungs(:)%chparam(3)/ntungs*0.0e0/
       data unctungs(:)%chparam(4)/ntungs*0.0e0/
       data unctungs(:)%uncwt/ntungs*1.0e0/
       data unctungs(:)%extra/ntungs*0.0e0 /
       data unctungs(:)%uncw/ntungs*.true./
!
!  Oxidation rate and thickness: coxthk, coxthkr, coxwtk, coxwtkr
       data uncoxid(:)%unvarnm/'OXI.MATPRO' /
       data uncoxid(:)%distrtp/noxid*'UD'/ 
       data uncoxid(:)%chparam(1)/noxid*1.0e0/
       data uncoxid(:)%chparam(2)/noxid*1.0e0/
       data uncoxid(:)%chparam(3)/noxid*0.0e0/
       data uncoxid(:)%chparam(4)/noxid*0.0e0/
       data uncoxid(:)%uncwt/noxid*1.0e0/
       data uncoxid(:)%extra/noxid*0.0e0 /
       data uncoxid(:)%uncw/noxid*.true./
!
!
       integer uncrun,unctrun,uncmin
       logical uncmode,uncmode0
       character*256 filsch0
       character*256 uncsv
!
       contains
!
       subroutine unccalc
!  Read information needed to calculate weights.
       use inpmodul
       implicit none
       include 'comctl.h'
       include 'contrl.h'
       include 'fast.h'
       include 'ufilef.h'
       include 'ufiles.h'
!
!  Local variables.
       type inpdatt
         real(kr) wt,wtc,baseval,chparam(4)
         integer ipr,ips,nd,cardno,cardw,ipcw(3)
         character*2 distrtp
       end type inpdatt
!
       type inpcardt
         type (inpdatt), pointer :: inpcard
         type (inpcardt), pointer :: next
       end type inpcardt
       type (inpcardt), pointer :: first,firstb,crnt,crntb,prev
       type (uncoutt) :: uncout
       type (inpdatt), allocatable :: inpcard(:)
       type (inpdatt) :: varh
!uncpackalt
       type sourcardt
         type (uncdatt) :: sourcard
         integer :: compon
         type (sourcardt), pointer :: snext
       end type sourcardt
       type (sourcardt), pointer :: sfirst, slist
       integer nums
!
       real(kr) baseval,beta,betac,gama,mwt,order,sumw(2),wt
       integer cnum,i,iadd,id1,id2,id3,imin,imax,iorder,ipcw(3),
     & ipr,ips,ix,ixd,ixy,j,je,k,l,l3a(15),l3c(16),l3d(11),l3y(13),len,
     & m,n3,n3d,n3y,n4,n4d,n4y,nd,numi,ny,uncwilksn,uncrewr
       integer, parameter :: unclen=9
       character*256 filewts
       character(16) temname,titlewordd
       character(8) av1(8000),chwrd
       logical frst,lhelp1,lhelp3,lnorm,lnorme,lph,tfail,tfailchf,
     & tfailfrv,tfailgap,tfailhtc,tfailvis,tfailcon,tfailsft,tfailtungs,
     & tfailoxid,wrflag
!mpfu:
       integer init(8000),l3u(100),iu,ju,initu(20)
       logical eflg(2)
       real xinit(8000),timecpu,xinitu(20)
       equivalence (init(1),xinit(1))
       equivalence (initu(1),xinitu(1))
!  Data statements
       data l3a/29000000,0,5,9,0,1,0,0,1,1,0,0,0,0,0/
       data l3c/29000001,-29001000,1,8000,0,1,9,-1,-1,-1,6*1/
       data l3d/29101000,0,5,5,0,1,-1,1,1,1,1/
       data l3y/29100001,0,6,8000,0,1,6,1,5*0/
       data titlewordd/'Source weights'/
!  Some local definitions.
!  numi: Number of input uncertainties.
!
       ipr = 5
       ips = 6
!  Open restart-plot file for setup process.
       if (.not.uncmode) then
         open (unit=rstplt,file=filsch(ipr),status='new',
     &form='unformatted',iostat=len)
         if (len .ne. 0) then
           fail = .true.
           write (tty,2015) len, trim(filsch(ipr))
 2015  format ('Open error number',i8,' on file ',a,', perhaps file alre
     &ady exists.')
           write (output,2014) len,trim(filsch(ipr))
 2014  format ('0******** Open error number',i8,' on file ',a,', perhaps
     & file already exists.')
         else
           write (output,"('0Restart plot file, ',a,', will be written.'
     &)")  trim(filsch(ipr))
         endif
       endif
! Read Wilks and uncertainty runs related information (card 29000000).
       j = 1
       uncwilksn = 0
       iadd = -1
       imin = -1
       imax = -1
       tfail = .false.
       l3a(6) = 1
       call inp2 (fa(filndx(1)),init,l3a)
       if (l3a(6) .le. 0) then
         fail = .true.
         write (tty,"('Generation of uncertainty weights must be termina
     &ted due to input error.')")
         write (output,"('0******** Generation of uncertainty weights mu
     &st be terminated due to input error.')")
         return
       else
         uncmin = init(1)
         unctrun = init(2)
         beta = xinit(3)
         gama = xinit(4)
         iorder = init(5)
         order=iorder
         if (uncmin.lt.0 .or. uncmin.gt.9999) then
           fail = .true.
           write (output,"('0******** Beggining number of uncertainty ru
     &ns ,',i10,', is out of range.')") uncmin
           write (tty,"('Beggining number of uncertainty runs ,',i10,', 
     &is out of range.')") uncmin
           return
         elseif (uncmin .eq. 0) then
!  If 0 is entered, all Wilks' information.
           uncmin = 1
         endif 
         if (unctrun.lt.0 .or. unctrun.gt.9999) then
           fail = .true.
           write (output,"('0******** End number of uncertainty runs,',
     &     i10,', is out of range.')") unctrun
           write (tty,"('End number of uncertainty runs,',i10,', is out 
     &of range.')") unctrun
           return
         endif 
         if (uncmin.gt.0 .and. unctrun.gt.0) then
           if (uncmin .gt. unctrun) then
             fail = .true.
             write (output,"('0******** End number of uncertainty runs i
     &s not greater than beginning number.')")
             write (tty,"('End number of uncertainty runs is not greater
     & than beginning number.')")
             return
           endif
         elseif (uncmin.eq.0 .and. unctrun.gt.0) then
           fail = .true.
           write (output,"('0******** Beginning run number must be enter
     &ed when end number is entered.')")
           write (tty,"('Beginning run number must be entered when end n
     &umber is entered.')")
           return
         endif
         if ((beta.le.0.0 .or. beta.ge.1.0) .or. 
     &   (gama.le.0.0 .or. gama.ge.1.0) .or. 
     &   (order.le.0.0)) then
           tfail = .true.
           write (output,"('0******** One or more of Wilks'' input param
     &eters (W3 through W5) are invalid. Setup process stopped.')")
           write (tty,"('One or more of Wilks'' input parameters (W3 thr
     &ough W5) are invalid. Setup process stopped.')")
           return
         else
           call ncalculation (beta,gama,order,uncwilksn,betac)
           if (uncwilksn .gt. 9999) then
             write (output,"('0******** End number computed exceeds maxi
     &mum of 9999. Set to 9999.')")
             uncwilksn = 9999
           endif
         endif
       endif
       if (l3a(6).ge.6) then
         iadd = init(6)
         if (iadd .lt. 0) then
           tfail = .true.
           write (output,"('0******** Number of additional runs is less 
     &than zero. Set to zero.')")
           iadd = 0
         endif
       else
         iadd = 0
       endif
       if (l3a(6) .ge. 7) then
         imin = init(7)
         if (imin .lt. 0) then
           tfail = .true.
           write (output,"('0******** Minimum number of runs is less tha
     &n zero. Set to 0.')")
           imin = 1
         endif
         if (l3a(6) .lt. 8) then
           tfail = .true.
           write (output,"('0******** Maximum missing when minimum enter
     &ed. Set to 9999.')")
           imax = 9999
         else
           imax = init(8)
           if (imax .gt. 9999) then
             tfail = .true.
             write (output,"('0******** Maximum number of runs exceeds
     &limt of 9999. Set to 9999.')")
             imax = 9999
           endif
         endif
         if (imax .le. imin) then
           tfail = .true.
           write (output,"('0****** Maximum number of runs is not greate
     &r than minimum number of runs. Set to 9999.')")
           imax = 9999
         endif
       else
         imin = 1
         imax = 9999
       endif
       if (l3a(6) .eq. 9) then
         seed(1) = init(9)
         if (seed(1).lt.0 .or. seed(1).gt.huge(seed(1))) then
           tfail = .true.
           write (output,"('0********* Seed cannot be a negative number 
     &nor exceed the maximum value for an integer*4 type quantity. Set t
     &o default.')")
           seed(1) = 298341
         endif
       endif
       if (tfail) then
         write (output,"('0********* Errors encountered in card',i9,' se
     &t to default. For detailed information read previous error message
     &s.')"
     &) l3a(1)
         write (tty,"('Errors encountered in card',i9,' set to default. 
     &For detailed information read output file.')") l3a(1)
       endif
!  Write Wilks' related computed data.
       write (output,"('0Wilks'' input parameters: confidence level = '
     &,es11.5,3x,', population percentile = ',es11.5,3x,', order of appl
     &ication = ',i4,'.')") beta,gama,iorder 
       write (output,"('0Wilks'' results: improved confidence level = '
     &,es11.5,3x,', Wilks'' estimated number of runs =',i4,'.')") betac,
     &   uncwilksn
       if (unctrun .eq. 0) then
         unctrun = max(imin,(min(imax,uncwilksn+iadd)))
         if (unctrun.gt.9999) then
           tfail = .true.
           write (output,"('0******** End run number exceeds limit of 99
     &99. Set to 9999')")
           write (tty,"('End run number exceeds limit of 9999. Set to 99
     &99')")
           unctrun = 9999
         endif
       endif
       write (output,"('0Weight files generated for run number ',i5,' to
     & ',i5)") uncmin,unctrun
!  Prepare base name for files containing the weight for each run.
       wrflag = .true.
       je = len_trim(filsch(ips))
       je = je - 6
       filewts = ' '
       filewts(1:je) = filsch(ips)(1:je)
!  Read weights information for all requested runs. 
       call random_seed(put=seed(1:1))
       write (output,"('0First seed used in the sampling process is ',
     & i15)") seed
!  Check over-writing of source weight data
       uncrewr = -1
       call inplnk (l3c(1),m,j,l3c(6),fa(filndx(1)))
       if (l3c(6).eq.0 .and. (m.eq.-1 .or. m.ge.abs(l3c(2)))) then
         uncrewr = 0
         write (output,"('0Default source weights written.')")
       else
         write (output,"('0List of over written source weights:')")
         write (output,"(' Quantity',11x,'Distr. R1',11x,'R2',
     &11x,'R3',11x,'R4',11x,'Weight flag')")
         l3c(6) = 1
         call inp2 (fa(filndx(1)),av1,l3c)
         tfail = .false.
         if (l3c(6) .lt. 0) then
            fail = .true.
            tfail = .true.
         elseif (mod(l3c(6),unclen) .ne. 0) then
            fail = .true.
            write (output,"('0******** Number of quantities in cards 290
     &XXXXX are not a multiple of eight.')")
         endif
         if ( .not.tfail) then
!uncpackalt
           allocate (slist) 
           nullify (slist%snext)
           sfirst => slist 
           nums=0
           do m = 1,l3c(6),unclen
             call inpextrt (temname(1:8),av1(m))
             call inpextrt (temname(9:16),av1(m+1))
             tfailchf = .false.
             tfailfrv = .false.
             tfailhtc = .false.
             tfailgap = .false.
             tfailvis = .false.
             tfailcon = .false.
             tfailsft = .false.
             tfailtungs = .false.
             tfailoxid = .false.
             select case (temname(1:3))
             case ('FRV')
               do k = 1,nfrv
                 if (temname .eq. uncfrv(k)%unvarnm) then
                   tfailfrv = .true.
                   exit
                 endif
               enddo
             case ('HTC')
               do k = 1,nhtc
                 if (temname .eq. unchtc(k)%unvarnm) then
                   tfailhtc = .true.
                   exit
                 endif
               enddo
             case ('CHF')
               do k = 1,nchf
                 if (temname .eq. uncchf(k)%unvarnm) then
                   tfailchf = .true.
                   exit
                 endif
               enddo
             case ('GAP')
               do k = 1,ngap
                 if (temname .eq. uncgap(k)%unvarnm) then
                   tfailgap = .true.
                   exit
                 endif
               enddo
             case ('VIS')
               do k = 1,nvis
                 if (temname .eq. uncvis(k)%unvarnm) then
                   tfailvis = .true.
                   exit
                 endif
               enddo
             case ('CON')
               do k = 1,ncon
                 if (temname .eq. unccon(k)%unvarnm) then
                   tfailcon = .true.
                   exit
                 endif
               enddo
             case ('SFT')
               do k = 1,nsft
                 if (temname .eq. uncsft(k)%unvarnm) then
                   tfailsft = .true.
                   exit
                 endif
               enddo
             case ('RES')
               do k = 1,ntungs
                 if (temname .eq. unctungs(k)%unvarnm) then
                   tfailtungs = .true.
                   exit
                 endif
               enddo
             case ('OXI')
               do k = 1,noxid
                 if (temname .eq. uncoxid(k)%unvarnm) then
                   tfailoxid = .true.
                   exit
                 endif
               enddo
             end select
             tfail = tfailfrv .or. tfailhtc .or. tfailchf .or. tfailgap
     &       .or. tfailvis .or. tfailcon .or. tfailsft .or. tfailtungs
     &       .or. tfailoxid
             if ( .not.tfail) then
               fail = .true.
!  Identify the card with the misspelling.
               call inp6 (l3c(1),abs(l3c(2)),m,j,i)
               write (output,"('0******** Weight name, ',a,', on card, '
     &,i8,', was not found in source weight table.')") trim(temname),j
             else
               if (tfailfrv) then
                 call inpextrt (chwrd,av1(m+2))
                 uncfrv(k)%distrtp = chwrd(1:2)
                 call inpextrt (uncfrv(k)%chparam(1),av1(m+3))
                 call inpextrt (uncfrv(k)%chparam(2),av1(m+4))
                 call inpextrt (uncfrv(k)%chparam(3),av1(m+5))
                 call inpextrt (uncfrv(k)%chparam(4),av1(m+6))
                 call inpextrt (uncfrv(k)%uncwt,av1(m+7))
                 if (uncfrv(k)%uncwt .ne. -1.0) then
                   if (uncfrv(k)%uncwt .le. 0.0) then
                     fail = .true.
                     write (output,"('0******** Weight number in cards 2
     &90XXXXX is not equal to -1.0 or positive non zero quantity.')")
                   else
                     uncfrv(k)%uncw = .true.
                   endif
!uncpackalt
                 else
                   uncfrv(k)%uncw = .false.
                 endif
                 call inpextrt (uncfrv(k)%extra,av1(m+8))
                 if (uncfrv(k)%extra .ne. 0.0) then
                     fail = .true.
                     write (output,"('0******** Last word in cards 290XX
     &XXX is not equal to 0.0.')")
                 endif
!uncpackalt                 write (output,"(1x,a16,3x,a2,3x,5es13.5)") 
!uncpackalt     &           uncfrv(k)%unvarnm,uncfrv(k)%distrtp,
!uncpackalt     &           uncfrv(k)%chparam(1:4),uncfrv(k)%uncwt
!uncpackalt
                 slist%sourcard%unvarnm = uncfrv(k)%unvarnm
                 slist%sourcard%distrtp = uncfrv(k)%distrtp
                 slist%sourcard%chparam(1:4) = uncfrv(k)%chparam(1:4)
                 slist%sourcard%uncw = uncfrv(k)%uncw
                 slist%sourcard%uncwt = uncfrv(k)%uncwt
                 slist%compon = k
                 nums = nums+1
                 allocate (slist%snext)
                 slist => slist%snext
                 nullify (slist%snext)
               elseif (tfailhtc) then
                 call inpextrt (chwrd,av1(m+2))
                 unchtc(k)%distrtp = chwrd(1:2)
                 call inpextrt (unchtc(k)%chparam(1),av1(m+3))
                 call inpextrt (unchtc(k)%chparam(2),av1(m+4))
                 call inpextrt (unchtc(k)%chparam(3),av1(m+5))
                 call inpextrt (unchtc(k)%chparam(4),av1(m+6))
                 call inpextrt (unchtc(k)%uncwt,av1(m+7))
                 if (unchtc(k)%uncwt .ne. -1.0) then
                   if (unchtc(k)%uncwt .le. 0.0) then
                     fail = .true.
                     write (output,"('0******** Weight number in cards 2
     &90XXXXX is not equal to -1.0 or positive non zero quantity.')")
                   else
                     unchtc(k)%uncw = .true.
                   endif
                 else
                    unchtc(k)%uncw = .false.
                 endif
                 call inpextrt (unchtc(k)%extra,av1(m+8))
                 if (unchtc(k)%extra .ne. 0.0) then
                     fail = .true.
                     write (output,"('0******** Last word in cards 290XX
     &XXX is not equal to 0.0.')")
                 endif
!uncpackalt                 write (output,"(1x,a16,3x,a2,3x,5es13.5)")
!uncpackalt     &           unchtc(k)%unvarnm,unchtc(k)%distrtp,
!uncpackalt     &           unchtc(k)%chparam(1:4),unchtc(k)%uncwt
!uncpackalt
                 slist%sourcard%unvarnm = unchtc(k)%unvarnm
                 slist%sourcard%distrtp = unchtc(k)%distrtp
                 slist%sourcard%chparam(1:4) = unchtc(k)%chparam(1:4)
                 slist%sourcard%uncw = unchtc(k)%uncw
                 slist%sourcard%uncwt = unchtc(k)%uncwt
                 slist%compon = k
                 nums = nums+1
                 allocate (slist%snext)
                 slist => slist%snext
                 nullify (slist%snext)
               elseif (tfailchf) then
                 call inpextrt (chwrd,av1(m+2))
                 uncchf(k)%distrtp = chwrd(1:2)
                 call inpextrt (uncchf(k)%chparam(1),av1(m+3))
                 call inpextrt (uncchf(k)%chparam(2),av1(m+4))
                 call inpextrt (uncchf(k)%chparam(3),av1(m+5))
                 call inpextrt (uncchf(k)%chparam(4),av1(m+6))
                 call inpextrt (uncchf(k)%uncwt,av1(m+7))
                 if (uncchf(k)%uncwt .ne. -1.0) then
                   if (uncchf(k)%uncwt .le. 0.0) then
                     fail = .true.
                     write (output,"('0******** Weight number in cards 2
     &90XXXXX is not equal to -1.0 or positive non zero quantity.')")
                   else
                     uncchf(k)%uncw = .true.
                   endif
!uncpackalt
                 else
                    uncchf(k)%uncw = .false.
                 endif
                 call inpextrt (uncchf(k)%extra,av1(m+8))
                 if (uncchf(k)%extra .ne. 0.0) then
                     fail = .true.
                     write (output,"('0******** Last word in cards 290XX
     &XXX is not equal to 0.0.')")
                 endif
!uncpackalt                 write (output,"(1x,a16,3x,a2,3x,5es13.5)")
!uncpackalt     &           uncchf(k)%unvarnm,uncchf(k)%distrtp,
!uncpackalt     &           uncchf(k)%chparam(1:4),uncchf(k)%uncwt
!uncpackalt
                 slist%sourcard%unvarnm = uncchf(k)%unvarnm
                 slist%sourcard%distrtp = uncchf(k)%distrtp
                 slist%sourcard%chparam(1:4) = uncchf(k)%chparam(1:4)
                 slist%sourcard%uncw = uncchf(k)%uncw
                 slist%sourcard%uncwt = uncchf(k)%uncwt
                 slist%compon = k
                 nums = nums+1
                 allocate (slist%snext)
                 slist => slist%snext
                 nullify (slist%snext)
               elseif (tfailgap) then
                 call inpextrt (chwrd,av1(m+2))
                 uncgap(k)%distrtp = chwrd(1:2)
                 call inpextrt (uncgap(k)%chparam(1),av1(m+3))
                 call inpextrt (uncgap(k)%chparam(2),av1(m+4))
                 call inpextrt (uncgap(k)%chparam(3),av1(m+5))
                 call inpextrt (uncgap(k)%chparam(4),av1(m+6))
                 call inpextrt (uncgap(k)%uncwt,av1(m+7))
                 if (uncgap(k)%uncwt .ne. -1.0) then
                   if (uncgap(k)%uncwt .le. 0.0) then
                     fail = .true.
                     write (output,"('0******** Weight number in cards 2
     &90XXXXX is not equal to -1.0 or positive non zero quantity.')")
                   else
                     uncgap(k)%uncw = .true.
                   endif
!uncpackalt
                 else
                   uncgap(k)%uncw = .false.
                 endif
                 call inpextrt (uncgap(k)%extra,av1(m+8))
                 if (uncgap(k)%extra .lt. 0.0) then
                   fail = .true.
                   write (output,"('0******** Error found in gap tempera
     &ture in cards 290XXXXX')")
!  Temperature units.
                 endif
                 if ( .not.uniti) then
                   uncgap(k)%extra = (uncgap(k)%extra + 459.67)/1.8
                 endif
!uncpackalt                 write (output,"(1x,a16,3x,a2,3x,5es13.5)")
!uncpackalt     &           uncgap(k)%unvarnm,uncgap(k)%distrtp,
!uncpackalt     &           uncgap(k)%chparam(1:4),uncgap(k)%uncwt
!uncpackalt
                 slist%sourcard%unvarnm = uncgap(k)%unvarnm
                 slist%sourcard%distrtp = uncgap(k)%distrtp
                 slist%sourcard%chparam(1:4) = uncgap(k)%chparam(1:4)
                 slist%sourcard%uncw = uncgap(k)%uncw
                 slist%sourcard%uncwt = uncgap(k)%uncwt
!mpfu --> to be corrected in RS4
                 slist%sourcard%extra = uncgap(k)%extra
                 slist%compon = k
                 nums = nums+1
                 allocate (slist%snext)
                 slist => slist%snext
                 nullify (slist%snext)
               elseif (tfailvis) then
                 call inpextrt (chwrd,av1(m+2))
                 uncvis(k)%distrtp = chwrd(1:2)
                 call inpextrt (uncvis(k)%chparam(1),av1(m+3))
                 call inpextrt (uncvis(k)%chparam(2),av1(m+4))
                 call inpextrt (uncvis(k)%chparam(3),av1(m+5))
                 call inpextrt (uncvis(k)%chparam(4),av1(m+6))
                 call inpextrt (uncvis(k)%uncwt,av1(m+7))
                 if (uncvis(k)%uncwt .ne. -1.0) then
                   if (uncvis(k)%uncwt .le. 0.0) then
                     fail = .true.
                     write (output,"('0******** Weight number in cards 2
     &90XXXXX is not equal to -1.0 or positive non zero quantity.')")
                   else
                     uncvis(k)%uncw = .true.
                   endif
!uncpackalt
                 else
                   uncvis(k)%uncw = .false.
                 endif
                 call inpextrt (uncvis(k)%extra,av1(m+8))
                 if (uncvis(k)%extra .ne. 0.0) then
                     fail = .true.
                     write (output,"('0******** Last word in cards 290XX
     &XXX is not equal to 0.0.')")
                 endif
!uncpackalt                 write (output,"(1x,a16,3x,a2,3x,5es13.5)")
!uncpackalt     &           uncvis(k)%unvarnm,uncvis(k)%distrtp,
!uncpackalt     &           uncvis(k)%chparam(1:4),uncvis(k)%uncwt
!uncpackalt
                 slist%sourcard%unvarnm = uncvis(k)%unvarnm
                 slist%sourcard%distrtp = uncvis(k)%distrtp
                 slist%sourcard%chparam(1:4) = uncvis(k)%chparam(1:4)
                 slist%sourcard%uncw = uncvis(k)%uncw
                 slist%sourcard%uncwt = uncvis(k)%uncwt
                 slist%compon = k
                 nums = nums+1
                 allocate (slist%snext)
                 slist => slist%snext
                 nullify (slist%snext)
               elseif (tfailcon) then
                 call inpextrt (chwrd,av1(m+2))
                 unccon(k)%distrtp = chwrd(1:2)
                 call inpextrt (unccon(k)%chparam(1),av1(m+3))
                 call inpextrt (unccon(k)%chparam(2),av1(m+4))
                 call inpextrt (unccon(k)%chparam(3),av1(m+5))
                 call inpextrt (unccon(k)%chparam(4),av1(m+6))
                 call inpextrt (unccon(k)%uncwt,av1(m+7))
                 if (unccon(k)%uncwt .ne. -1.0) then
                   if (unccon(k)%uncwt .le. 0.0) then
                     fail = .true.
                     write (output,"('0******** Weight number in cards 2
     &90XXXXX is not equal to -1.0 or positive non zero quantity.')")
                   else
                     unccon(k)%uncw = .true.
                   endif
!uncpackalt
                 else
                   unccon(k)%uncw = .false.
                 endif
                 call inpextrt (unccon(k)%extra,av1(m+8))
                 if (unccon(k)%extra .ne. 0.0) then
                     fail = .true.
                     write (output,"('0******** Last word in cards 290XX
     &XXX is not equal to 0.0.')")
                 endif
!uncpackalt                 write (output,"(1x,a16,3x,a2,3x,5es13.5)")
!uncpackalt     &           unccon(k)%unvarnm,unccon(k)%distrtp,
!uncpackalt     &           unccon(k)%chparam(1:4),unccon(k)%uncwt
!uncpackalt
                 slist%sourcard%unvarnm = unccon(k)%unvarnm
                 slist%sourcard%distrtp = unccon(k)%distrtp
                 slist%sourcard%chparam(1:4) = unccon(k)%chparam(1:4)
                 slist%sourcard%uncw = unccon(k)%uncw
                 slist%sourcard%uncwt = unccon(k)%uncwt
                 slist%compon = k
                 nums = nums+1
                 allocate (slist%snext)
                 slist => slist%snext
                 nullify (slist%snext)
               elseif (tfailsft) then
                 call inpextrt (chwrd,av1(m+2))
                 uncsft(k)%distrtp = chwrd(1:2)
                 call inpextrt (uncsft(k)%chparam(1),av1(m+3))
                 call inpextrt (uncsft(k)%chparam(2),av1(m+4))
                 call inpextrt (uncsft(k)%chparam(3),av1(m+5))
                 call inpextrt (uncsft(k)%chparam(4),av1(m+6))
                 call inpextrt (uncsft(k)%uncwt,av1(m+7))
                 if (uncsft(k)%uncwt .ne. -1.0) then
                   if (uncsft(k)%uncwt .le. 0.0) then
                     fail = .true.
                     write (output,"('0******** Weight number in cards 2
     &90XXXXX is not equal to -1.0 or positive non zero quantity.')")
                   else
                     uncsft(k)%uncw = .true.
                   endif
!uncpackalt
                 else
                   uncsft(k)%uncw = .false.
                 endif
                 call inpextrt (uncsft(k)%extra,av1(m+8))
                 if (uncsft(k)%extra .ne. 0.0) then
                     fail = .true.
                     write (output,"('0******** Last word in cards 290XX
     &XXX is not equal to 0.0.')")
                 endif
!uncpackalt                 write (output,"(1x,a16,3x,a2,3x,5es13.5)")
!uncpackalt     &           uncsft(k)%unvarnm,uncsft(k)%distrtp,
!uncpackalt     &           uncsft(k)%chparam(1:4),uncsft(k)%uncwt
!uncpackalt
                 slist%sourcard%unvarnm = uncsft(k)%unvarnm
                 slist%sourcard%distrtp = uncsft(k)%distrtp
                 slist%sourcard%chparam(1:4) = uncsft(k)%chparam(1:4)
                 slist%sourcard%uncw = uncsft(k)%uncw
                 slist%sourcard%uncwt = uncsft(k)%uncwt
                 slist%compon = k
                 nums = nums+1
                 allocate (slist%snext)
                 slist => slist%snext
                 nullify (slist%snext)
               elseif (tfailtungs) then
                 call inpextrt (chwrd,av1(m+2))
                 unctungs(k)%distrtp = chwrd(1:2)
                 call inpextrt (unctungs(k)%chparam(1),av1(m+3))
                 call inpextrt (unctungs(k)%chparam(2),av1(m+4))
                 call inpextrt (unctungs(k)%chparam(3),av1(m+5))
                 call inpextrt (unctungs(k)%chparam(4),av1(m+6))
                 call inpextrt (unctungs(k)%uncwt,av1(m+7))
                 if (unctungs(k)%uncwt .ne. -1.0) then
                   if (unctungs(k)%uncwt .le. 0.0) then
                     fail = .true.
                     write (output,"('0******** Weight number in cards 2
     &90XXXXX is not equal to -1.0 or positive non zero quantity.')")
                   else
                     unctungs(k)%uncw = .true.
                   endif
!uncpackalt
                 else
                   unctungs(k)%uncw = .false.
                 endif
                 call inpextrt (unctungs(k)%extra,av1(m+8))
                 if (unctungs(k)%extra .ne. 0.0) then
                     fail = .true.
                     write (output,"('0******** Last word in cards 290XX
     &XXX is not equal to 0.0.')")
                 endif
!uncpackalt                 write (output,"(1x,a16,3x,a2,3x,5es13.5)")
!uncpackalt     &           uncsft(k)%unvarnm,uncsft(k)%distrtp,
!uncpackalt     &           uncsft(k)%chparam(1:4),uncsft(k)%uncwt
!uncpackalt
                 slist%sourcard%unvarnm = unctungs(k)%unvarnm
                 slist%sourcard%distrtp = unctungs(k)%distrtp
                 slist%sourcard%chparam(1:4) = unctungs(k)%chparam(1:4)
                 slist%sourcard%uncw = unctungs(k)%uncw
                 slist%sourcard%uncwt = unctungs(k)%uncwt
                 slist%compon = k
                 nums = nums+1
                 allocate (slist%snext)
                 slist => slist%snext
                 nullify (slist%snext)
               elseif (tfailoxid) then
                 call inpextrt (chwrd,av1(m+2))
                 uncoxid(k)%distrtp = chwrd(1:2)
                 call inpextrt (uncoxid(k)%chparam(1),av1(m+3))
                 call inpextrt (uncoxid(k)%chparam(2),av1(m+4))
                 call inpextrt (uncoxid(k)%chparam(3),av1(m+5))
                 call inpextrt (uncoxid(k)%chparam(4),av1(m+6))
                 call inpextrt (uncoxid(k)%uncwt,av1(m+7))
                 if (uncoxid(k)%uncwt .ne. -1.0) then
                   if (uncoxid(k)%uncwt .le. 0.0) then
                     fail = .true.
                     write (output,"('0******** Weight number in cards 2
     &90XXXXX is not equal to -1.0 or positive non zero quantity.')")
                   else
                     uncoxid(k)%uncw = .true.
                   endif
!uncpackalt
                 else
                   uncoxid(k)%uncw = .false.
                 endif
                 call inpextrt (uncoxid(k)%extra,av1(m+8))
                 if (uncoxid(k)%extra .ne. 0.0) then
                     fail = .true.
                     write (output,"('0******** Last word in cards 290XX
     &XXX is not equal to 0.0.')")
                 endif
!uncpackalt                 write (output,"(1x,a16,3x,a2,3x,5es13.5)")
!uncpackalt     &           uncsft(k)%unvarnm,uncsft(k)%distrtp,
!uncpackalt     &           uncsft(k)%chparam(1:4),uncsft(k)%uncwt
!uncpackalt
                 slist%sourcard%unvarnm = uncoxid(k)%unvarnm
                 slist%sourcard%distrtp = uncoxid(k)%distrtp
                 slist%sourcard%chparam(1:4) = uncoxid(k)%chparam(1:4)
                 slist%sourcard%uncw = uncoxid(k)%uncw
                 slist%sourcard%uncwt = uncoxid(k)%uncwt
                 slist%compon = k
                 nums = nums+1
                 allocate (slist%snext)
                 slist => slist%snext
                 nullify (slist%snext)
               endif
             endif
           enddo
!  Check uncertainty for gap th.cond. entered.
           if (tfailgap) then
             if (uncgap(1)%extra.ne.-1.0 .and. 
     &(uncgap(2)%extra.ne.-1.0.or.uncgap(3)%extra.ne.-1.0)) then
               fail = .true.
               write (output,"('0******** Too many uncertainty parameter
     &s for gap conductance model.')")
             endif
           endif
         endif
       endif
       if (uncrewr .eq. -1) then
!uncpackalt
       slist => sfirst
       nums = 0
       do while (associated(slist%snext))
         write (output,"(1x,a16,3x,a2,3x,5es13.5)") 
     &   slist%sourcard%unvarnm,slist%sourcard%distrtp,
     &   slist%sourcard%chparam(1:4),slist%sourcard%uncwt
         nums = nums+1
         slist => slist%snext
       enddo
!endif below on uncrewr
       endif
!
!  Read input uncertainties
!       write (output,"('0List of input weights information.')")
       lhelp1 = .false.
       lnorm = .false.
       nd = 1  
       numi = 0
       nullify (first)
       do
         frst = .true.
         l3d(1) = 29100000+nd*1000
         call inplnk (l3d(1),ixd,n3d,n4d,fa(filndx(1)))
         if (n4d .eq. 0) then
           if (ixd .eq. -1) then
!             write (output,"('0No input weight information entered.')")
             exit
           elseif (ixd .lt. (l3d(1)+1000)) then
             fail = .true.
             write(output,"('0******** Weight input cards entered withou
     &t first entering distribution information on card',i9,'.')") 
     &       l3d(1)
             nd = nd + 1
             if (nd .ge. 99) exit
             cycle
           else
             nd = (ixd - 29100000)/1000
             if (nd .ge. 99) exit
             cycle
           endif 
         else
           l3d(6) = 1
           call inp2 (fa(filndx(1)),av1,l3d)
           if (l3d(6) .le. 0) then
             fail = .true.
             write (output,"('0******** Reading of input uncertainty inf
     &ormation must be terminated due to input error.')")
             write (tty,"('0******** Reading of input uncertainty inform
     &ation must be terminated due to input error.')")
             return
           elseif (l3d(6) .lt. 5) then
             fail = .true.
             write (output,"('0******** Missing numbers in card',i9,'.')
     &") ixd
           else
             call inpextrt (chwrd,av1(1))
             uncinp(nd)%distrtp = chwrd(1:2)
             call inpextrt (uncinp(nd)%chparam(1),av1(2))
             call inpextrt (uncinp(nd)%chparam(2),av1(3))
             call inpextrt (uncinp(nd)%chparam(3),av1(4))
             call inpextrt (uncinp(nd)%chparam(4),av1(5))
             lhelp1 = .true.
           endif
         endif
         if (lhelp1) then
           ny = 1
           do
           l3y(1) = l3d(1) + ny
!  Read the weight cards.
             call inplnk (l3y(1),ixy,n3y,n4y,fa(filndx(1)))
             if (n4y .eq. 0) then
               if (ixy .eq. -1) then
!mpfu: is nd=99 needed anymore after considering it an error?
                 nd = 99
                 write (output,"('0******** Uncertainty information ente
     &red but no input card specified.')")
                 fail = .true.
                 exit
               elseif (ixy .lt. (l3y(1)+999)) then
                 l3y(1) = ixy
                 ny = ixy-l3d(1)
                 cycle
               else
                 exit
               endif
             else
               l3y(6) = 1
               call inp2 (fa(filndx(1)),init,l3y)
!  Apply the weight to the entered input card.
!  Store the needed values.
!mpfu why not using tfail as above?!               lhelp3 = .false.
!mpfu tfail=true then no further input processing.
               tfail = .false.
               if (l3y(6) .lt. 0) then
                 fail = .true.
!mpfu on tfail:
                 tfail = .true.
               elseif (mod(l3y(6),l3y(7)) .ne. 0) then
                 fail = .true.
                 write (output,"('0******** Number of words in card,
     &',i9,', is not a multiple of four.')") l3y(1)
                 l3y(6) = (l3y(6)/l3y(7))*l3y(7)
!mpfu on tfail                 lhelp3 = .true.
!mpfu on tfail               else
!mpfu on tfail                 lhelp3 = .true.
               endif 
!mpfu on tfail               if (lhelp3) then
               if (.not.tfail) then
                 do i = 1,l3y(6),l3y(7)
!mpfu on tfail                   tfail = .false.
                   wt = xinit(i)
                   ipcw(1) = init(i+1)
                   cnum = init(i+2)
                   id1 = init(i+3)
                   id2 = init(i+4)
                   id3 = init(i+5)
                   if (wt .ne. -1.0) then
                     if (wt .lt. 0.0) then
                       tfail = .true.
                       write (output,"('0******** A weight number on car
     &d, 'i9,', is not equal to -1.0, 0.0, or positive quantity non zero
     & quantity.')") l3y(1)
                       wt = 1.0
!  Check first weight value after a distribution card.
                     elseif (wt.eq.0.0 .and. frst) then
                       tfail = .true.
                       write (output,"('0******** Ther first weight afte
     &r card, ',i9,', must either be entered or request computation of a
     & weight')") l3d(1)
                       wt = 1.0
                     endif
                   endif
                   ipcw(3) = 0
                   if (ipcw(1) .lt. 0) then
                     ipcw(3) = 1
                     ipcw(1) = abs(ipcw(1))
                   endif
                   if (ipcw(1) .gt. 99) then
                     tfail = .true.
                     ipcw(1) = 20
                     write (output,"('0******** A control word on card, 
     &', i9,', is not correct')") l3y(1)
                   endif
                   ipcw(2) = ipcw(1)/10
                   ipcw(1) = ipcw(1) - 10*ipcw(2)
!  Check first weight&normalization flags after a distribution card.
                   if (frst .and. (ipcw(1).eq.2.or.ipcw(2).eq.1)) then
                     tfail = .true.
                     write (output,"('0******** Ther first weight or nor
     &malization flag after card, ',i9,', is invalid.')") l3d(1)
                     ipcw(1) = 0
                     ipcw(2) = 2
                   endif
!  Weight flag.
                   if (ipcw(2) .eq. 0) then
                     if (wt .le. 0.0) then
                       tfail = .true.
                       write (output,"('0******** A control word and its
     & weight value on card, ', i9,', are not consistent')") l3y(1)
                       wt = 1.0
                     endif
                   elseif (ipcw(2) .eq. 1) then
                     if (wt .ne. 0.0) then
                       tfail = .true.
                       write (output,"('0******** A control word and its
     & weight value on card, ', i9,', are not consistent')") l3y(1)
                       wt = 0.0
                     endif
                   elseif (ipcw(2).eq.2 .or. ipcw(2).eq.3) then
                     if (wt .ne. -1.0) then
                       tfail = .true.
                       write (output,"('0******** A control word and its
     & weight value on card, ', i9,', are not consistent.')") l3y(1)
                       wt = -1.0
                     endif
                   else
                     tfail = .true.
                     write (output,"('0******** Weight part of a control
     & word in card, ',i9,', is not valid.')") l3y(1)
                     ipcw(2) = 0
                     wt = 1.0
                   endif
!  Normalization flag.
                   if (frst) then
                     if (ipcw(1) .eq. 1) lnorm = .true.
                   else
                     if (ipcw(1) .gt. 3) then
                       tfail = .true.
                       write (output,"('0******** Normalization part of 
     &a control word on card,', i9,', is not correct')") l3y(1)
                       ipcw(1) = 0
                     elseif (ipcw(1) .eq. 1) then
                       if (crnt%inpcard%ipcw(1) .eq. 1) then
                         tfail = .true.
                         write (output,"('0******** A consecutive normal
     &ization flag vaule of 1 on card,',i9,', is not allowed.')") 
     &                   l3y(1)
                       elseif (crnt%inpcard%ipcw(1).eq.0 .and. lnorm) 
     &                 then
                         tfail = .true.
                         write (output,"('0******** A beginning of norma
     &lization flag vaule of 1 on card,',i9,', is not allowed, because p
     &revious normalization not finished.')") l3y(1)
                       endif
                       lnorm = .true.
                     elseif (ipcw(1) .eq. 3) then
                       if (crnt%inpcard%ipcw(1) .eq. 1) then
                         tfail = .true.
                         write (output,"('0******** Unfinished normaliza
     &tion found on card,',i9,'.')") l3y(1)
                       elseif (crnt%inpcard%ipcw(1).eq.0 .and. lnorm) th
     &en
                         tfail = .true.
                         write (output,"('0******** A beginning of norma
     &lization flag vaule of 1 on card,',i9,', is not allowed, because p
     &revious normalization not finished.')") l3y(1)
                       endif
                       if ((id1+id3) .lt. id2) then
                         tfail = .true.
                         write (output,"('0******** Card ,',i9,' specifi
     &es normalization over just one quantity and that is not allowed.'
     &)")                l3y(1)
                       endif
                     elseif (ipcw(1) .eq. 2) then
                       if ( .not.lnorm) then
                         tfail = .true.
                         write (output,"('0******** A end of normalizati
     &on flag found on card,',i9,' is not valid.')") l3y(1)
                       endif
                       if (crnt%inpcard%ipcw(1).eq.3 .or. 
     &                 crnt%inpcard%ipcw(1).eq.2) then
                         tfail = .true.
                         write (output,"('0******** A end of normalizati
     &on flag found on card,',i9,' is not valid.')") l3y(1)
                       endif
                       lnorm = .false.
                     endif
                   endif
                   if (cnum.lt.0 .or. cnum.gt.99999999) then
                     fail = .true.
                     write (output,"('0******** Card number,',i9,
     &', entered on,',i9,', is invalid.')") cnum,l3y(1)
                     cycle
                   endif
                   frst = .false.
                   call inplnk (cnum,ix,n3,n4,fa(filndx(1)))
                   if (n4 .eq. 0) then
                     tfail = .true.
                     write (output,"('0******** Card number,',i9,
     &', entered on,',i9,', is not present in input deck.')") cnum,
     & l3y(1)
                   endif
                   if (id1.lt.1 .or. id1.gt.n4 .or. id2.lt.id1
     &             .or. id2.gt.n4 .or. id3.lt.1) then
                     tfail = .true.
                     write (output,"('0******** One or more words in
     & card,',i9,', are not correct.')") l3y(1)
                   endif
                   fail = fail .or. tfail
                   if ( .not.tfail) then
!mpfu: changed because we do not have access to cards from rcards.
                     l3u(1) = cnum
                     do ju=2,5
                       l3u(ju) = 0
                     enddo
                     eflg(1) = .false.
                     eflg(2) = .false.
                     l3u(6) = 1
!mpfu: initially all cards are expected to be real because base value
!      should be real, we do not care about other values.
!      To be changed once discrete functions are available.
!      id2 is the number of components
                     do ju = 7,7+n4-1
                       l3u(ju) = 1
                     enddo
!mpfu: call arguments added are j (word position), and eflg (error flag)
                     call inp2u (fa(filndx(1)),initu,l3u,
     &id1,id2,id3,eflg)
                       if (eflg(1) .or. eflg(2)) fail = .true.
                       if (eflg(1)) write (output,"('0******** Word num
     &ber ',i4,' specified in card ',i9,' is out of range')") j,l3y(1)
                       if (eflg(2)) write (output,"('0******** Input car
     &d,',i9,', has an error and cannot be processed for uncertainty ana
     &lysis.')") cnum
                     do j = id1,id2,id3 
                     if (.not.fail) then
!  Process individual words.
!  Card number to be modified copied.
                           baseval = xinitu(j)
                           if (baseval .eq. 0.0) then
                             fail = .true.
                             write (output,"('0******** Word',i5,' 
     &on card',i9,' is zero.')") j,cnum
                           else
                             if (numi .eq. 0) then
                               allocate (first)
                               crnt => first
                             else
                               allocate (crnt%next)
                               crnt => crnt%next
                             endif
                             allocate (crnt%inpcard)
                             numi = numi + 1
                             crnt%inpcard%distrtp = 
     &                       uncinp(nd)%distrtp
                             crnt%inpcard%chparam(1) = 
     &                       uncinp(nd)%chparam(1)
                             crnt%inpcard%chparam(2) = 
     &                       uncinp(nd)%chparam(2)
                             crnt%inpcard%chparam(3) = 
     &                       uncinp(nd)%chparam(3)
                             crnt%inpcard%chparam(4) = 
     &                       uncinp(nd)%chparam(4)
                             crnt%inpcard%baseval = baseval 
                             if (j.ne.id1 .and. ipcw(2).eq.2) then
                               crnt%inpcard%wt = 0.0
                             else
                               crnt%inpcard%wt = wt
                             endif
                             crnt%inpcard%nd = nd
                             crnt%inpcard%cardno = cnum
                             crnt%inpcard%cardw = j
                             if (j.ne.id1 .and. ipcw(1).eq.1) then
                               crnt%inpcard%ipcw(1) = 0
                             else
                               crnt%inpcard%ipcw(1) = ipcw(1)
                             endif
                             if (ipcw(1) .eq. 3) then
                               if (j .eq. id1) then 
                                 crnt%inpcard%ipcw(1) = 1
                               elseif (j .eq. id2) then
                                 crnt%inpcard%ipcw(1) = 2
                               else
                                 crnt%inpcard%ipcw(1) = 0
                               endif
                             endif
                             crnt%inpcard%ipcw(2) = ipcw(2)
                             crnt%inpcard%ipcw(3) = ipcw(3)
                           endif
                     endif
                     enddo
                   endif
                 enddo 
               endif
               if (ixy .eq. -1) then
                 nd = 99
                 exit
               elseif (ixy .ge. l3d(1)+1000) then
                 if ((lnorm .and. crnt%inpcard%ipcw(1).eq.0) .or. 
     &           crnt%inpcard%ipcw(1).eq.1) then
                   fail = .true.
                   write (output,"('0******** Last normalization flag on
     & card, ',i9,', is invalid.')") l3y(1) 
                 endif
                 exit
               else 
                 ny = ixy-l3d(1)
                 cycle
               endif
             endif
           enddo
         endif
         nd = nd + 1
         if (nd .ge. 99) exit
         if (ixy .eq. -1) exit
       enddo
!  Write header if there are input parameters
       if (numi.eq.0) then
         write (output,"('0No input weights information.')")
       else
         write (output,"('0List of input weights information.')")
       endif
!  Copy input modification information from threaded list to standard 
!  array format.
       allocate (inpcard(numi))
       crnt => first
       do i = 1,numi
         inpcard(i) = crnt%inpcard
!  Check if any normalization requested.
         if (inpcard(i)%ipcw(1).eq.1 .or. inpcard(i)%ipcw(1).eq.3) then
           lnorm = .true.
         endif
         crnt => crnt%next
       enddo
!  Order cards and word numbers using the standard array format.
       if (numi .gt. 1) then
         do i = 2,numi
           lph = .false.
           if (inpcard(i)%cardno .lt. inpcard(i-1)%cardno) then
             lph = .true.
           elseif (inpcard(i)%cardno .eq. inpcard(i-1)%cardno) then
             if (inpcard(i)%cardw .lt. inpcard(i-1)%cardw) lph = .true.
             if (inpcard(i)%cardw .eq. inpcard(i-1)%cardw) then
               fail = .true.
               write (output,"('0******** Card number ',i9,', word numbe
     &er ',i3,' is duplicated.')") inpcard(i)%cardno,inpcard(i)%cardw
             endif
           endif
           if (lph) then
             varh = inpcard(i)
             j = i - 1
             do
               inpcard(j+1) = inpcard(j)
               j = j - 1
               if (j .ne. 0) then
                 if (varh%cardno .lt. inpcard(j)%cardno) cycle
                 if (varh%cardno .eq. inpcard(j)%cardno) then
                   if (varh%cardw .lt. inpcard(j)%cardw) then
                     cycle
                   elseif (varh%cardw .eq. inpcard(j)%cardw) then
                     fail = .true.
                     write (output,"('0******** Card number ',i9,', word
     & number ',i3,', is duplicated.')") inpcard(j)%cardno,
     &               inpcard(j)%cardw
                   endif
                 endif
               endif
               inpcard(j+1) = varh
               exit
             enddo
           endif
         enddo
       endif
       if (numi) then
         write (output,"(' Card no.',5x,'Word no.',2x,'Base value',3x,
     &'Distr.  R1',11x,'R2',11x,'R3',11x,'R4',11x,'Weight flag')")
         do j = 1,numi
           write (output,"(i9,1x,i5,7x,es13.5,1x,a3,4x,5es13.5)") 
     &   inpcard(j)%cardno,inpcard(j)%cardw,inpcard(j)%baseval,
     &   inpcard(j)%distrtp,inpcard(j)%chparam(1),inpcard(j)%chparam(2),
     &   inpcard(j)%chparam(3),inpcard(j)%chparam(4),inpcard(j)%wt
         enddo
       endif
!
!  Calculate source and input weights for each run.
       do i = uncmin,unctrun
         write (filewts(je+1:je+6),"(i4.4,'.w')") i
         write (output,"('Weights for run',i5,': ',a)") i,trim(filewts)
         open (unit=stripf,file=filewts,status='new',form='unformatted',
     &   iostat=len)
         if (len .ne. 0) then
           fail = .true.
           wrflag = .false.
           write (tty,2011) len,trim(filewts)
 2011  format ('Open error number',i8,' on file ',a,', perhaps file alre
     &ady exists.')
           write (output,2012) len,trim(filewts)
 2012  format ('0******** Open error number',i8,' on file ',a,', perhaps
     & file already exists.')
         endif
         write (output,"('0 Num   Quantity',7x,'Distr.  R1',11x,'R2',
     &11x,'R3',11x,'R4',11x,'Weight')")
       if (uncrewr .eq. -1) then
!uncpackalt
       slist => sfirst
       nums = 0
       do while (associated(slist%snext))
         if (.not.slist%sourcard%uncw) then
             select case (slist%sourcard%distrtp)
             case ('ND')
               call normdistr (slist%sourcard%chparam(:),
     &         slist%sourcard%uncwt)
             case ('UD')
               call unifdistr (slist%sourcard%chparam(:),
     &         slist%sourcard%uncwt)
             case ('TD')
               call trapdistr (slist%sourcard%chparam(:),
     &         slist%sourcard%uncwt)
             case ('LD')
               call lgnormdistr (slist%sourcard%chparam(:),
     &         slist%sourcard%uncwt)
             case default
               fail = .true.
               write (output,"('0******** Distribution type ',a2,' is no
     &t a valid type.')") slist%sourcard%distrtp
             end select
         endif
         write (output,"(i5,3x,a16,3x,a2,5es13.5)") nums+1,
     &   slist%sourcard%unvarnm,slist%sourcard%distrtp,
     &   slist%sourcard%chparam(1:4),slist%sourcard%uncwt
!
!  Over write the weights specified in the input deck.
         select case (slist%sourcard%unvarnm(1:3))
         case ("FRV")
           uncfrv(slist%compon)%distrtp = slist%sourcard%distrtp
           uncfrv(slist%compon)%chparam(1:4) = 
     &     slist%sourcard%chparam(1:4)
           uncfrv(slist%compon)%uncwt = slist%sourcard%uncwt
           uncfrv(slist%compon)%extra = slist%sourcard%extra
           uncfrv(slist%compon)%uncw = slist%sourcard%uncw
         case ("HTC")
           unchtc(slist%compon)%distrtp = slist%sourcard%distrtp
           unchtc(slist%compon)%chparam(1:4) = 
     &     slist%sourcard%chparam(1:4)
           unchtc(slist%compon)%uncwt = slist%sourcard%uncwt
           unchtc(slist%compon)%extra = slist%sourcard%extra
           unchtc(slist%compon)%uncw = slist%sourcard%uncw
         case ("CHF")
           uncchf(slist%compon)%distrtp = slist%sourcard%distrtp
           uncchf(slist%compon)%chparam(1:4) = 
     &     slist%sourcard%chparam(1:4)
           uncchf(slist%compon)%uncwt = slist%sourcard%uncwt
           uncchf(slist%compon)%extra = slist%sourcard%extra
           uncchf(slist%compon)%uncw = slist%sourcard%uncw
         case ("GAP")
           uncgap(slist%compon)%distrtp = slist%sourcard%distrtp
           uncgap(slist%compon)%chparam(1:4) = 
     &     slist%sourcard%chparam(1:4)
           uncgap(slist%compon)%uncwt = slist%sourcard%uncwt
           uncgap(slist%compon)%extra = slist%sourcard%extra
           uncgap(slist%compon)%uncw = slist%sourcard%uncw
         case ("VIS")
           uncvis(slist%compon)%distrtp = slist%sourcard%distrtp
           uncvis(slist%compon)%chparam(1:4) = 
     &     slist%sourcard%chparam(1:4)
           uncvis(slist%compon)%uncwt = slist%sourcard%uncwt
           uncvis(slist%compon)%extra = slist%sourcard%extra
           uncvis(slist%compon)%uncw = slist%sourcard%uncw
         case ("CON")
           unccon(slist%compon)%distrtp = slist%sourcard%distrtp
           unccon(slist%compon)%chparam(1:4) = 
     &     slist%sourcard%chparam(1:4)
           unccon(slist%compon)%uncwt = slist%sourcard%uncwt
           unccon(slist%compon)%extra = slist%sourcard%extra
           unccon(slist%compon)%uncw = slist%sourcard%uncw
         case ("SFT")
           uncsft(slist%compon)%distrtp = slist%sourcard%distrtp
           uncsft(slist%compon)%chparam(1:4) = 
     &     slist%sourcard%chparam(1:4)
           uncsft(slist%compon)%uncwt = slist%sourcard%uncwt
           uncsft(slist%compon)%extra = slist%sourcard%extra
           uncsft(slist%compon)%uncw = slist%sourcard%uncw
         case ("RES")
           unctungs(slist%compon)%distrtp = slist%sourcard%distrtp
           unctungs(slist%compon)%chparam(1:4) = 
     &     slist%sourcard%chparam(1:4)
           unctungs(slist%compon)%uncwt = slist%sourcard%uncwt
           unctungs(slist%compon)%extra = slist%sourcard%extra
           unctungs(slist%compon)%uncw = slist%sourcard%uncw
         case ("OXI")
           uncoxid(slist%compon)%distrtp = slist%sourcard%distrtp
           uncoxid(slist%compon)%chparam(1:4) = 
     &     slist%sourcard%chparam(1:4)
           uncoxid(slist%compon)%uncwt = slist%sourcard%uncwt
           uncoxid(slist%compon)%extra = slist%sourcard%extra
           uncoxid(slist%compon)%uncw = slist%sourcard%uncw
         end select
         nums = nums+1
         slist => slist%snext
       enddo
!endif below on uncrewr
       endif
!uncpackalt The other coding is commented out.
!         do j = 1,nfrv
!!  Calculate weight or use setup input file value.
!           if ( .not.uncfrv(j)%uncw) then
!             select case (uncfrv(j)%distrtp)
!             case ('ND')
!               call normdistr (uncfrv(j)%chparam(:),uncfrv(j)%uncwt)
!             case ('UD')
!               call unifdistr (uncfrv(j)%chparam(:),uncfrv(j)%uncwt)
!             case ('TD')
!               call trapdistr (uncfrv(j)%chparam(:),uncfrv(j)%uncwt)
!             end select
!           endif
!           write (output,"(i5,3x,a16,3x,a2,5es13.5)") j,
!     &     uncfrv(j)%unvarnm,uncfrv(j)%distrtp,uncfrv(j)%chparam(1:4),
!     &     uncfrv(j)%uncwt
!         enddo
!         do j = 1,nhtc
!!  Calculate weight or use setup input file value.
!           if ( .not.unchtc(j)%uncw) then
!             select case (unchtc(j)%distrtp)
!             case ('ND')
!               call normdistr (unchtc(j)%chparam(:),unchtc(j)%uncwt)
!             case ('UD')
!               call unifdistr (unchtc(j)%chparam(:),unchtc(j)%uncwt)
!             case ('TD')
!               call trapdistr (unchtc(j)%chparam(:),unchtc(j)%uncwt)
!             end select
!           endif
!           write (output,"(i5,3x,a16,3x,a2,5es13.5)") j,
!     &     unchtc(j)%unvarnm,unchtc(j)%distrtp,unchtc(j)%chparam(1:4),
!     &     unchtc(j)%uncwt
!         enddo
!         do j = 1,nchf
!!  Calculate weight or use setup input file value.
!           if ( .not.uncchf(j)%uncw) then
!             select case (uncchf(j)%distrtp)
!             case ('ND')
!               call normdistr (uncchf(j)%chparam(:),uncchf(j)%uncwt)
!             case ('UD')
!               call unifdistr (uncchf(j)%chparam(:),uncchf(j)%uncwt)
!             case ('TD')
!               call trapdistr (uncchf(j)%chparam(:),uncchf(j)%uncwt)
!             end select
!           endif
!           write (output,"(i5,3x,a16,3x,a2,5es13.5)") j,
!     &     uncchf(j)%unvarnm,uncchf(j)%distrtp,uncchf(j)%chparam(1:4),
!     &     uncchf(j)%uncwt
!         enddo
!         do j = 1,ngap
!!  Calculate weight or use setup input file value.
!           if (uncgap(j)%extra .ne. -1.0) then
!             if ( .not.uncgap(j)%uncw) then
!               select case (uncgap(j)%distrtp)
!               case ('ND')
!                 call normdistr (uncgap(j)%chparam(:),uncgap(j)%uncwt)
!               case ('UD')
!                 call unifdistr (uncgap(j)%chparam(:),uncgap(j)%uncwt)
!               case ('TD')
!                 call trapdistr (uncgap(j)%chparam(:),uncgap(j)%uncwt)
!               end select
!             endif
!           endif
!           write (output,"(i5,3x,a16,3x,a2,5es13.5)") j,
!     &     uncgap(j)%unvarnm,uncgap(j)%distrtp,uncgap(j)%chparam(1:4),
!     &     uncgap(j)%uncwt
!         enddo
!         do j = 1,nvis
!!  Calculate weight or use setup input file value.
!           if ( .not.uncvis(j)%uncw) then
!             select case (uncvis(j)%distrtp)
!             case ('ND')
!               call normdistr (uncvis(j)%chparam(:),uncvis(j)%uncwt)
!             case ('UD')
!               call unifdistr (uncvis(j)%chparam(:),uncvis(j)%uncwt)
!             case ('TD')
!               call trapdistr (uncvis(j)%chparam(:),uncvis(j)%uncwt)
!             end select
!           endif
!           write (output,"(i5,3x,a16,3x,a2,5es13.5)") j,
!     &     uncvis(j)%unvarnm,uncvis(j)%distrtp,uncvis(j)%chparam(1:4),
!     &     uncvis(j)%uncwt
!         enddo
!         do j = 1,ncon
!!  Calculate weight or use setup input file value.
!           if ( .not.unccon(j)%uncw) then
!             select case (unccon(j)%distrtp)
!             case ('ND')
!               call normdistr (unccon(j)%chparam(:),unccon(j)%uncwt)
!             case ('UD')
!               call unifdistr (unccon(j)%chparam(:),unccon(j)%uncwt)
!             case ('TD')
!               call trapdistr (unccon(j)%chparam(:),unccon(j)%uncwt)
!             end select
!           endif
!           write (output,"(i5,3x,a16,3x,a2,5es13.5)") j,
!     &     unccon(j)%unvarnm,unccon(j)%distrtp,unccon(j)%chparam(1:4),
!     &     unccon(j)%uncwt
!         enddo
!         do j = 1,nsft
!!  Calculate weight or use setup input file value.
!           if ( .not.uncsft(j)%uncw) then
!             select case (uncsft(j)%distrtp)
!             case ('ND')
!               call normdistr (uncsft(j)%chparam(:),uncsft(j)%uncwt)
!             case ('UD')
!               call unifdistr (uncsft(j)%chparam(:),uncsft(j)%uncwt)
!             case ('TD')
!               call trapdistr (uncsft(j)%chparam(:),uncsft(j)%uncwt)
!             end select
!           endif
!           write (output,"(i5,3x,a16,3x,a2,5es13.5)") j,
!     &     uncsft(j)%unvarnm,uncsft(j)%distrtp,uncsft(j)%chparam(1:4),
!     &     uncsft(j)%uncwt
!         enddo
!uncpackalt test
!uncpackalt test write (12,"('run number ',i4)") i
!uncpackalt test write (12,"('CHF.LT.GR weight =',es13.5)") uncchf(13)%uncwt
!uncpackalt test
         write (stripf) i,unctrun
         write (stripf) titlewordd,nfrv,nhtc,nchf,ngap,nvis,ncon,nsft,
     & ntungs,noxid
         write (stripf) uncfrv(:)
         write (stripf) unchtc(:)
         write (stripf) uncchf(:)
         write (stripf) uncgap(:)
         write (stripf) uncvis(:)
         write (stripf) unccon(:)
         write (stripf) uncsft(:)
         write (stripf) unctungs(:)
         write (stripf) uncoxid(:)
!
!  Get weights for input quantitites.
         prev => first
         crnt => first
         write (stripf) numi
         write (output,"('0 Num',3x,'Card no.',4x,'Word no.',2x,
     &'Base value',5x,'Weight',9x,'New value')") 
         do j = 1,numi
           if (crnt%inpcard%wt .eq. 0.0) then
             wt = prev%inpcard%wtc
           elseif (crnt%inpcard%wt .eq. -1.0) then
!  Compute weights if input card = -1.0 
             select case (crnt%inpcard%distrtp)
             case ('ND')
               call normdistr (crnt%inpcard%chparam(:),wt)
             case ('UD')
               call unifdistr (crnt%inpcard%chparam(:),wt)
             case ('TD')
               call trapdistr (crnt%inpcard%chparam(:),wt)
             case ('LD')
               call lgnormdistr (crnt%inpcard%chparam(:),wt)
             case default
               fail = .true.
               write (output,"('0******** Distribution type ',a2,' is no
     &t a valid type.')") crnt%inpcard%distrtp
             end select
           else
             wt = crnt%inpcard%wt
           endif
           crnt%inpcard%wtc = wt
           prev => crnt
           crnt => crnt%next
         enddo
!  Apply normalization if requested.
         if (lnorm) then
           lnorm = .false.
           lnorme = .false.
           crnt => first
           do j = 1,numi
             if (crnt%inpcard%ipcw(1) .eq. 1) then
               lnorm = .true.
               sumw(:) = 0.0
               firstb => crnt
               k = 0
             elseif (crnt%inpcard%ipcw(1) .eq. 2) then
               lnorme = .true.
             endif
             if (lnorm) then
              k = k + 1 
              sumw(1) = sumw(1) + crnt%inpcard%baseval
              sumw(2) = sumw(2) + crnt%inpcard%baseval*crnt%inpcard%wtc
             endif
             if (lnorme) then
               lnorm = .false.
               lnorme = .false.
               mwt = sumw(1)/sumw(2)
               crntb => firstb
               do l = 1,k
                 crntb%inpcard%wtc = crntb%inpcard%wtc*mwt 
                 crntb => crntb%next
               enddo
             endif
             crnt => crnt%next
           enddo
           lnorm = .true.
         endif
         crnt => first
         do j = 1,numi
           uncout%wt = crnt%inpcard%wtc
           uncout%baseval = crnt%inpcard%baseval
           if (crnt%inpcard%ipcw(3).eq.1 .and. 
     &     (uncout%baseval*uncout%wt).gt.1.0) uncout%wt = 1.0
           uncout%cardno = crnt%inpcard%cardno
           uncout%cardw = crnt%inpcard%cardw
!  Write input data to stripf
           write (stripf) uncout
!  Write input data to output file
           write (output,"(i5,2x,i9,2x,i3,7x,es13.5,2x,es13.5,2x,
     &     es13.5)") j,uncout%cardno,uncout%cardw,uncout%baseval,
     &     uncout%wt,uncout%baseval*uncout%wt
           crnt => crnt%next
         enddo
         close (stripf,status='keep')
       enddo
!
!  Write information from setup needed for post processing.
       if (.not.uncmode) then
           write (rstplt) filsch(ipr)
           write (rstplt) beta,gama,iorder,betac
           write (rstplt) uncwilksn,unctrun
           close (rstplt)
       endif
!
       call random_seed(get=seed)
       write (output,"('0Next seed to be used is ',i15)") seed
       if ( .not.fail) then
         write (output,"('0Computation of source and input uncertainty w
     &eights completed succesfully.')")
         write (tty,"('0Computation of source and input uncertainty weig
     &hts completed succesfully.')")
       else
         write (output,"('0******** Errors detected during setup process
     & for source and input uncertainty weights computation.')")
         write (tty,"('0******** Errors detected during setup process fo
     &r source and input uncertainty weights computation.')")
       endif
!
       end subroutine unccalc
!
       subroutine uncrdrun
! Read uncertainty weight files.
       use inpmodul
       implicit none
       include 'comctl.h'
       include 'contrl.h'
       include 'fast.h'
       include 'ufilef.h'
       include 'ufiles.h'
       type (uncoutt) :: uncout
       real(kr) baseval
       integer i,ips,len,nfrvck,nhtcck,nchfck,ngapck,nvisck,
     & nconck,nsftck,ntungsck,noxidck,numi,ix,n3,n4
       logical tfail
       character(16) titleword,titlewordd
       data titlewordd/'Source weights'/
!
       ips = 6
       if (fail) return
       if (uncmode) then
         write (output,"('0 - - - This run is using the uncertainty anal
     &ysis option. - - -')")
         if (uncrun.lt.0 .or. uncrun.gt.9999) then
           fail = .true.
         write (output,"('0******** Uncertainty run number is out of ran
     &ge.')")
         endif
!  Read in weights.
         open (unit=stripf,file=filsch(ips),status='old',
     &   form='unformatted',iostat=len)
         if (len .ne. 0) then
           fail = .true.
           write (output,"('0******** Unable to open file,',a,', for unc
     &ertainty run,',i5,'.')") trim(filsch(ips)),uncrun
         else
           read (stripf) i,unctrun
           if (i .ne. uncrun) then
             fail = .true.
             write (output,"('0******** Run number indicated in weight f
     &ile,',i5,', is different from that on input line 106.')") i
           endif
!
           read (stripf) titleword,nfrvck,nhtcck,nchfck,ngapck,nvisck,
     &                   nconck,nsftck,ntungsck,noxidck
           if (titleword .ne. titlewordd) then
             fail = .true.
             write (output,"('0******** Header identifying source weight
     &s not found.')")
           elseif (nfrvck .ne. nfrv) then
               fail = .true.
               write (output,"('0******** Number of weights read does no
     &t match number of weights defined in program.')")
           elseif (nhtcck .ne. nhtc) then
               fail = .true.
               write (output,"('0******** Number of weights read does no
     &t match number of weights defined in program.')")
           elseif (nchfck .ne. nchf) then
               fail = .true.
               write (output,"('0******** Number of weights read does no
     &t match number of weights defined in program.')")
           elseif (ngapck .ne. ngap) then
               fail = .true.
               write (output,"('0******** Number of weights read does no
     &t match number of weights defined in program.')")
           elseif (nvisck .ne. nvis) then
               fail = .true.
               write (output,"('0******** Number of weights read does no
     &t match number of weights defined in program.')")
           elseif (nconck .ne. ncon) then
               fail = .true.
               write (output,"('0******** Number of weights read does no
     &t match number of weights defined in program.')")
           elseif (nsftck .ne. nsft) then
               fail = .true.
               write (output,"('0******** Number of weights read does no
     &t match number of weights defined in program.')")
           elseif (ntungsck .ne. ntungs) then
               fail = .true.
               write (output,"('0******** Number of weights read does no
     &t match number of weights defined in program.')")
           elseif (noxidck .ne. noxid) then
               fail = .true.
               write (output,"('0******** Number of weights read does no
     &t match number of weights defined in program.')")
           endif
!
           read (stripf,iostat=i) uncfrv(:)
           if (i .ne. 0) then
             fail = .true.
             write (output,"('0******** Unable to read file,',a,', for u
     &ncertainty run,',i5,'.')") trim(filsch(ips)),uncrun
           endif
           read (stripf,iostat=i) unchtc(:)
           if (i .ne. 0) then
             fail = .true.
             write (output,"('0******** Unable to read file,',a,', for u
     &ncertainty run,',i5,'.')") trim(filsch(ips)),uncrun
           endif
           read (stripf,iostat=i) uncchf(:)
           if (i .ne. 0) then
             fail = .true.
             write (output,"('0******** Unable to read file,',a,', for u
     &ncertainty run,',i5,'.')") trim(filsch(ips)),uncrun
           endif
           read (stripf,iostat=i) uncgap(:)
           if (i .ne. 0) then
             fail = .true.
             write (output,"('0******** Unable to read file,',a,', for u
     &ncertainty run,',i5,'.')") trim(filsch(ips)),uncrun
           endif
           read (stripf,iostat=i) uncvis(:)
           if (i .ne. 0) then
             fail = .true.
             write (output,"('0******** Unable to read file,',a,', for u
     &ncertainty run,',i5,'.')") trim(filsch(ips)),uncrun
           endif
           read (stripf,iostat=i) unccon(:)
           if (i .ne. 0) then
             fail = .true.
             write (output,"('0******** Unable to read file,',a,', for u
     &ncertainty run,',i5,'.')") trim(filsch(ips)),uncrun
           endif
           read (stripf,iostat=i) uncsft(:)
           if (i .ne. 0) then
             fail = .true.
             write (output,"('0******** Unable to read file,',a,', for u
     &ncertainty run,',i5,'.')") trim(filsch(ips)),uncrun
           endif
           read (stripf,iostat=i) unctungs(:)
           if (i .ne. 0) then
             fail = .true.
             write (output,"('0******** Unable to read file,',a,', for u
     &ncertainty run,',i5,'.')") trim(filsch(ips)),uncrun
           endif
           read (stripf,iostat=i) uncoxid(:)
           if (i .ne. 0) then
             fail = .true.
             write (output,"('0******** Unable to read file,',a,', for u
     &ncertainty run,',i5,'.')") trim(filsch(ips)),uncrun
           endif
!  Read input uncertainty.
           read (stripf) numi
           do i = 1,numi
             read (stripf) uncout
             call inplnku (uncout%cardno,ix,n3,n4,fa(filndx(1)))
             tfail = .false.
             if (n4 .eq. 0) then
               if (uncrstrt) then
                 tfail = .true.
                 write (output,"('0******** Card ',i9,' was not found fo
     &r uncertainty modification')") uncout%cardno
               endif
             else
               if (n4 .lt. uncout%cardw) then
                 tfail = .true.
                 write (output,"('0******** Word number ',i3,' is not pr
     &esent in card ',i9,'.')") uncout%cardw,uncout%cardno
               endif
             endif
             fail = fail .or. tfail
             if ( .not.uncrstrt) then
               if (.not.tfail) then
                 write (output,"('0******** Card ',i9,' cannot be in res
     &tart input file.')") uncout%cardno
                 exit
               else
                 cycle
               endif
             endif
             if ( .not.fail) then
!  Base value to be modified.
               baseval = fa(filndx(1)-2+n3+uncout%cardw)
               if (baseval .ne. uncout%baseval) then
                 fail = .true.
                 write (output,"('0******** Value to be modified is diff
     &erent from that enterd during uncertainty setup processing.')")
               else
!  Modifies the base value with the uncertainty weight.
                 baseval = baseval*uncout%wt
                 fa(filndx(1)-2+n3+uncout%cardw) = baseval
                 write (output,"('0 Word',i4,' on card number',i9,
     &', has been modified from its base value,'es13.5,', to',es13.5,
     &'.')") uncout%cardw,uncout%cardno,uncout%baseval,baseval
               endif
             endif
           enddo
           close (stripf)
           if ( .not.fail) then
             write (output,"('0Uncertainty weights for run,',i5,', were 
     &read from, ',a,'.')") uncrun,trim(filsch(ips))
           else
             write (output,"('0******** Errors detected when reading wei
     &ghts for run ',i5)") uncrun
             write (tty,"('Errors detected when reading weights for run 
     &',i5)") uncrun
           endif
         endif
       endif
       end subroutine uncrdrun
!
       subroutine appwtchf(rchf,ghighr)
!  Apply uncertainty weights to CHF correlations
!
       implicit none
       include 'flood.h'
       include 'htrcom.h'
       include 'rflhtc.h'
       real (kr) rchf
       real ghighr
       integer i
!
!  PG correlations.
       if (pgopta .gt. 0) then
!  PG power.
         if (pgopta .gt. 40) then
           i = 1
           if (pgopta .eq. 41) then
             rchf = rchf*uncchf(i)%uncwt
           elseif (pgopta .eq. 42) then
             rchf = rchf*uncchf(i+1)%uncwt
           else
             rchf = rchf*uncchf(i+2)%uncwt
           endif
!  PG geometry.
         elseif (pgopta .gt. 30) then
           i = 4
           if (pgopta .eq. 31) then
             rchf = rchf*uncchf(i)%uncwt
           elseif (pgopta .eq. 32) then
             rchf = rchf*uncchf(i+1)%uncwt
           else
             rchf = rchf*uncchf(i+2)%uncwt
           endif
!  PG flux.
         elseif (pgopta .gt. 20) then
           i = 7
           if (pgopta .eq. 21) then
             rchf = rchf*uncchf(i)%uncwt
           elseif (pgopta .eq. 22) then
             rchf = rchf*uncchf(i+1)%uncwt
           else
             rchf = rchf*uncchf(i+2)%uncwt
           endif
!  PG basic
         else
           i = 10
           if (pgopta .eq. 11) then
             rchf = rchf*uncchf(i)%uncwt
           elseif (pgopta .eq. 12) then
             rchf = rchf*uncchf(i+1)%uncwt
           else
             rchf = rchf*uncchf(i+2)%uncwt
           endif
         endif
!  CHF lookup table method.
       elseif (onrefl.eq.1 .and. pgopta.eq.0) then
         if (gabs .ge. ghighr) then
           i = 13
           rchf = rchf*uncchf(i)%uncwt
         endif
       elseif (htopta.ne.51 .and. htopta.ne.2 .and. htopta.le.33 .or. 
     & htopta.ge.50) then
         i = 13
         rchf = rchf*uncchf(i)%uncwt
       endif
       end subroutine appwtchf
!
       subroutine appwthtc (inder)
!  Applies uncertainty weights to HTF correlations.
!
       implicit none
       include 'fast.h'
       include 'htrcom.h'
       include 'htscr.h'
       integer inder
!
       character*2 type2
       integer i,jr,modeapp
       logical lhelp
!
! modeapp: ranges from 0 to 11. if reflood or non-condensable
!          40 or 20 is subtracted.
       if (mode .ge. 40) then
         modeapp = mode - 40
       elseif (mode .ge. 20) then
         modeapp = mode - 20
       else 
         modeapp = mode
       endif
       if (modeapp .lt. 20) then
         if (modeapp.lt.0 .or. modeapp.gt.11) call fabend
         jr = modeapp + 1
!  type2 gives heat structure geometry type.
         write (type2,"(i2.2)") htopta
         lhelp = .false.
         do i = 1,5
           if (type2 .eq. unchtc(jr)%unvarnm(9:10)) then
             lhelp = .true.
             exit
           endif
           jr = jr + 12    
         enddo
         if ( .not.lhelp) call fabend
!  Apply to each quantity.
         hthht(inder) = hthht(inder)*unchtc(jr)%uncwt
         hthhff(inder) = hthhff(inder)*unchtc(jr)%uncwt
         hthhft(inder) = hthhft(inder)*unchtc(jr)%uncwt
         hthhgg(inder) = hthhgg(inder)*unchtc(jr)%uncwt
         hthhgt(inder) = hthhgt(inder)*unchtc(jr)%uncwt
         hthhgp(inder) = hthhgp(inder)*unchtc(jr)%uncwt
         htqost(inder) = htqost(inder)*unchtc(jr)%uncwt
         htqosf(inder) = htqosf(inder)*unchtc(jr)%uncwt
         htqosg(inder) = htqosg(inder)*unchtc(jr)%uncwt
       else
         call fabend
       endif
       end subroutine appwthtc
!
       subroutine appwtfrv(ir)
!  Applies uncertainty weights to correlations.
       use lpdatc
!
       implicit none
       include 'fast.h'
       include 'jundat.h'
       include 'voldat.h'
       integer ir,jr,floregi
!
       floregi = int(floreg(ir))
       jr = 3*(floregi - 1) + 1
       hif(ir) = hif(ir)*uncfrv(jr)%uncwt
       hig(ir) = hig(ir)*uncfrv(jr+1)%uncwt
       hgf(ir) = hgf(ir)*uncfrv(jr+2)%uncwt
       end subroutine appwtfrv
!
       subroutine appwtgap (thconr,tgapr)
!  Applies uncertainty weights to thermal conductivity computed when
!  gap conductance model is activated.
!
       implicit none
       real(kr) thconr,tgapr
!
       if (uncgap(1)%extra .ne. -1.0) then
         thconr = thconr*uncgap(1)%uncwt
       elseif (uncgap(2)%extra.ne.-1.0 .or. uncgap(3)%extra.ne.-1.0) 
     & then
         if (uncgap(2)%extra.ne.-1.0 .and. tgapr.le.uncgap(2)%extra) 
     &   thconr = thconr*uncgap(2)%uncwt
         if (uncgap(3)%extra.ne.-1.0 .and. tgapr.gt.uncgap(3)%extra) 
     &   thconr = thconr*uncgap(3)%uncwt
       else 
!  If no gap uncertainty eneterd, all temperatures have same weight.
         thconr = thconr*uncgap(1)%uncwt
       endif
       end subroutine appwtgap
!
       subroutine appwtvis (ifluidr,stater,ihldr,nhr,viscr,iscskpr)
!  Applies uncertainty weights to viscosity.
!
       implicit none
       integer ihr,ifluidr,ihldr(*),iscskpr,ir,mr,nhr
       real(kr) viscr(*)
       character*(*) stater
!
       ihr = 1
       do mr = 1,nhr
         ir = ihldr(ihr)
         select case (ifluidr)
         case (1,12,15,16)
           if (stater .eq. 'liquid') viscr(ir) = 
     & viscr(ir)*uncvis(1)%uncwt
           if (stater .eq. 'vapor') viscr(ir) = 
     & viscr(ir)*uncvis(2)%uncwt
         case (2)
           if (stater .eq. 'liquid') viscr(ir) = 
     & viscr(ir)*uncvis(3)%uncwt
           if (stater .eq. 'vapor') viscr(ir) = 
     & viscr(ir)*uncvis(4)%uncwt
         end select
         ihr = ihr + iscskpr
       enddo
       end subroutine appwtvis
!
       subroutine appwtcon (ifluidr,stater,ihldr,nhr,thconr,iscskpr)
!  Applies uncertainty weights to thermal conductivity.
!
       implicit none
       integer ihr,ifluidr,ihldr(*),iscskpr,ir,mr,nhr
       real(kr) thconr(*)
       character*(*) stater
!
       ihr = 1
       do mr = 1,nhr
         ir = ihldr(ihr)
         select case (ifluidr)
         case (1,12,15,16)
           if (stater .eq. 'liquid') thconr(ir) = 
     &                              thconr(ir)*unccon(1)%uncwt
           if (stater .eq. 'vapor') thconr(ir) = 
     &                              thconr(ir)*unccon(2)%uncwt
         case (2)
           if (stater .eq. 'liquid') thconr(ir) = 
     &                              thconr(ir)*unccon(3)%uncwt
           if (stater .eq. 'vapor') thconr(ir) = 
     &                              thconr(ir)*unccon(4)%uncwt
         end select
         ihr = ihr + iscskpr
       enddo
       end subroutine appwtcon
!
       subroutine appwtsft (ifluidr,ihldr,nhr,sigmar,iscskpr)
!  Applies uncertainty weights to thermal conductivity.
!
       implicit none
       integer ir,ihr,ifluidr,ihldr(*),mr,nhr,iscskpr
       real(kr) sigmar(*)
!
       ihr = 1
       do mr = 1,nhr
         ir = ihldr(ihr)
         select case (ifluidr)
         case (1,12,15,16)
           sigmar(ir) = sigmar(ir)*uncsft(1)%uncwt
         case (2)
           sigmar(ir) = sigmar(ir)*uncsft(3)%uncwt
         end select
         ihr = ihr + iscskpr
       enddo
       end subroutine appwtsft
!
       subroutine appwttungs (widersr)
!
       implicit none
       real(kr) widersr
!
       widersr = widersr*unctungs(ntungs)%uncwt
       end subroutine appwttungs
!
       subroutine appwtoxid (coxr)
!  Applies uncertainty weights to thermal conductivity.
!
       implicit none
       real(kr) coxr
!
       coxr = coxr*uncoxid(noxid)%uncwt
       end subroutine appwtoxid
!
       subroutine ncalculation (betas,gama,order,uncwilksn,betac)
!
       implicit none
       real(kr) betas,gama,betac,order,s,x
       integer uncwilksn
       logical level
       real(kr) dbetai
!
       level = .false.
       s = order
       x = 1.0 - gama
       do while (.not. level)
!  Computes regularized incomplete beta function
!         call incob(order,s,1.0-gama,betac)
         betac = dbetai(x,order,s)
         if (betac .ge. betas) then
           uncwilksn = s+order-1
           level = .true.
         else
           s = s+1
         endif
       enddo
       end subroutine ncalculation 
!
       subroutine normdistr (params, weight)
!  Computes weight for normal distribution.
       implicit none
       include 'contrl.h'
       include 'ufilef.h'
       include 'ufiles.h'
       real(kr) params(:),weight
       real(kr) m, sd, aleat1, aleat2, lowlim, upplim, x1,
     & pi
!UNCtrunc: times controls the number of iterations to find a value within
!          the truncation limits
!          truncation is set to true when W3 and W4 are used.
       integer times
       logical truncation
       parameter (pi = 3.1415927e0)
!UNCtrunc: initialization
       truncation = .false.
       lowlim = 0.
       upplim = 0.
!**************************************************c
!  NORMAL probability distribution function
!  mostreig: 2var + INVERSION: Box-Mller method
!  manual PENELOPE, pages 16&17
!**************************************************c
       m = params(1)
       sd = params(2)
!
!UNCtrunc: W3 and W4 are processed, they cannot be negative.
       if ((params(3).lt.0.) .or. (params(4).lt.0.)) then
         fail = .true.
         write (output,"('0******** Truncation field in normal distribut
     &ion cannot be negative.')")
!UNCtrunc: Check if truncation is activated.
!          Truncation activated if W3 and W4 are non-zero & positive.
       elseif (params(3).eq.0.0) then
!UNCtrunc: Truncation is disabled
         if (params(4) .ne. 0.0) then
           fail = .true.
           write (output,"('0******** Error in truncation definition')")
           return
         else
           truncation = .false.
           write (output,"('Truncation is not applied')")
         endif
       elseif ((params(3).lt.0.) .or. (params(4).lt.0.)) then
         write (output,"('0******** Truncation values cannot be negative
     &')")
       else
!UNCtrunc: Truncation is enabled.
         truncation = .true.
         write (output,"('Truncation applied')")
         lowlim = m - sd*params(3)
         upplim = m + sd*params(4)
       endif
!
!Note:  log() = ln in FORTRAN
!
!UNCtrunc: Computation of weights if truncation enabled.
       if(truncation) then
!UNCtrunc: set variable times to 0 to control the number of iterations.
         times = 0
         do
           times = times + 1
           call random_number (aleat1)
           call random_number (aleat2)
           x1=sqrt(-2.0*log(aleat1))*cos(2.0*pi*aleat2)
!  y, normal distribution, m sd.        
           weight = m + x1*sd
!UNCtrunc: Checks the number of iterations
           if (times .lt. 10e3) then
             if ((weight.lt.lowlim) .or. (weight.gt.upplim)) then
               cycle
               write (output,"('Iteration = ',i9)") times
             else
               exit
             endif
           else
             write (output,"('0******** Too many iterations')")
             fail = .true.
             return
           endif
         enddo
!UNCtrunc: Computation of weights if NO truncation.
       else
           call random_number (aleat1)
           call random_number (aleat2)
           x1=sqrt(-2.0*log(aleat1))*cos(2.0*pi*aleat2)
!  y, normal distribution, m sd.        
           weight = m + x1*sd
       endif
!
       end subroutine normdistr
!
       subroutine lgnormdistr (params, weight)
!  Computes weight for lgnormal distribution.
       implicit none
       include 'contrl.h'
       include 'ufilef.h'
       include 'ufiles.h'
       real(kr) params(:),weight
       real(kr) m, sd, aleat1, aleat2, lowlim, upplim, x1,
     & pi
!UNCtrunc: times controls the number of iterations to find a value within
!          the truncation limits
!          truncation is set to true when W3 and W4 are used.
       integer times
       logical truncation
       parameter (pi = 3.1415927e0)
!UNCtrunc: initialization
       truncation = .false.
       lowlim = 0.
       upplim = 0. 
!**************************************************c
!  LOG-NORMAL probability distribution function
!  mostreig: 2var + INVERSION: Box-Mller method
!  manual PENELOPE, pages 16&17
!**************************************************c
       m = params(1)
       sd = params(2)
!
!UNCtrunc: W3 and W4 are processed, they cannot be negative.
       if ((params(3).lt.0.) .or. (params(4).lt.0.)) then
         fail = .true.
         write (output,"('0******** Truncation field in normal distribut
     &ion cannot be negative.')")
!UNCtrunc: Check if truncation is activated.
!          Truncation activated if W3 and W4 are non-zero & positive.
       elseif (params(3).eq.0.0) then
!UNCtrunc: Truncation is disabled
         if (params(4) .ne. 0.0) then
           fail = .true.
           write (output,"('0******** Error in truncation definition')")
           return
         else
           truncation = .false.
           write (output,"('Truncation is not applied')")
         endif
       elseif ((params(3).lt.0.) .or. (params(4).lt.0.)) then
         write (output,"('0******** Truncation values cannot be negative
     &')")
       else
!UNCtrunc: Truncation is enabled.
         truncation = .true.
         write (output,"('Truncation applied')")
         lowlim = m - sd*params(3)
         upplim = m + sd*params(4)
       endif
!
!Note:  log() = ln in FORTRAN
!
!UNCtrunc: Computation of weights if truncation enabled.
       if(truncation) then
!UNCtrunc: set variable times to 0 to control the number of iterations.
         times = 0
         do
           times = times + 1
           call random_number (aleat1)
           call random_number (aleat2)
           x1=sqrt(-2.0*log(aleat1))*cos(2.0*pi*aleat2)
!  y, normal distribution, m sd.        
           weight = m + x1*sd
!UNCtrunc: Checks the number of iterations
           if (times .lt. 10e3) then
             if ((weight.lt.lowlim) .or. (weight.gt.upplim)) then
               cycle
               write (output,"('Iteration = ',i9)") times
             else
!  y, log-normal distribution, m sd.        
               weight = exp(m + x1*sd)
               exit
             endif
           else
             write (output,"('0******** Too many iterations')")
             fail = .true.
             return
           endif
         enddo
!UNCtrunc: Computation of weights if NO truncation.
       else
           call random_number (aleat1)
           call random_number (aleat2)
           x1=sqrt(-2.0*log(aleat1))*cos(2.0*pi*aleat2)
!  y, log-normal distribution, m sd.        
           weight = exp(m + x1*sd)
       endif
!
       end subroutine lgnormdistr
!
       subroutine unifdistr (params, weight)
!  Computes weight for uniform distribution.
       implicit none
       real(kr) params(:),weight
!
       real(kr) r2, r1
         r1 = params(1)
         r2 = params(2)
         call random_number (weight)
         weight = weight*(r2-r1)+r1
       end subroutine unifdistr
!
       subroutine trapdistr (params, weight)
!  Computes weight for trapezoidal distribution.
!  r1 = lower left limit, r2 = upper left limit, 
!  r3 = upper right limit, r4 = lower right limit
!
       implicit none
       real(kr) params(:),weight
!
       real(kr) r1, r2, r3, r4, lim1, lim2, const, r12, r22, r32, 
     & a, b, b2, c, d, d2, cumul
!
!***********************************************c
!** p = f*g*h: probability distribution        *c
!** c = normalization constant   	       *c
!** f = c*(x-r1)/(r2-r1) --> p = f x<r2        *c
!** g = c*1              --> p = g r2>=x<=r3   *c
!** h = c*(r4-x)/(r4-r3) --> p = h x<=r4       *c
!**					       *c
!** INVERSION METHOD                           *c
!***********************************************c	
       r1 = params(1)
       r2 = params(2)
       r3 = params(3)
       r4 = params(4)
!***** CONSTANTS
       r12=1.0e0*r1**2
       r22=1.0e0*r2**2
       r32=1.0e0*r3**2
!
       const=2.0e0/(r4+r3-r1-r2)
!
!  region inside r1&r2, y=ax+b
       a = const/(r2-r1)
       b=-1.0e0*r1*a
       b2=1.0e0*b**2
!
!  region inside R3&R4, y=cx+d
       c =const/(r3-r4)
       d=-1.0e0*r4*c
       d2=1.0e0*d**2
!
!  limits:
      lim1=(a/2)*(r22-r12)+b*(r2-r1)
      lim2=lim1+const*(r3-r2)
!
!***** rand() gives a random number [0,1]
!***** cumulative value
       call random_number (cumul)
!
!* 1st interval (r1,r2)
       if (cumul.le.lim1) then
         weight = r1 + sqrt(2*cumul/a)
!* 2nd interval (r2,r3)
       elseif (cumul.le.lim2) then
         weight = (cumul-lim1)/const+r2
!* 3rd interval (r3,r4)
       else 
         weight = r4*(1-sqrt((const/d)**2-(2*(cumul-lim2)/(r4*d))))
       endif
       end subroutine trapdistr
!
       subroutine uncposti (tpostr)
!  Read code run numbers for uncertainty analysis
       use inpmodul
       implicit none
       include 'comctl.h'
       include 'fast.h'
       include 'ufilef.h'
       include 'ufiles.h'
       logical tpostr
!
       integer i,irun(9999),j,k,l3a(9),nrun,ktemp,init(8000)
       character(8) av1(9999)
       real xinit(8000)
       equivalence (init(1),xinit(1))
       data l3a/29200000,-29209999,1,9998,0,1,2,2*0/
       tpostr = .false.
!
       krun = 0
       ktemp = 0
       nrun = 0
       l3a(6) = 1
       call inp2 (fa(filndx(1)),init,l3a)
       if (l3a(6) .lt. 0) then
         tpostr =.true.
       endif
       if (.not.tpostr) then
         do i = 1,l3a(6)
           ktemp = ktemp + 1
           irun(i) = init(i)
!  First word of first card cannot be less than zero.
           if (i .eq. 1) then
             if (irun(i) .le. 0) then
               tpostr = .true.
               write (output,"('0******** First number on card',i9,'
     & cannot be zero nor negative.')") l3a(1)
               exit
             endif
           else
!  Check runs are in consecutive order.
             if (abs(irun(ktemp)) .lt. abs(irun(ktemp-1))) then
               tpostr = .true.
               write (output,"('0******** Numbers in cards 2920XXXX are 
     &not in consecutive order.')") 
               exit
             endif
           endif
!  Calculate the number of runs under analysis, krun.
           if (irun(ktemp) .ge. 0) then
             krun = krun + 1
           else
             krun = krun + abs(irun(ktemp)) - irun(ktemp-1)
           endif
         enddo
       endif
!
       write (output,"('Number of runs under analysis is ',i5)") krun
       allocate (irunno(0:krun))
       irunno(0) = 0
!
       k = 1
       do i = 1,ktemp
         if (irun(i) .ge. 0) then
           irunno(k) = irun(i)
           k = k+1
           cycle
         else
           do j = 1,abs(irun(i))-irun(i-1)
             irunno(k) = irun(i-1)+j
             k = k+1
           enddo
         endif
       enddo
       write (output,"('0Run numbers other than the base case for post p
     &rocessing:')")
       do j = 1,krun
         write (output,'(i4)') irunno(j)
       enddo
!
!  Call rusrvr.ff : 2080XXXX processing, to bring in the parameters 
!  under analysis.
       call rusrvr
!
       end subroutine uncposti
!
$endif
       end module uncdata
