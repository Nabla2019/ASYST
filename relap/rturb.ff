*mlist
       subroutine rturb
*in32 init
*in32 iscr
*in32end
c  Process turbine component data.
c
c  Cognizant engineer: rjw,jat.
c
       use cmpdat
       use jundat
       use voldat
       implicit none
       include 'fast.h'
       include 'cmpdat.h'
       include 'comctl.h'
       include 'cons.h'
       include 'contrl.h'
       include 'jundat.h'
       include 'rcompc.h'
       include 'turbin.h'
       include 'ufiles.h'
       include 'voldat.h'
c
c  Local variables.
       integer l3a(8),l3b(18),l3c(10),l3d(12),l3e(9),l3f(12),l3g(10),
     & l3h(10),l3j(14),init(12),iscr(1089)
       real xinit(12),xcr(1089)
       equivalence (init(1),xinit(1)),(iscr(1),xcr(1))
       integer i,i1,i2,i3,ibor,icc,ick,id,idans,ief,ihb,ihf,ihff,ihl,
     & ihp,iht,ihv,ii,ij,ije,ijs,imat,ink,irf,isf,ist,it,iv,ix,ixp,
     & inp10,jcn(2),k,k1,k2,kk,lcntgs,lens,n,n3,n4,nc,nc1,nj,njs,nj1,
     & nj1o,nnv,nt,nv1,nv1o
       real angl(3),cinrt,crpm,cs(3),ctorq,degf1,degf2,eng,
     & fr(4),ft,ft2,ft3,psia,rpi180,si(3),tt,xlbsec
       logical tfail,ovl,mmfl
       character labl1(2)*5,labl2(2)*9,labl3(2)*8,lcord(3)*1
c
c  Data statements.
       parameter (lens=26)
       data rpi180/1.745329252e-2/
       data l3a/2*0,1,2,0,1,0,0/
       data l3b/2*0,9,12,0,1,8*1,0,0,1,1/
       data l3c/2*0,3,6,0,1,0,2,1,1/
       data l3d/2*0,2*6,0,1,0,0,1,1,1,0/
       data l3e/2*0,2,3,0,1,3*1/
       data l3f/2*0,5,6,0,1,3*1,3*0/
       data l3g/2*0,3,4,0,1,0,3*1/
       data l3h/2*0,0,4,0,1,1,1,1,1/
       data l3j/2*0,0,8,0,1,4*1,0,3*1/
       data ft/0.3048/, ft2/9.290304e-2/, ft3/2.831685e-2/,
     & eng/2.326e3/, psia/6.894757e3/, degf1/0.5555555555555/,
     & degf2/255.3722222222/, xlbsec/.45359237/, tt/300.0/
       data crpm/0.10471975512/,cinrt/0.04214011009/,ctorq/1.355817948/
       data labl1/' vel.',' flow'/, labl2/'(ft/sec)','(lbm/sec)'/,
     & labl3/'(m/sec)','(kg/sec)'/
       data lcord/'x','y','z'/
c
c  Get component number.
       ovl = .false.
       i = ncmps(filndx(3)) + filndx(3)
       nc = cmpnum(i)
c  Extend component block.
       filsiz(3) = filsiz(3) + lens
       l3a(1) = filsiz(3)
       if (.not.cmpsrc) l3a(1) = l3a(1) + lens
       if (lcntgs(filid(3),1) .ge. l3a(1)) go to 10
   15  write (output,2001) nc
 2001  format ('0******** Insufficient storage to process component',i4,
     & '.')
   12  l3c(1) = nc*10000
       l3c(2) = l3c(1) + 9999
       filsiz(1) = inp10(fa(filndx(1)),l3c(1),l3c(2))
       call ftbsft (2.0,filsiz(1),1,filndx(1))
  204  filsiz(3) = filsiz(3) - lens + 4
       cmplen(i) = 4
       cmptyp(i) = 0
       call ftbsft (filid(3),filsiz(3),1,filndx(3))
       ncmps(filndx(3)) = ncmps(filndx(3)) + 4
       fail = .true.
       return
   10  call ftbsft (filid(3),l3a(1),1,filndx(3))
       i = ncmps(filndx(3)) + filndx(3)
       cmplen(i) = lens
c  Get number of junctions in turbine.
       l3a(1) = nc*10000 + 1
       l3a(6) = 1
       call inp2 (fa(filndx(1)),init,l3a)
       if (l3a(6) .gt. 0) go to 69
  408  write (output,2002) nc
 2002  format ('0******** Data for component',i4,' cannot be processed.'
     +)
       go to 12
   69  ixp = 0
       if (l3a(6) .eq. 1) go to 11
       ixp = init(2)
       if (ixp.eq.0 .or. ixp.eq.1) go to 11
       write (output,2027)
 2027  format ('0******** Control for junction initial conditions incorr
     &ect, set to 0 for continued checking.')
       fail = .true.
       ixp = 0
   11  nj = init(1)
       if (nj .lt. 1 .or. nj .gt. 2) then
         write (output,2003) l3a(1)
 2003  format ('0******** Number of junctions specified on card',i9,
     & ' must be 1 or 2.')
         go to 12
       endif
       nvc(i) = 1
       njc(i) = nj
       cmpopt(i) = ixp
c  Check if replacement or flag modification is possible.
       if (cmpsrc) go to 401
       ii = filndx(3)
       nnv = ncomp - 1
       if (nnv .ne. 0) then
         nv1 = 0
         nj1 = 0
         tfail = .false.
         do 402 k = 1,nnv
           nv1o = nvc(ii)
           nj1o = njc(ii)
           nc1 = cmplen(ii)
           if (cmpnum(ii) .eq. nc) go to 404
           if (cmpnum(ii) .gt. nc) tfail = .true.
           nv1 = nv1 + nv1o
           nj1 = nj1 + nj1o
           ii = ii + nc1
  402    continue
         if (tfail) go to 410
       endif
       cmpsrc = .true.
       go to 401
  404  ncomp = nnv
       if (cmptyp(ii) .ne. cmptyp(i)) go to 406
       if (njc(ii) .ne. njc(i)) go to 406
       ovl = cmpflg
       go to 14
  410  nv1o = 0
       nj1o = 0
       nc1 = 0
  406  if (.not.cmpflg) go to 14
  409  write (output,2035) nc
 2035  format ('0******** Illegal use of component flag change option in
     & component',i4,'.')
       go to 408
c  Extend volume and junction blocks for component.
  401  if (cmpflg) go to 409
   14  if (cmpsrc) nv1o = 0
       k2 = 1 - nv1o
       k = filsiz(4) + k2*ivskp
       k1 = max(filsiz(4),k)
       if (k1 .gt. lcntgs(filid(4),1)) go to 15
       call ftbsft (filid(4),k1,1,filndx(4))
       if (cmpsrc) nv1 = nvols(filndx(4))
       iv = nv1*ivskp + filndx(4)
       k1 = (nvols(filndx(4)) - nv1 - nv1o)*ivskp
       if (k1 .ne. 0) then
         n3 = iv + nv1o*ivskp
         n4 = iv + ivskp
         ink = n3 - n4
         if (ink .ne. 0) then
           if (ink .lt. 0) k1 = -k1
           call ftbmov (nvols[n3+1),nvols[n4+1),k1)
         endif
       endif
       nvols(filndx(4)) = nvols(filndx(4)) + k2
       if (associated(cmphld(nc)%volp)) deallocate (cmphld(nc)%volp)
       allocate (cmphld(nc)%volp(1))
       if (associated(cmphld(nc)%junp)) deallocate (cmphld(nc)%junp)
       allocate (cmphld(nc)%junp(nj))
   16  filsiz(4) = k
c  Set storage for new volumes.
       if (.not.ovl) then
         call setndf (nvols(iv+1),ivskp)
         vctrl(iv) = 8
         vctrlx(iv) = 0
         imap(iv) = 16384
         imap(iv+1) = 0
         imap(iv+2) = 0
         do k = 1,3
           frica(iv+k-1) = 0.0
           fricb(iv+k-1) = 0.0
           fricc(iv+k-1) = 0.0
         enddo
       endif
c  Get junction block.
       njs = nj*ijskp
       if (cmpsrc) nj1o = 0
       k2 = nj - nj1o
       k = filsiz(5) + k2*ijskp
       k1 = max(filsiz(5),k)
       if (k1 .gt. lcntgs(filid(5),1)) go to 15
       call ftbsft (filid(5),k1,2,filndx(5))
       if (cmpsrc) nj1 = njuns(filndx(5))
       ij = nj1*ijskp + filndx(5)
       k1 = (njuns(filndx(5)) - nj1 - nj1o)*ijskp
       if (k1 .eq. 0) go to 421
       n3 = ij + nj1o*ijskp
       n4 = ij + njs
       if (n3 - n4) 422,421,423
  422  k1 = -k1
$if -def,in32,1
  423  call ftbmov (njuns(n3+1),njuns(n4+1),k1)
$if def,in32,1
  423  call ftbmov (njuns[n3+1),njuns[n4+1),k1)
  421  njuns(filndx(5)) = njuns(filndx(5)) + k2
       filsiz(5) = k
       if (nj .eq. 0) go to 430
       ije = ij + njs - 1
       if (ovl) go to 430
       call setndf (njuns(ij+1),njs)
       do k = ij,ije,ijskp
         jc(k) = 128
         jcex(k) = 0
         ijflg(k) = 0
         athrot(k) = 1.0
         guinval(k:k+1) = 0.0
         guinang(k:k+1) = 0.0
cjmk-1
         if (chngno(53)) then
c  Henry-Fauske default values.
           jdissc(k) = 1.0
           jdistp(k) = 0.14
           jdissh(k) = 0.0
         else
c  Standard default values.
           jdissc(k) = 1.0
           jdistp(k) = 1.0
           jdissh(k) = 1.0
         endif
cjmk-1
       enddo
  430  call ftbsft (filid(5),filsiz(5),2,filndx(5))
       call ftbsft (filid(4),filsiz(4),2,filndx(4))
       iv = nv1*ivskp + filndx(4)
       ij = nj1*ijskp + filndx(5)
c  Insert new component in proper place in component block if necessary.
       if (.not.cmpsrc .and. nc1.ne.0) then
         k2 = lens - nc1
         n3 = ii + nc1
         n4 = ii + lens
         k1 = i + lens - n3
         if (k2 .ne. 0) then
           if (k2 .gt. 0) k1 = -k1
$if -def,in32,1
           call ftbmov (cmpnum(n3),cmpnum(n4),k1)
$if def,in32,1
           call ftbmov (cmpnum[n3),cmpnum[n4),k1)
           i = i + k2
         endif
$if -def,in32,1
         call ftbmov (cmpnum(i),cmpnum(ii),lens)
$if def,in32,1
         call ftbmov (cmpnum[i),cmpnum[ii),lens)
         i = ii
         ncmps(filndx(3)) = ncmps(filndx(3)) + k2
         filsiz(3) = filsiz(3) + k2 - lens
         call ftbsft (filid(3),filsiz(3),3,filndx(3))
       else
         ncmps(filndx(3)) = ncmps(filndx(3)) + lens
       endif
       n = i
c  Write output header for component.
   17  if( iand(ihlppr(2),ishft(1,22)).ne.0 )
     & write (output,2101) nc,cmpnam(i),cmpalf(cmptyp(i)),nj
 2101  format ('0====================================================='
     & '==================',/,
     & 22x,'Input data for component',i4,',',2a9,', having
     & 1 volume and',i3,' junctions')
c  Process volume geometry input.
       if (.not.uniti) then
         fr(1) = ft
         fr(2) = ft2
         fr(3) = ft3
       else
         fr(1) = 1.0
         fr(2) = 1.0
         fr(3) = 1.0
       endif
       l3b(1) = nc*10000 + 101
       l3b(2) = -l3b(1) - 8
       l3b(6) = 1
       call inp2 (fa(filndx(1)),init,l3b)
       if (l3b(6) .le. 0) then
         write (output,2007) lcord(1)
 2007  format ('0******** Volume geometry conditions for ',a1,' coordina
     &te are set to default values for continued checking.')
         if (.not.cmpflg) then
           avol(iv) = 1.0
           dl(iv) = 1.0
           v(iv) = 1.0
           rhof(iv) = 0.0
           rho(iv) = 0.0
           do k = 1,18
             hydxc(iv+k-1) = 0.0
           enddo
           roughv(iv) = 0.0
           diamv(iv) = 2.0*sqrt(avol(iv)/pi)
           fshape(iv:iv+2) = 1.0
           fmurex(iv:iv+2) = 0.0
         endif
         fail = .true.
         go to 115
       endif
       if (cmpflg) go to 34
       avol(iv) = xinit(1)*fr(2)
       if (avol(iv) .lt. 0.0) then
         avol(iv) = 1.0
         write (output,2005) lcord(1)
 2005  format ('0******** Volume area for ',a1,' coordinate is less than
     & 0.0, is set to 1.0 for continued checking.')
         fail = .true.
       endif
       dl(iv) = xinit(2)*fr(1)
       if (dl(iv) .lt. 0.0) then
         dl(iv) = 1.0
         write (output,2009) lcord(1)
 2009  format ('0******** Volume length for ',a1,' coordinate is less th
     &an 0.0, is set to 1.0 for continued checking.')
         fail = .true.
       endif
       v(iv) = xinit(3)*fr(3)
       if (v(iv) .lt. 0.0) then
         write (output,2011)
 2011  format ('0******** Volume volume less than 0.0, set to 1.0 for co
     &ntinued checking.')
         fail = .true.
         v(iv) = 1.0
       endif
c  Apply defaults to volume area, length, and volume.
       tfail = .false.
       if (v(iv) .eq. 0.0) then
         v(iv) = avol(iv)*dl(iv)
         if (v(iv) .ne. 0.0) go to 27
         tfail = .true.
         v(iv) = 1.0
       endif
       if (avol(iv) .eq. 0.0) then
         if (dl(iv) .ne. 0.0) then
           avol(iv) = v(iv)/dl(iv)
           go to 65
         endif
         tfail = .true.
         avol(iv) = 1.0
       endif
       if (dl(iv) .eq. 0.0) then
         dl(iv) = v(iv)/avol(iv)
         go to 65
       endif
       if (abs(avol(iv)*dl(iv)-v(iv))/v(iv) .le. 0.000001) go to 65
       write (output,2031) lcord(1)
 2031  format ('0******** Volume is not equal to area times length for '
     &,a1,' coordinate.')
       go to 64
   65  if (.not.tfail) go to 27
       write (output,2030) lcord(1)
 2030  format ('0******** Only one of the volume area, length, or volume
     & may be 0.0, default values used.')
   64  fail = .true.
   27  rhof(iv) = xinit(4)
       if (abs(rhof(iv)) .gt. 360.0) then
         rhof(iv) = 0.0
         write (output,2012)
 2012  format ('0******** Horizontal angle incorrect, set to 0.0 for con
     &tinued checking.')
         fail = .true.
       endif
       rho(iv) = xinit(5)
       if (rho(iv).lt.-90.0 .or. rho(iv).gt.90.0) then
         rho(iv) = 0.0
         write (output,2013)
 2013  format ('0******** Vertical angle incorrect, set to 0.0 for conti
     &nued checking.')
         fail = .true.
       endif
       angl(1) = rhof(iv)*rpi180
       angl(2) = rho(iv)*rpi180
       cs(1) = cos(angl(1))
       si(1) = sin(angl(1))
       cs(2) = cos(angl(2))
       si(2) = sin(angl(2))
       cmphld(nc)%volp(1)%hyanpr(1,1) = cs(1)*cs(2)
       cmphld(nc)%volp(1)%hyanpr(1,2) = -si(1)
       cmphld(nc)%volp(1)%hyanpr(1,3) = -cs(1)*si(2)
       cmphld(nc)%volp(1)%hyanpr(2,1) = si(1)*cs(2)
       cmphld(nc)%volp(1)%hyanpr(2,2) = cs(1)
       cmphld(nc)%volp(1)%hyanpr(2,3) = -si(1)*si(2)
       cmphld(nc)%volp(1)%hyanpr(3,1) = si(2)
       cmphld(nc)%volp(1)%hyanpr(3,2) = 0
       cmphld(nc)%volp(1)%hyanpr(3,3) = cs(2)
       dl(iv+1) = 2.0*sqrt(avol(iv)/pi)
       dl(iv+2) = dl(iv+1)
       hydxc(iv) = 0.5*cmphld(nc)%volp(1)%hyanpr(1,1)*dl(iv)
       hydxc(iv+1) = hydxc(iv)
       hydxc(iv+2) = 0.5*cmphld(nc)%volp(1)%hyanpr(1,2)*dl(iv+1)
       hydxc(iv+3) = hydxc(iv+2)
       hydxc(iv+4) = 0.5*cmphld(nc)%volp(1)%hyanpr(1,3)*dl(iv+2)
       hydxc(iv+5) = hydxc(iv+4)
       hydyc(iv) = 0.5*cmphld(nc)%volp(1)%hyanpr(2,1)*dl(iv)
       hydyc(iv+1) = hydyc(iv)
       hydyc(iv+2) = 0.5*cmphld(nc)%volp(1)%hyanpr(2,2)*dl(iv+1)
       hydyc(iv+3) = hydyc(iv+2)
       hydyc(iv+4) = 0.5*cmphld(nc)%volp(1)%hyanpr(2,3)*dl(iv+2)
       hydyc(iv+5) = hydyc(iv+4)
       hydzc(iv) = 0.5*cmphld(nc)%volp(1)%hyanpr(3,1)*dl(iv)
       hydzc(iv+1) = hydzc(iv)
       hydzc(iv+2) = 0.5*cmphld(nc)%volp(1)%hyanpr(3,2)*dl(iv+1)
       hydzc(iv+3) = hydzc(iv+2)
       hydzc(iv+4) = 0.5*cmphld(nc)%volp(1)%hyanpr(3,3)*dl(iv+2)
       hydzc(iv+5) = hydzc(iv+4)
       if (l3b(6) .lt. 10) init(10) = 1
       if (l3b(6) .lt. 11) xinit(11) = 0.0
       if (l3b(6) .lt. 12) xinit(12) = 0.0
       if (init(10) .ne. 0) then
         if (init(10) .eq. 2) then
           hydxc(iv) = 0.5*xinit(11)*fr(1)
           hydxc(iv+1) = hydxc(iv)
           hydyc(iv) = 0.5*xinit(12)*fr(1)
           hydyc(iv+1) = hydyc(iv)
         endif
         hydzc(iv) = 0.5*xinit(6)*fr(1)
         hydzc(iv+1) = hydzc(iv)
         tfail = .false.
         if (rho(iv) .eq. 0.0) then
           if (hydzc(iv) .ne. 0) tfail = .true.
         else
           if (rho(iv)*hydzc(iv) .le. 0.0) tfail = .true.
         endif
         if (tfail) then
           write (output,2033)
 2033  format ('0******** Volume vertical angle inconsistent with vertic
     &al incremental height.')
           fail = .true.
         endif
       endif
       if (abs(hydzc(iv) + hydzc(iv+1)) .gt. dl(iv) .or.
     & abs(hydyc(iv) + hydyc(iv+1)).gt.dl(iv) .or.
     & abs(hydzc(iv) + hydzc(iv+1)).gt.dl(iv)) then
         write (output,2015)
 2015  format ('0******** Volume positional change is greater than volum
     &e length for ',a1,' coordinate.')
         fail = .true.
       endif
       roughv(iv) = xinit(7)*fr(1)
       if (roughv(iv) .lt. 0.0) then
         roughv(iv) = 0.0
         write (output,2016) lcord(1)
 2016  format ('0******** Volume roughness for ',a1,' coordinate is less
     & than 0.0, set to 0.0 for continued checking.')
         fail = .true.
       endif
       diamv(iv) = xinit(8)*fr(1)
       if (diamv(iv) .le. 0.0) then
         if (diamv(iv) .lt. 0.0) then
           write (output,2017) lcord(1)
 2017  format ('0******** Hydraulic diameter for ',a1,' coordinate is le
     &ss than 0.0, set to default value for continued checking.')
           fail = .true.
         endif
         diamv(iv) = 2.0*sqrt(avol(iv)/pi)
       endif
       if (roughv(iv) .ge. 0.5*diamv(iv)) then
         write (output,2034) lcord(1)
 2034  format ('0******** Volume roughness is not less than half the vol
     &ume hydraulic diameter for ',a1,' coordinate.')
         fail = .true.
       endif
       fshape(iv:iv+2) = 1.0
       fmurex(iv:iv+2) = 0.0
   34  tfail = .false.
       if (init(9) .lt. 0) then
         init(9) = -init(9)
         tfail = .true.
       endif
       iht = init(9)/1000000
       init(9) = init(9) - 1000000*iht
       if (iht .ne. 0) then
         iht = 0
         tfail = .true.
       endif
       ihl = init(9)/100000
       init(9) = init(9) - 100000*ihl
       if (ihl .ne. 0) then
         ihl = 0
         tfail = .true.
       endif
       ihp = init(9)/10000
       init(9) = init(9) - 10000*ihp
       if (ihp .gt. 1) then
         ihp = 0
         tfail = .true.
       elseif (ihp .eq. 0) then
         ihp = 1
       endif
       ihv = init(9)/1000
       init(9) = init(9) - 1000*ihv
       if (ihv .gt. 1) then
         ihv = 0
         tfail = .true.
       elseif (ihv .eq. 0) then
         ihv = 1
       endif
       ihb = init(9)/100
       init(9) = init(9) - 100*ihb
       idans = 0
       if (ihb .ne. 0) then
         ihb = 0
         tfail = .true.
       endif
       ihf = init(9)/10
       ihff = 0
       init(9) = init(9) - 10*ihf
       if (ihf .ne. 1) then
         write (output,2052)
 2052  format ('0******** Zero wall friction is required in turbine; sta
     &ndard wall friction does not account for blading structures.')
         ihf = 1
         tfail = .true.
       endif
       if (init(9) .gt. 1) then
         init(9) = 0
         tfail = .true.
       endif
       if (tfail) then
         write (output,2021)
 2021  format ('0******** Volume control incorrect, set to zero for cont
     &inued checking.')
         fail = .true.
       endif
       vctrl(iv) = ior(ior(ior(ior(vctrl(iv),ishft(iht,2)),
     & ishft(init(9),1)),ishft(ihb,30)),ishft(ihp,7))
       imap(iv) = ior(ior(ior(ior(ior(ior(imap(iv),ishft(ihv,9)),
     & ishft(ihb,16)),ishft(ihf,13)),ishft(idans,27)),ishft(ihff,26)),
     & ishft(ihl,28))
       do 3000 id = 1,2
         l3j(1) = nc*10000 + 171 + id*10
         l3j(2) = -l3j(1) - 8
         l3j(6) = 1
         k = iv + id
         kk = iv + 2*id
         call inp2 (fa(filndx(1)),init,l3j)
         if (l3j(6) .le. 0) then
           if (l3j(6) .lt. 0) then
             write (output,2007) lcord(id+1)
             fail = .true.
           endif
           avol(k) = v(iv)/dl(k)
           roughv(k) = 0.0
           diamv(k) = 4.0*avol(k)/sqrt(pi*avol(iv))
         else
           imap(k) = ior(imap(k),16384)
           avol(k) = xinit(1)*fr(2)
           if (avol(k) .lt. 0.0) then
             avol(k) = v(iv)/dl(iv)
             write (output,2005) lcord(id+1)
             fail = .true.
           endif
           dl(k) = xinit(2)*fr(1)
           if (dl(k) .lt. 0.0) then
             dl(k) = 2.0*sqrt(avol(iv)/pi)
             write (output,2009) lcord(id+1)
             fail = .true.
           endif
c  Apply defaults to volume area, length, and volume.
           tfail = .false.
           if (avol(k) .eq. 0.0) then
             if (dl(k) .ne. 0.0) then
               avol(k) = v(iv)/dl(k)
               go to 965
             endif
             tfail = .true.
             avol(k) = 1.0
           endif
           if (dl(k) .eq. 0.0) then
             dl(k) = v(iv)/avol(k)
             go to 965
           endif
           if (abs(avol(k)*dl(k)-v(iv))/v(iv) .le. 0.000001) go to 965
           write (output,2031) lcord(id+1)
           go to 964
  965      if (.not.tfail) go to 927
           write (output,2030) lcord(id+1)
  964      fail = .true.
  927      if (l3j(6) .le. 5) then
             if (id .eq. 1) then
               hydxc(iv+2) =
     &         0.5*cmphld(nc)%volp(1)%hyanpr(1,2)*dl(iv+1)
               hydxc(iv+3) = hydxc(iv+2)
               hydyc(iv+2) =
     &         0.5*cmphld(nc)%volp(1)%hyanpr(2,2)*dl(iv+1)
               hydyc(iv+3) = hydyc(iv+2)
               hydzc(iv+2) =
     &         0.5*cmphld(nc)%volp(1)%hyanpr(3,2)*dl(iv+1)
               hydzc(iv+3) = hydzc(iv+2)
             else
               hydxc(iv+4) =
     &         0.5*cmphld(nc)%volp(1)%hyanpr(1,3)*dl(iv+2)
               hydxc(iv+5) = hydxc(iv+4)
               hydyc(iv+4) =
     &         0.5*cmphld(nc)%volp(1)%hyanpr(2,3)*dl(iv+2)
               hydyc(iv+5) = hydyc(iv+4)
               hydzc(iv+4) =
     &         0.5*cmphld(nc)%volp(1)%hyanpr(3,3)*dl(iv+2)
               hydzc(iv+5) = hydzc(iv+4)
             endif
           else
             if (l3j(6) .lt. 8) then
               write (output,2050) l3j(1),-l3j(2)
 2050  format ('0******** Incorrect number of words on cards',i8,' throu
     &gh'i8,'.')
               fail = .true.
               if (l3j(6) .lt. 7) xinit(8) = 0.0
               if (l3j(6) .lt. 8) xinit(9) = 0.0
             endif
             hydxc(kk) = 0.5*xinit(6)*fr(1)
             hydxc(kk+1) = hydxc(kk)
             hydyc(kk) = 0.5*xinit(7)*fr(1)
             hydyc(kk+1) = hydyc(kk)
             hydzc(kk) = 0.5*xinit(8)*fr(1)
             hydzc(kk+1) = hydzc(kk)
           endif
           if (abs(hydxc(kk) + hydxc(kk+1)) .gt. dl(k) .or.
     &     abs(hydyc(kk) + hydyc(kk+1)) .gt. dl(k) .or.
     &     abs(hydzc(kk) + hydzc(kk+1)) .gt. dl(k)) then
             write (output,2015) lcord(id+1)
             fail = .true.
           endif
           roughv(k) = xinit(3)*fr(1)
           if (roughv(k) .lt. 0.0) then
             roughv(k) = 0.0
             write (output,2016) lcord(id+1)
             fail = .true.
           endif
           diamv(k) = xinit(4)*fr(1)
           if (diamv(k) .le. 0.0) then
             if (diamv(k) .lt. 0.0) then
               write (output,2017) lcord(id+1)
               fail = .true.
             endif
             diamv(k) = 4.0*avol(k)/sqrt(pi*avol(iv))
           endif
           if (roughv(k) .ge. 0.5*diamv(k)) then
             write (output,2034) lcord(id+1)
             fail = .true.
           endif
           tfail = .false.
           if (init(5) .lt. 0) then
             init(5) = -init(5)
             tfail = .true.
           endif
           iht = init(5)/1000000
           init(9) = init(5) - 1000000*iht
           if (iht .ne. 0) then
             iht = 0
             tfail = .true.
           endif
           ihl = init(5)/100000
           init(5) = init(5) - 100000*ihl
           if (ihl .ne. 0) then
             ihl = 0
             tfail = .true.
           endif
           ihp = init(5)/10000
           init(9) = init(5) - 10000*ihp
           if (ihp .ne. 0) then
             ihp = 0
             tfail = .true.
           endif
           ihv = init(5)/1000
           init(5) = init(5) - 1000*ihv
           if (ihv .ne. 0) then
             ihv = 0
             tfail = .true.
           endif
           ihb = init(5)/100
           init(5) = init(5) - 100*ihb
           idans = 0
           if (ihb .ne. 0) then
             ihb = 0
             tfail = .true.
           endif
           ihf = init(5)/10
           init(5) = init(5) - 10*ihf
           if (ihf .gt. 2) then
             ihf = 0
             ihff = 0
             tfail = .true.
           else
             ihff = ishft(ihf,-1)
             ihf = iand(ihf,1)
           endif
           if (init(5) .ne. 0) then
             init(5) = 0
             tfail = .true.
           endif
           if (tfail) then
             write (output,2021) lcord(id+1)
             fail = .true.
           endif
           imap(k) = ior(ior(imap(k),ishft(ihf,13)),ishft(ihff,26))
         endif
 3000  continue
c  Process volume initial conditions.
  115  if (cmpflg) go to 50
       if (.not.uniti) then
         fr(1) = psia
         fr(2) = eng
         fr(3) = degf1
         fr(4) = degf2
       else
         fr(1) = 1.0
         fr(2) = 1.0
         fr(3) = 1.0
         fr(4) = 0.0
       endif
       mmfl = .false.
       l3c(1) = l3b(1) + 99
       l3c(2) = 0
       l3c(6) = 1
       ibor = 0
       boron(iv) = 0.0
       call inp2 (fa(filndx(1)),init,l3c)
       if (l3c(6) .ge. 0) go to 43
   77  write (output,2022)
 2022  format ('0******** Volume conditons set to liquid water for conti
     &nued checking.')
       vctrl(iv) = ior(vctrl(iv),256)
       temp(iv) = tt
       quale(iv) = 0.0
       go to 90
   43  if (init(1).lt.0 .or. init(1).gt.10000) go to 144
       imat =  init(1)/100
       init(1) =  init(1) - 100*imat
       ibor=init(1)/10
       if (ibor .gt. 1) go to 144
       init(1) = init(1) - ibor*10
       if (init(1) .le. 6) go to 124
  144  init(1) = 0
       ibor = 0
       imat = 0
       write (output,2023)
 2023  format ('0******** Control for volume initial conditions incorrec
     &t, set to zero for continued checking.')
       fail = .true.
  124  vctrl(iv) = ior(vctrl(iv),ishft(init(1),8))
       volmat(iv) = imat
       i3 = init(1) + 1
       l3c(6) = l3c(6) - ibor
       if (i3 .gt. 1) go to 101
       if (l3c(6) .eq. 5) go to 131
       go to 88
  101  if (i3 .gt. 4) go to 102
       if (l3c(6) .eq. 3) go to 123
       go to 88
  102  if (i3 .gt. 6) go to 103
       if (l3c(6) .eq. 4) go to 76
       go to 88
  103  if (l3c(6) .eq. 6) go to 83
   88  write (output,2037) l3c(1)
 2037  format ('0******** Incorrect number of quantities on card',i8,'.'
     & )
       fail = .true.
       go to 77
   76  if (i3 .gt. 5) go to 82
         if (xinit(4).ge.0.0 .and. xinit(4).le.1.0) go to 84
           fail = .true.
           xinit(4) = 0.0
           write (output,2024)
 2201  format('0******** Non cond. quality in volume initial condition i
     &ncorrect, set to zero for continued checking.')
   84    p(iv) = xinit(2) * fr(1)
         temp(iv) = xinit(3) * fr(3) + fr(4)
         quale(iv) = xinit(4)
         go to 50
   82  if (xinit(4).ge.0.0 .and. xinit(4).le.1.0) go to 85
         fail = .true.
         xinit(4) = 0.0
         write (output,2201)
   85    if (xinit(3).ge.0.0 .and. xinit(3).le.1.0) go to 87
           fail = .true.
           xinit(3) = 0.0
           write (output,2024)
   87    temp(iv) = xinit(2) * fr(3) + fr(4)
         quale(iv) = xinit(3)
         quala(iv) = xinit(4)
         go to 50
   83  p(iv) = xinit(2) * fr(1)
       uf(iv) = xinit(3) * fr(2)
       ug(iv) = xinit(4) * fr(2)
       if (xinit(5).ge.0.0 .and. xinit(5).le.1.0) go to 181
         fail = .true.
         xinit(5) = 0.0
         write (output,2038)
  181  if (xinit(6).ge.0.0 .and. xinit(6).le.1.0) go to 183
         fail = .true.
         xinit(6) = 0.0
         write (output,2201)
  183  voidg(iv) = xinit(5)
       quala(iv) = xinit(6)
       go to 50
  131  p(iv) = xinit(2)*fr(1)
       uf(iv) = xinit(3)*fr(2)
       ug(iv) = xinit(4)*fr(2)
       if (xinit(5).ge.0.0 .and. xinit(5).le.1.0) go to 125
       xinit(5) = 0.0
       write (output,2038)
 2038  format ('0******** Gas void in volume initial condition incorrect
     &, set to zero for continued checking.')
 2024  format ('0******** Quality in volume initial condition incorrect,
     & set to zero for continued checking.')
       fail = .true.
  125  voidg(iv) = xinit(5)
       go to 50
  123  if (i3-3) 132,133,134
  132  temp(iv) = xinit(2)*fr(3) + fr(4)
       go to 127
  133  p(iv) = xinit(2)*fr(1)
  127  if (xinit(3).ge.0.0 .and. xinit(3).le.1.0) go to 128
       xinit(3) = 0.0
       write (output,2024)
       fail = .true.
  128  quale(iv) = xinit(3)
       go to 50
  134  p(iv) = xinit(2)*fr(1)
       temp(iv) = xinit(3)*fr(3) + fr(4)
   50  if (ibor .eq. 0) go to 90
       if (xinit(l3c(6)+1) .ge. 0.0) go to 104
       xinit(l3c(6)+1) = 0.0
       write (output,2025)
 2025  format ('0******** Boron concentration is less than zero, set to
     &zero.')
  104  boron(iv) = xinit(l3c(6)+1)
c  Process junction input.
   90  if (nj .eq. 0) go to 259
       ijs = ij
       it = 0
       nt = 1
       l3b(1) = nc*10000 + 101
   39  l3d(1) = l3b(1) + nt*1000
       call inplnk (l3d(1),ix,n3,n4,fa(filndx(1)))
       if (n4 .ne. 0) go to 44
       if (ix .eq. -1) go to 53
       ix = (ix-l3b(1))/1000
       if (ix .ne. nt) go to 40
       write (output,2010) l3d(1)
 2010  format ('0******** Card',i8,' is missing, default junction data e
     &ntered.')
       jc(ij) = 128
       ij1(ij) = 0
       ij2(ij) = 0
       ajun(ij) = 0.0
       fjunf(ij) = 0.0
       fjunr(ij) = 0.0
       velfj(ij) = 0.0
       velgj(ij) = 0.0
$if def,mmfld,1
       velmj(ij) = 0.0
       junno(ij) = nc*1000000 + nt*10000
       go to 59
   40  nt = ix
       go to 66
   44  ihf = junno(ij)
       junno(ij) = nc*1000000 + nt*10000
       if (.not.cmpflg) go to 461
       if (junno(ij) .eq. ihf) go to 461
       write (output,2036)
 2036  format ('0******** Junction card numbers do not match existing ju
     &nctions as required with change flag option.')
       fail = .true.
       l3c(1) = nc*10000
       l3c(2) = l3c(1) + 9999
       ihf = inp10(fa(filndx(1)),l3c(1),l3c(2))
       go to 301
  461  fr(1) = 1.0
       if (.not.uniti) fr(1) = ft2
       l3d(6) = 1
       call inp2 (fa(filndx(1)),init,l3d)
       if (l3d(6) .gt. 0) go to 45
       write (output,2008)
 2008  format ('0******** Junction geometry set to default conditions fo
     &r continued checking.')
       if (cmpflg) go to 462
       ij1(ij) = 0
       ij2(ij) = 0
       ajun(ij) = 0.0
       fjunf(ij) = 0.0
       fjunr(ij) = 0.0
  462  fail = .true.
       go to 55
   45  if (cmpflg) go to 52
       tfail = .false.
       if (init(1) .le. 0) then
         init(1) = 0
         tfail = .true.
       endif
       if (init(2) .le. 0) then
         init(2) = 0
         tfail = .true.
       endif
       if (tfail) then
         write (output,2006)
 2006  format ('0******** Volume pointers less than or equal to 0, set t
     &o 0 for further checking.')
         fail = .true.
       endif
       ij1(ij) = init(1)
       jcn(1) = init(1)/1000000
       ij2(ij) = init(2)
       jcn(2) = init(2)/1000000
       if (jcn(1).ne.nc .and. jcn(2).ne.nc) then
         write (output,2032)
 2032  format ('0******** Junction connections do not involve component
     &volumes.')
         fail = .true.
       elseif (jcn(1) .eq. jcn(2)) then
         write (output,2040)
 2040  format ('0******** Junction connections involve the same componen
     &t')
         fail = .true.
       elseif (nt .le. 1) then
         if (jcn(2) .ne. nc) then
           write (output,2041)
 2041  format ('0******** To connection for first junction is not the x
     &coordinate of the component volume.')
           fail = .true.
         endif
         ief = init(2) - (init(2)/10)*10
         if (ief .eq. 0) then
           tfail = init(2) - nc*1000000 .ne. 0
         else
           tfail = init(2) .ne. nc*1000000 + 10001
         endif
         if (tfail) then
           write (output,2042)
 2042  format ('0******** First junction is not connected to the inlet s
     &ide of the x coordinate of the component volume.')
           fail = .true.
         endif
       endif
       if (xinit(3) .lt. 0.0) then
         write (output,2014)
 2014  format ('0******** Junction area less than 0.0, set to 0.0 for co
     &ntinued checking.')
         xinit(3) = 0.0
         fail = .true.
       endif
       ajun(ij) = xinit(3)*fr(1)
       diamj(ij) = 2.0*sqrt(ajun(ij)/pi)
       tfail = .false.
       if (xinit(4) .lt. 0.0) then
         xinit(4) = 0.0
         tfail = .true.
       endif
       if (xinit(5) .lt. 0.0) then
         xinit(5) = 0.0
         tfail = .true.
       endif
       fjunf(ij) = xinit(4)
       fjunr(ij) = xinit(5)
       if (tfail) then
         write (output,2004)
 2004  format ('0******** Form loss coefficients less than 0.0, set to 0
     &.0 for continued checking.')
         fail = .true.
       endif
   52  tfail = .false.
       if (init(6) .lt. 0) then
         init(6) = -init(6)
         tfail = .true.
       endif
       ief = init(6)/1000000
       init(6) = init(6) - 1000000*ief
       icc = init(6)/100000
       init(6) = init(6) - 100000*icc
       ist = init(6)/10000
       init(6) = init(6)-10000*ist
       ick = init(6)/1000
       init(6) = init(6) - 1000*ick
       irf = init(6)/100
       init(6) = init(6) - 100*irf
       ihf = init(6)/10
       isf = init(6) - ihf*10
       if (ief .gt. 0) then
         ief = 0
         tfail = .true.
       endif
       if (icc .ne. 0) then
         icc = 0
         tfail = .true.
       endif
       if (ist .ne. 0) then
         ist = 0
         tfail = .true.
       endif
       if (ick .ne. 1) then
         if (ick .eq. 0) then
           if( iand(ihlppr(2),ishft(1,22)).ne.0 )
     &     write (output,2051)
 2051  format ('0$$$$$$$$ Is this the first stage group in the turbine?
     &If not the choking option should not be used.')
         endif
         if (ick .ne. 0) then
           ick = 1
           tfail = .true.
         endif
       endif
       if (irf .ge. 2) then
         irf = 0
         tfail = .true.
       endif
       if (ihf .gt. 2) then
         ihf = 0
         tfail = .true.
       endif
       if (ihf .eq. 2) ihf = 1
       if (nt .eq. 1) then
         if (ihf .ne. 1) then
           ihf = 1
           tfail = .true.
         endif
       endif
       if (isf .gt. 3) then
         isf = 0
         tfail = .true.
       endif
       jc(ij) = ior(ior(ior(ior(ior(jc(ij),ishft(irf,8)),
     & ishft(ihf,9)),ishft(isf,12)),ishft(ick,4)),ishft(ist,17))
       jcex(ij) = ior(ior(jcex(ij),ishft(icc,2)),ishft(ief,15))
       if (.not.tfail) go to 245
       write (output,2020)
 2020  format ('0******** Junction controls incorrect, reset flags for c
     &ontinued checking.')
       fail = .true.
  245  if (nt .eq. 2) jc(ij) = ior(jc(ij),ishft(1,29))
c  Process additional form loss card.
  55   fjunfb(ij) = 0.0
       fjunfc(ij) = 0.0
       fjunrb(ij) = 0.0
       fjunrc(ij) = 0.0
       l3h(1) = l3d(1) + 11
       l3h(6) = 1
       call inp2 (fa(filndx(1)),init,l3h)
       if (l3h(6) .lt. 0) then
         write (output,4168)
 4168  format ('0******** Junction input form loss data set to default f
     &or continued checking.')
         fail = .true.
       elseif (l3h(6) .ne. 0) then
         if (l3h(6) .ne. 4) then
           write (output,4122)
 4122  format ('0******** Junction input form loss data card contains le
     &ss than 4 words, input set to default.')
           fail = .true.
         else
           if (xinit(1) .lt. 0.0) then
             write (output,4123)
 4123  format ('0******** Forward form loss coefficient less than 0.0, s
     &et to 0.0 for continued checking.')
             xinit(1) = 0.0
             fail = .true.
           endif
           fjunfb(ij) = xinit(1)
           if (xinit(2) .lt. 0.0) then
             write (output,4124)
 4124  format ('0******** Forward form loss exponent less than 0.0, s
     &et to 0.0 for continued checking.')
             xinit(2) = 0.0
             fail = .true.
           endif
           fjunfc(ij) = xinit(2)
           if (xinit(3) .lt. 0.0) then
             write (output,4125)
 4125  format ('0******** Reverse form loss coefficient less than 0.0, s
     &et to 0.0 for continued checking.')
             xinit(3) = 0.0
             fail = .true.
           endif
           fjunrb(ij) = xinit(3)
           if (xinit(4) .lt. 0.0) then
             write (output,4126)
 4126  format ('0******** Reverse form loss exponent less than 0.0, s
     &et to 0.0 for continued checking.')
             xinit(4) = 0.0
             fail = .true.
           endif
           fjunrc(ij) = xinit(4)
         endif
       endif
c  Process junction initial conditions.
       if (cmpflg) go to 59
       l3e(1) = l3d(1) + 100
       l3e(6) = 1
       call inp2 (fa(filndx(1)),init,l3e)
       if (l3e(6) .gt. 0) go to 57
       write (output,2018)
 2018  format ('0******** Junction initial velocities set to 0.0 for con
     &tinued checking.')
       velfj(ij) = 0.0
       velgj(ij) = 0.0
$if def,mmfld,1
       velmj(ij) = 0.0
       fail = .true.
       go to 59
   57  fr(1) = 1.0
       fr(2) = 1.0
       if (ixp .ne. 0) go to 58
       if (.not.uniti) fr(1) = ft
       velfj(ij) = xinit(1)*fr(1)
       velgj(ij) = xinit(2)*fr(1)
$if def,mmfld,1
       velmj(ij) = 0.0
       go to 59
   58  if (.not.uniti) fr(1) = xlbsec
       velfj(ij) = xinit(1)*fr(1)
       velgj(ij) = xinit(2)*fr(1)
$if def,mmfld,1
       velmj(ij) = 0.0
   59  ij = ij + ijskp
       it = it + 1
       if (it .eq. nj) go to 301
       nt = nt + 1
   66  if (nt .lt. 10) go to 39
   53  write (output,2019) l3a(1)
 2019  format ('0******** Number of junction entered is not consistent w
     &ith number on card',i8,', defaults being entered.')
       ink = 1
       do i = ij,ije,ijskp
         jc(i) = 128
         ij1(i) = 0
         ij2(i) = 0
         ajun(i) = 0.0
         fjunf(i) = 0.0
         fjunr(i) = 0.0
         fjunfb(i) = 0.0
         fjunfc(i) = 0.0
         fjunrb(i) = 0.0
         fjunrc(i) = 0.0
         velfj(i) = 0.0
         velgj(i) = 0.0
$if def,mmfld,1
         velmj(i) = 0.0
         junno(i) = nc*1000000 + nt*10000
         cmphld(nc)%junp(ink)%junno = junno(i)
         nt = nt + 1
         ink = ink + 1
       enddo
       fail = .true.
  301  ij = ijs
c  Process turbine stage input.
  259  turctr(n) = 0
       turctr(n+1) = 0
       l3f(1) = nc*10000 + 300
       l3f(6) = 1
       call inp2 (fa(filndx(1)),init,l3f)
       if (l3f(6) .gt. 0) go to 78
       write (output,2210)
 2210  format('0******** Turbine stage parameters set to default values
     &for continued checking.')
       turvel(n) = 0.100472
       turint(n) = 2.0
       turfr(n) = 0.0
       turscm(n) = 0
       turctr(n) = 0
       turctr(n+1) = 0
       init(6) = 0
       fail = .true.
       go to 97
   78  turvel(n) = xinit(1)
       if (xinit(2) .ge. 0.0) go to 80
       xinit(2) = 2.0
       write (output,2212)
 2212  format ('0******** Turbine monent of inertia negative, set to def
     &ault value for continued checking.')
       fail = .true.
   80  turint(n) = xinit(2)
       if (xinit(3) .ge. 0.0) go to 81
       xinit(3) = 0.0
       write (output,2213)
 2213  format ('0******** Turbine friction factor less than zero, set to
     & zero for continued checking.')
       fail = .true.
   81  turfr(n) = xinit(3)
       if (init(4).gt.0 .and. init(4).lt.10000) go to 91
       init(4) = 0
       write (output,2218)
 2218  format ('0******** Shaft component reference is incorrect, set to
     & zero for continued checking.')
       fail = .true.
   91  turscm(n) = init(4)
       if (init(5).ge.0 .and. init(5).le.2000) go to 92
       init(5) = 0
       write (output,2219)
 2219  format ('********* Turbine disconnect trip incorrect, set to zero
     & for continued checking.')
       fail = .true.
   92  turctr(n) = init(5)
   97  if (l3f(6) .eq. 5) init(6) = 0
       if (init(6).eq.0 .or. init(6).eq.1) go to 93
       init(6) = 0
       write (output,2220)
 2220  format ('0******** Turbine drain flag incorrect, set to zero for
     &continued checking.')
   93  cmpopt(n) = ior(cmpopt(n),4*init(6))
       if (nj.ne.1 .or. init(6).eq.0) go to 98
       write (output,2221)
 2221  format ('0******** Turbine drain flag cannot be 1 when only one j
     &unction is entered.')
       fail = .true.
   98  if (uniti) go to 95
       turvel(n) = turvel(n)*crpm
       turint(n) = turint(n)*cinrt
       turfr(n) = turfr(n)*ctorq/crpm
c  Process turbine performance data.
   95  l3g(1) = nc*10000 + 400
       l3g(6) = 1
       call inp2 (fa(filndx(1)),init,l3g)
       if (l3g(6) .gt. 0) go to 110
       write (output,2410)
 2410  format('0******** Turbine efficiency parameters set to default v
     &alues for continued checking.')
       cmpopt(n) = ior(cmpopt(n),8)
       turdef(n) = 0.85
       tureff(n) = turdef(n)
       turpow(n) = 0.0
       turtrq(n) = 0.0
       turx(n) = 0.50
       turrds(n) = 1.00
       fail = .true.
       go to 116
  110  if (init(1).eq.0 .or. init(1).eq.1 .or. init(1).eq.2) go to 111
       init(1) = 1
       write (output,2412)
 2412  format ('0******** Turbine type invalid set to default value of 1
     & for continued checking.')
  111  cmpopt(n) = ior(cmpopt(n),8*init(1))
       if (xinit(2).lt.0.0  .or.  xinit(2).gt.1.0) then
         xinit(2) = 0.85
         write (output,2413)
 2413  format ('0******** Turbine design efficicncy outside physical ran
     &ge, reset for continued checking.')
         fail = .true.
       endif
       turdef(n) = xinit(2)
       tureff(n) = turdef(n)
       turpow(n) = 0.0
       turtrq(n) = 0.0
       if (xinit(3).lt.0.0 .or. xinit(3).gt.1.0) then
         xinit(3) = 0.5
         write (output,2418)
 2418  format ('0******** Stage reaction fraction is incorrect, set to 0
     &.5 for continued checking.')
         fail = .true.
       endif
       turx(n) = xinit(3)
       if (l3g(6) .eq. 3) xinit(4) = 0.0
       if (xinit(4) .lt. 0.0 ) then
         xinit(4) = 1.00
         write (output,2419)
 2419  format ('0******** Mean stage radius is incorrect, set to 1.0 for
     &continued checking.')
         fail = .true.
       endif
       turrds(n) = xinit(4)
  116  if (.not.uniti) turrds(n) = turrds(n)*ft
c  Edit component input.
       l3c(1) = nc*1000000 + 10000
       l3c(2) = l3c(1)
       if (iand(ihlppr(2),ishft(1,22)).ne.0) then
         write (output,2105)
 2105  format ('0  Vol no.',4x,'volume',8x,'angle 1',7x,'angle 2',7x,
     & 'angle 3',6x,'vol-flag')
         if (.not.unito) then
           write (output,2106)
 2106  format (14x,'(ft3)',9x,3('(deg)',9x),'tlpvb_e')
         else
           write (output,2107)
 2107  format (14x,'(m3)',10x,3('(deg)',9x),'tlpvb_e')
         endif
       endif
       k = iv
       volno(k) = l3c(2)
       cmphld(nc)%volp(1)%volno = l3c(2)
       iscr(11) = 1000000*iand(ishft(vctrl(k),-2),1) +
     & 100000*iand(ishft(imap(k),-28),1) +
     & 10000*iand(ishft(vctrl(k),-7),1) +
     & 1000*iand(ishft(imap(k),-9),1) +
     & 100*iand(ishft(vctrl(k),-30),1) +
     & 200*iand(ishft(imap(k),-27),1) +
     & iand(ishft(vctrl(k),-1),1)
       rhog(k) = 0.0
       if (unito) then
         if (iand(ihlppr(2),ishft(1,22)).ne.0)
     &   write (output,2102) l3c(2),v(k),rhof(k),rho(k),rhog(k),
     &   iscr(11)
 2102  format (i10.9,1p,4g14.4,i11.7)
       else
         xcr(1) = v(k)/ft3
         if (iand(ihlppr(2),ishft(1,22)).ne.0)
     &   write (output,2102) l3c(2),xcr(1),rhof(k),rho(k),rhog(k),
     &   iscr(11)
       endif
       l3c(2) = l3c(2) + 10000
       if (iand(ihlppr(2),ishft(1,22)).ne.0) then
         write (output,2115)
 2115  format ('0  Vol no. coord.    flow area',5x,'flow length',3x,
     & 'sp.x. chng.',3x,'sp.y. chng.',3x,'sp.z. chng.',3x,'roughness',
     & 5x,'hydrlc.diam.',2x,'xyz-flag')
         if (.not.unito) then
           write (output,2116)
 2116  format (21x,'(ft2)',9x,'(ft)',5(10x,'(ft)'),11x,'_____f_')
         else
           write (output,2117)
 2117  format (21x,'(m2)',10x,'(m)',5(11x,'(m)'),12x,'_____f_')
         endif
         l3c(2) = l3c(1)
         k = iv
         do 280 id = 1,3
           ist = 10*iand(ishft(imap(k+id-1),-13),1) +
     &     20*iand(ishft(imap(k+id-1),-26),1)
           xcr(3) = hydxc(k+2*id-2) + hydxc(k+2*id-1)
           xcr(4) = hydxc(k+2*id+4) + hydxc(k+2*id+5)
           xcr(5) = hydxc(k+2*id+10) + hydxc(k+2*id+11)
           if (unito) then
             write (output,2108) volno(k),lcord(id),avol(k+id-1),
     &       dl(k+id-1),xcr(3),xcr(4),xcr(5),roughv(k+id-1),
     &       diamv(k+id-1),ist
 2108  format (i10.9,6x,a1,1p,7g14.4,i12.7)
           else
             xcr(1) = avol(k+id-1)/ft2
             xcr(2) = dl(k+id-1)/ft
             xcr(3) = xcr(3)/ft
             xcr(4) = xcr(4)/ft
             xcr(5) = xcr(5)/ft
             xcr(6) = roughv(k+id-1)/ft
             xcr(7) = diamv(k+id-1)/ft
             write (output,2108) volno(k),lcord(id),
     &       (xcr(irf),irf=1,7),ist
           endif
  280    continue
         do 169 k = 1,11
           xcr(k) = 0.0
  169    continue
         i1 = 1
         k = iv
         init(1) = iand(ishft(vctrl(k),-8),2047)
         ibor = init(1)/10
         i2 = init(1) - 10*ibor + 1
         imat = volmat(k)
         iscr(i1+9) = init(1) + 100*imat
         if (.not.unito) go to 165
$if -def,mmfld,1
         go to (271,272,273,274,275,276,277), i2
$if def,mmfld,1
         go to (271,272,273,274,275,276,277,277), i2
         call fabend
  271    xcr(i1+2) = p(k)
         xcr(i1+3) = uf(k)
         xcr(i1+4) = ug(k)
         xcr(i1+5) = voidg(k)
         go to 166
  272    xcr(i1+2) = temp(k)
         go to 281
  273    xcr(i1+2) = p(k)
  281    xcr(i1+3) = quale(k)
         go to 166
  274    xcr(i1+2) = p(k)
         xcr(i1+3) = temp(k)
         go to 166
  275    xcr(i1+2) = p(k)
         xcr(i1+3) = temp(k)
         xcr(i1+4) = quale(k)
         go to 166
  276    xcr(i1+2) = temp(k)
         xcr(i1+3) = quale(k)
         xcr(i1+4) = quala(k)
         go to 166
  277    xcr(i1+2) = p(k)
         xcr(i1+3) = uf(k)
         xcr(i1+4) = ug(k)
         xcr(i1+5) = voidg(k)
         xcr(i1+6) = quala(k)
$if def,mmfld,3
         if (.not.mmfl) go to 166
         xcr(i1+7) = um(k)
         xcr(i1+8) = voidm(k)
         go to 166
  165    xcr(i1) = roughv(k)/ft
         xcr(i1+1) = diamv(k)/ft
$if -def,mmfld,1
         go to (171,172,173,174,190,185,186), i2
$if def,mmfld,1
         go to (171,172,173,174,190,185,186,186), i2
         call fabend
  171    xcr(i1+2) = p(k)/psia
         xcr(i1+3) = uf(k)/eng
         xcr(i1+4) = ug(k)/eng
         xcr(i1+5) = voidg(k)
         go to 166
  172    xcr(i1+2) = (temp(k)-degf2)/degf1
         go to 176
  173    xcr(i1+2) = p(k)/psia
  176    xcr(i1+3) = quale(k)
         go to 166
  174    xcr(i1+2) = p(k)/psia
         xcr(i1+3) = (temp(k)-degf2)/degf1
         go to 166
  190    xcr(i1+2) = p(k)/psia
         xcr(i1+3) = (temp(k)-degf2)/degf1
         xcr(i1+4) = quale(k)
         go to 166
  185    xcr(i1+2) = (temp(k) - degf2)/degf1
         xcr(i1+3) = quale(k)
         xcr(i1+4) = quala(k)
         go to 166
  186    xcr(i1+2) = p(k)/psia
         xcr(i1+3) = uf(k)/eng
         xcr(i1+4) = ug(k)/eng
         xcr(i1+5) = voidg(k)
         xcr(i1+6) = quala(k)
$if def,mmfld,4
         if (mmfl) then
           xcr(i1+7) = um(k)/eng
           xcr(i1+8) = voidm(k)
         endif
  166    i1 = i1 + 11
         l3c(2) = l3c(1)
         write (output,2121)
 2121  format ('0  Vol no.',3x,'i.c.',4x,'i.c.value 1',3x,'i.c.value 2',
     & 3x,'i.c.value 3',3x,'i.c.value 4',3x,'i.c.value 5',3x,
     & 'i.c.value 6',3x,'i.c.value 7', 3x,'boron conc.'/13x,'flag')
         i1 = 1
         l3c(2) = l3c(1)
         k = iv
         write (output,2119) l3c(2),iscr(i1+9),(xcr(i1+kk),kk=2,8),
     &   boron(k)
 2119  format (i10.9,i7,1p,8g14.4)
         l3c(2) = l3c(2) + 1000
         i1 = i1 + 11
         if (nj .ne. 0) then
           write (output,2111)
 2111  format ('0  Jun.no. from vol.   to vol.',5x,'junction area',
     & 7x,'jun-flag')
           if (.not.unito) then
             write (output,2112)
 2112  format (35x,'(ft2)',15x,'efvcahs')
           else
             write (output,2113)
 2113  format (35x,'(m2)',16x,'efvcahs')
           endif
           do 350 i = ijs,ije,ijskp
             ihf =
     &       1000000*iand(ishft(jcex(i),-15),1) +
     &       100000*iand(ishft(jcex(i),-2),1) +
     &       10000*iand(ishft(jc(i),-17),3) +
     &       1000*iand(ishft(jc(i),-4),1) +
     &       100*iand(ishft(jc(i),-8),1) +
     &       10*iand(ishft(jc(i),-9),1) +
     &       iand(ishft(jc(i),-12),3)
             if (.not.unito) then
               xinit(2) = ajun(i)/ft2
               write (output,2026) junno(i),ij1(i),ij2(i),xinit(2),ihf
             else
               write (output,2026) junno(i),ij1(i),ij2(i),ajun(i),ihf
 2026  format (3i10.9,1p,g17.6,i15.7)
             endif
  350      continue
           write (output,4121)
 4121  format ('0  Jun.no.',5x,'forward loss ',3x,'forward loss',4x,'for
     &ward loss',4x,'reverse loss ',3x,'reverse loss',4x,'reverse loss')
           write (output,4127)
 4127  format (15x,'coefficient  ',3x,'multiplier  ',4x,'exponent
     & ','coefficient  ',3x,'multiplier  ',4x,'exponent ')
           do 4352 i = ijs,ije,ijskp
             write (output,4128) junno(i),fjunf(i),fjunfb(i),fjunfc(i),
     &       fjunr(i),fjunrb(i),fjunrc(i)
 4352      continue
 4128  format(i10,1x,1p,6e16.6)
           write (output,2114) labl1(ixp+1),labl1(ixp+1)
 2114  format ('0  Jun.no.',25x,'init. liq.',a5,2x,'init. vap.',a5)
           if (.not.unito) then
             write (output,2915) labl2(ixp+1),labl2(ixp+1)
 2915  format (35x,a10,7x,a10)
             do 355 i = ijs,ije,ijskp
               if (ixp .eq. 0) then
                 xinit(2) = velfj(i)/ft
                 xinit(3) = velgj(i)/ft
               else
                 xinit(2) = velfj(i)/xlbsec
                 xinit(3) = velgj(i)/xlbsec
               endif
               write (output,2028) junno(i),(xinit(ihf),ihf=2,3)
  355        continue
           else
             write (output,2916) labl3(ixp+1),labl3(ixp+1)
 2916  format (35x,a10,7x,a10)
             write (output,2028) (junno(i),velfj(i),velgj(i),
     &       i=ijs,ije,ijskp)
 2028  format (i10.9,20x,1p,2g17.6)
           endif
           init(5) = turctr(n)
           init(6) = iand(ishft(cmpopt(n),-2),1)
           if (unito) then
             write (output,2216) turvel(n),turint(n),turfr(n),
     &       turscm(n),init(5),init(6)
 2216  format ('0  Turbine rot.     moment  of',7x,'friction',9x,
     & 'shaft',6x,'disconnect  drain flag'/
     & '   velocity',9x,'inertia',10x,'factor',11x,'component   trip'/
     & '   (rad/sec)',8x,'(kg-m2)',10x,'(n-m-sec)'/1p,3g17.6,3i12)
           else
             xinit(1) = turvel(n)/crpm
             xinit(2) = turint(n)/cinrt
             xinit(3) = turfr(n)/ctorq*crpm
             write (output,2215) xinit(1),xinit(2),xinit(3),
     &       turscm(n),init(5),init(6)
 2215  format ('0  Turbine rot.     moment  of',7x,'friction',13x,
     & 'shaft',2x,'disconnect  drain flag'/
     & '   velocity',9x,'inertia',10x,'factor',11x,'component   trip'/
     & '   (rev/min)',8x,'(lb-ft2)',9x,'(lbf-ft-min)'/1p,3g17.6,3i12)
           endif
           init(1) = ishft(cmpopt(n),-3)
           if (unito) then
             write (output,2416) init(1),turdef(n),turx(n),turrds(n)
 2416  format ('0  Turbine type     efficiency',7x,'reaction',9x,
     & 'radius'/ 54x,'(m)'/ i15,1p,3g17.6)
           else
             xinit(4) = turrds(n)/ft
             write (output,2415) init(1),turdef(n),turx(n),xinit(4)
 2415  format ('0  Turbine type     efficiency',7x,'reaction',9x,
     & 'radius'/ 54x,'(ft)'/ i15,1p,3g17.6)
           endif
         endif
       endif
       return
       end
