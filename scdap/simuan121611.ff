*mlist
*if def,selap
       subroutine simuan
c
c  Drives the SCDAP simulator rod analysis.
c
c  Cognizant engineer: ewc.
c calling subroutines:  sbntac
c subroutines called:  ctime , cfdata, oxidiz, liqsol, brchsw,
c                      mxarea, clddfm, freloc, shufl , fgrelh,
c                      fgrelg, fpress, fstate, nheat , rlockf,
c                      meshgn, heatcn, trate , mxctmp,
c                      grid  , cfdamg, cfaver, cfout , fragmt
c
       use scdmod
       implicit none
       include 'cpmdat.h'
       include 'comctl.h'
       include 'contrl.h'
       include 'fast.h'
       include 'scddat.h'
       include 'buntim.h'
       include 'farays.h'
       include 'voldat.h'
       include 'statec.h'
       include 'cons.h'
       include 'solcom.h'
       include 'nbtim.h'
       include 'cmptim.h'
       include 'iocom.h'
       include 'trnot1.h'
       include 'miscon.h'
       include 'cmatp.h'
       include 'fpnonv.h'
       include 'fpfast.h'
       include 'ptscom.h'
       include 'dbacct.h'
       include 'eht0.h'
       include 'effprp.h'
       include 'plndat.h'
       include 'tblsp.h'
       include 'balfar.h'
       include 'debout.h'
       include 'fgrcom.h'
       include 'grscgr.h'
       include 'intcom.h'
       include 'ndxara.h'
       include 'nhtara.h'
       include 'fpdkht.h'
       include 'scdads.h'
       include 'scdcom.h'
       include 'scdout.h'
       include 'trnot2.h'
       include 'ufiles.h'
       include 'slumpv.h'
       include 'scntl.h'
       include 'oxairv.h'
c  Local variables.
      dimension avir(ndrd,ndax)
      integer i,i34,iareax,ierr,ir,isp,ispo,itrflg,iwarn,izrt,jiter,
     # k,kfail,kki,kx,mdyn,mltswz,nelm,nsn,nswqch,nuflg,nvolin,
     # nzrflg
      integer ig,nshap
      real a,afracl,avir,avoidl,azira,b,c,dtemp, dzfrq0,effcp,effcpc,
     # effgen,effk,effkc,effkf,epsz,estimd, fnsigl,gasms,
     # haddbt,hremov,oxdhc, oxdhf,oxdwz,pcool0,pgas0,
     # qfrell,qin, rcox,rfrces,rlcnda,roliq,slglen,snrelr,
     # snrem,taca, tcik,tcld,tdis,tfgrj,tfpivr,tfpivy,tgou,
     # tgsg,timdbf,tprf,tsat,tsav,tsur,tzr,
     # voidfr,vtvod,vzira,wmltzo,wuo2,wuotot,wx,wz, wzr,xdeltz,ztop
      real tzr2
      real tmpfmx,timnw1,timnw2,tsolgd,tgrdlq
      integer itmpmx,kmnpol
      real gasmol,rfix
      real acond1,radus1,qcldtt
      real vrodhp,ruo2,rzr,wurod,wzrod,wuo1,wuo22,wzr1,wzr2,
     # wzro1,wzro2,wag1,wag2,wss1,wss2,wsso1,wsso2,wzruo1,wzruo2, afru1,
     # afru2,afrz1,afrz2,wbc1,wbc2,tmpold,tmpnew,tmpblk, dvsum,tmpsum,
     # dvrod,vrsthp,wuslg,wzslg,ceffzr, ceffuo,ceff,oxlis0,
     # wmxdif,qdkns,qtotox,wmxwtg,area1,hgcoh1
      real apel0,volcs1,dencrs
      real ndrp1,ndrp2,ndrp3,wzrdp1,wzrdp2,wuodp1,wuodp2,adiss
      dimension apel0(ndax)
      integer j,mz,m2,n,nn4,nn5,nn6,nn15,nn16
      dimension effcp(ndrd,ndax),effcpc(ndax),effgen(ndrd,ndax),
     # effkc(ndax),roliq(ndax),hremov(ndax),oxdhc(ndax),
     # oxdhf(ndax),slglen(ndax),tzr(ndax),tzr2(ndax),
     # voidfr(ndax),oxdwz(ndax),dtemp(ndax),effk(ndrd,ndax),
     # afracl(ndax),avoidl(ndax),mltswz(ndax),qin(ndax),tsur(ndax),
     # xdeltz(ndax),wmltzo(ndax),rlcnda(ndax), effkf(ndax), wuo2(ndax),
     # wzr(ndax), vtvod(ndax)
      integer igslmp
      real afracu,afracz,afraco
      external pliq,atomfr
      real pliq
      dimension tfpivr(5,ndax),tfgrj(5,ndax),tfpivy(ndax,5), rcox(ndax),
     # taca(ndax), tprf(ndax), tgsg(5,ndax),tgou(6,ndax),
     # tdis(16,ndax),tsav(4,ndax),tcik(16,ndax)
      real co,uo,do
      integer m,l,nnn,nsw,ivol,in,iln
      integer indmts
      integer kmid1,mm
      integer ndbg
c
      real wcldrp
      real poxndt
      real fden,cden,coxwtk,zuden
      real arga,argb,argc,rotest,rntest,oxtest
      external gasmol,fden,cden,oxydef,coxwtk,mixtmp,zuden
      external brchsw,cfdamg,cfdata,cfout,clddfm,ctime,effht,efprop,
     +fpress,fpspix,fstate,gridsc,heatc2,heatdb,hprop, liqsol,
     +meshgn,mxarea,mxctmp,nheat,oxidiz,pmass,rfrzn, rlockf,rubtrn,
     +shufl,tinr,trate,tspowr
      data uo/1.827834e5/, co/10310.75/, do/0.52257/
c
      rfix(a,b,c) = sqrt(a*a - b*b + c*c)
c
      ndbg=0
cljs    if(timehy.ge.12499.0.and.timehy.le.12500.0)ndbg=3
          if(ndbg.eq.3)then
          write(output,9005)timehy,icomp,gaman(3860)
9005      format(' SIMUAN entered; timehy=',e12.6,
     &    ' icomp=',i5,' gaman(3860)=',e10.4)
          end if
      j = icomp
      mz = ndax*(icomp - 1) + 1
      m2 = ndax*2*(icomp - 1) + 1
      n = ndrd*ndax*(icomp - 1) + 1
      nn4 = 4*ndax* (icomp - 1) + 1
      nn5=5*ndax*(icomp-1)+1
      nn6 =  6*ndax*(icomp - 1) + 1
      nn15=15*ndax*(icomp-1)+1
      nn16=16*ndax*(icomp-1)+1
c set indicator of grid spacer slumping during time step to zero.
      igslmp=2
      naxpz(j) = naz
c override fragmentation due to quench until debris models are in
      do 10 i = 1,naz
         ifrag(i+mz-1) = 0
         oxdwz(i)=0.0
c Initialize term that stores heat conducted from drops to fuel rod.
         qcdrps(i,icomp)=0.0
cljs add next line to initialize qcdrgs(i,icomp) to zero every
cljs time step; otherwise spurious temperature excursion
         qcdrgs(i,icomp)=0.0
         qgrdox(i,icomp)=0.0
         qoxcht(i,icomp)=0.0
         qoxchb(i,icomp)=0.0
         qdrops(i,icomp)=0.0
         qdebox(i,icomp)=0.0
         qdboxm(i,icomp)=0.0
         qcohst(i,icomp)=0.0
         hgcohs(i,icomp)=0.0
         hgdeb(i,icomp)=0.0
c Initialize hydrogen production rate due to oxidation of drops.
         hgdrps(i,icomp)=0.0
         afuel(i+mz-1)=pi*rpel(i+mz-1)**2
c       if(tcond3(nrodes(mz-1+i),i,j).gt.1250.0)erupt=0.02
c    define start of time step temperatures.
         do12l=1,nrodes(mz-1+i)
         tcnd03(l,i,j)=tcond3(l,i,j)
12       continue
   10 continue
      do20i=1,naz
         wuotot=wfrouo(mz+i-1)+wuobng(mz+i-1)-wuorem(mz+i-1) -
     #     wremuo(mz+i-1)
c ifrag=3=void region.
         if(wuotot.lt.0.01)ifrag(mz+i-1)=3
   20 continue
      idsrup(j) = 0
c set fuelrod component id for *heatcn*
c set the radial melt fraction required to cause the fuel column
c to buckle
      rfrces = 0.1
c this initialization of past time step coolant pressure must be
c moved to the dbundl subroutine
      pcool0 = pcool
c estimd and curtim will be dummies until disruption routines
c are inserted.  timec in current component time and timdbf is
      estimd = 0.0
      timdbf = timdb + deltdb
      timec = timdb
c determine the movement of fuel in the intact rod if debris
c regions have been formed
      if  ( ntotrg .gt. 1 )  then
         itrflg = 0
         call shufl (dzcond(mz),dzfrac(m2),dzfrac(m2+ndax),fgrj(1,j),
     +   fpivrt(1,j), fpivy(1,j),movesw(mz),naz,ndisrp(mz),tfgrj,
     +   tfpivr, tfpivy, zcond(mz),ci(nn15),acae(mz),prf(mz),gsg(nn5),
     +   gou(nn6),dis(nn16),sv(nn4),taca,tprf,tgsg,tgou,tdis,tsav,tcik,
     +   itrflg )
         do 30 i = 1,naz
            movesw(mz-1+i) = 0
   30    continue
      endif
      if((timdbf-timec).gt.0.0)then
       call cfdata
         do50k=1,naz
            avoidl(k)=pitch(j)**2-pi*rcos(j)**2
            if(avoidl(k).lt.1.e-8)avoidl(k)=1.e-8
            tsur(k)=tcond3(nrods2(k,icomp),k,icomp)
            tsur0(k)=tcnd03(nrods2(k,icomp),k,icomp)
            dtemp(k)=tsur(k)-tsur0(k)
   50    continue
         pgas0=pgas(naz)
c set izrt > 0 if maximum surface temperature less 600 k
c or greater the 2098 k or if balooning model is turned off.
         if(.not.scntrl(9))then
            call mxctmp(naz,tsur,izrt,pcool,pgas(j),rci(mz),rco(mz))
            if(izrt.eq.1)then
               itmpmx=1
               tmpfmx=0.0
               do60i=1,naz
                  if(tcond3(nrodes(mz-1+naz),i,j).gt.tmpfmx)then
                     tmpfmx=tcond3(nrodes(mz-1+naz),i,j)
                     itmpmx=i
                  end if
   60          continue
               if(tmpfmx.ge.1900.and.ibrch(j).eq.0)then
                  ii(j)=itmpmx
                  icladf(j)=1
               end if
            end if
            if (afuel(mz) .lt. 1.0e-07) izrt = 1
         else
            izrt = 1
         end if
c Get power for this Scdap component.
         call tspowr
         jiter = 1
c turn off oxidation at node in which debris blocks out coolant.
         do90i=1,naz
            if(irubpp(i,j).eq.1.or.nblkrd(i,j).eq.1.or.
     #         lcrucb(i,j).ge.1.or.dzfrcq(i,j).ge.0.99)then
               noxide(mz-1+i)=2
            end if
   90    continue
         call oxidiz(oxdeo(mz),alfao(mz),oxdwc(mz),oxdwc0,oxdhc,oxdhf,
     #     rnoxd(mz),rnalf(mz),nfrslg(mz),tzr,oxdwz,daxdis(1,j),
     #     noxide(mz))
         do 100 i = 1,naz
         oxdhcc(i,icomp) = oxdhc(i)
         oxdhfc(i,icomp) = oxdhf(i)
c save new outer cladding radius calculated by oxidiz
c in separate array for ref. pt. if ballooning occurs
            rcox(i) = rcoi(mz-1+i)
c put outer clad radius back if greater than crust radius
            rocrst(mz-1+i) = max(rocrst(mz-1+i),rco(mz-1+i))
c set metallic cladding thickness for liqsol, account for
c double sided oxidation:
            if((int(brchv(i,j)).ne.1) .and.
     #        (rnoxd(mz-1+i).gt.rci(mz-1+i)) ) then
               tzr2(i) = rnoxd(mz-1+i) - rci(mz-1+i)
            else if ((int(brchv(i,j)).eq.1) .and.
     #  (rnoxd(mz-1+i)**2 .gt.0.5*(rci(mz-1+i)**2+rco(mz-1+i)**2))) then
c 1.6555=ratio of density of zr to zro2.
               tzr2(i)=sqrt(1.6555*rnoxd(mz-1+i)**2-
     #          0.6555*rco(mz-1+i)**2) - rci(mz-1+i)
            else
               tzr2(i) = 0.0
            end if
  100    continue
         wdtqlp(icomp)=0.0
c Calculate time shift to inconel reaction caused by ZrO2
c insulation on fuel rods.
         do 110 i = 1,naz
            k = mz -  1+ i
c Check for possibility of oxide being so thick that it
c never gets dissolved.
            if(oxdeo(k) .gt. 1.0e-4) go to 110
c Skip over axial nodes that do not have inconel grid
c spacers and nodes where the grid spacer has slumped away
            if(igrdsp(i,j) .lt. 1.or.igrdsp(i,j).ge.3) go to 110
            if(igrinc(i,j) .eq. 0) go to 110
            timnw1 = timzo2(i,j) - dt
            if(tcond3(nrodes(k),i,j) .lt. 1273.0) go to 110
c Get liquidus temperature of inconel grid spacer (tgrdlq)
            call hprop(tsolgd, tgrdlq)
            if(tcond3(nrodes(k),i,j) .ge. tgrdlq) then
c Grid spacer melts during this time step
               timzo2(i,j) = timehy
               go to 110
            endif
            if((tcond3(nrodes(k),i,j).le.1423.0) .or.
     #         (oxdeo(k).le.3.0e-5)) then
               timnw2=3.759*((100.0*oxdeo(k)**2.1056)
     #           *exp(26595.5/tcond3(nrodes(k),i,j)))
            else
               timnw2 = 4.021e-6*((100.0*oxdeo(k)**1.3413) *exp(37142.5
     +         /tcond3(nrodes(k),i,j)))
            endif
            timnw2=timnw2+timehy
            timzo2(i,j) = min(timnw1,timnw2)
  110    continue
c Check for failure of fuel rod cladding due to interaction with
c inconel grid spacer.
         do 120 i = 1,naz
c Bypass check if cladding has already failed.
            if(igrdsp(i,j).lt.1.or.igrdsp(i,j).ge.3)go to 120
c Check if the grid spacer is zircaloy (0) or Inconel (1)
            if(igrinc(i,j).eq.0) then
               if(wremzr(mz-1+i).gt.1.e-10)then
                  igrdsp(i,j) = 2
               endif
            else
               if(timehy. ge. (timzo2(i,j) - dt)) then
                  igrdsp(i,j) = 2
               end if
            endif
  120    continue
         kmnpol=naz+1
         call liqsol(j,denuo2,dt,dzcond(mz),faxial,naz,pcool,pgas(j),
     #     pitch(j),qin,rci(mz),rl(j),rco(mz),rpel(mz),teff(mz),
     #     oxdeo(mz),tsur,tsur0,tzr2,zcond(mz),zgrid(1,j),nfrslg(mz),
     #     rocrmx(mz),rocrst(mz),volcrs(mz),wbotuo(j),wbotzr(j),
     #     wfrouo(mz),wfrozr(mz),wremuo(mz),hadd(mz),haddbt,hremov,
     #     kfail,mltswz,roliq,slglen,wuo2,wzr,fmix,nwet,avoidl,
     #     afracl,tmpfal,dzfrcl(mz),vladeb(mz),ndisrp(mz),oxdwf(mz),
     #     oxdwz,stozro(mz),timec,vfuel(m2),flwh2(mz),flstm(mz),
     #     burnup(mz),wuorem(mz),wremzo(mz),ruomlt(mz),wuomlt(mz),
     #     wmltzo,wbotox(j), dzfrac(m2),rfrces,igrdsp(1,j),wincl(1,j),
     #     thincl(1,j),winfro(1,j),winliq(1,j),wzrinc(1,j),wzrgfz(1,j),
     #     igrinc(1,j),dzrinf(1,j),dinzrf(1,j),daxdis(1,j),thkgpl(1,j),
     #     daxgrd(1,j),retabg(1,j),thetgr(1,j),drgrdm(1,j),dia1gr(1,j),
     #     dza1gr(1,j),oxdwc(mz),rnoxd(mz),rci(mz),rcoi(mz),ruliq(mz),
     #     winrem(1,j),wremzr(mz),nfi(mz),wuobng(mz),unuca(1,j),
     #     powadd(1,j),kmnpol,idcomp(j),kfail2(1,j))
         igslmp=2
         do130k=1,naz
            if(igrdsp(k,j).eq.3)igslmp=1
  130    continue
         do 150 k=1,naz
            kki=(icomp-1)*ndax+k
            dzfrq0=dzfrcq(k,j)
            dzfrcq(k,j)=dzfrcl(mz-1+k)
c set indicator to show that grid spacer slumping is completed
            if(igrdsp(k,j).eq.3)igrdsp(k,j)=4
            if(ibrch(j).eq.0)then
               if(igrdsp(k,j).eq.4.and.igrinc(k,j).eq.1)then
                  if(dzrinf(k,j).ge.(tzr2(k)-1.e-6))then
c Set fuel rod failure flags
                     ibrch(j) = 1
                     ii(j) = k
                     icladf(j) = 1
                     icladf(j) = 1
                     write(output,9010)timehy,k,scd1(icomp)%cmpno
 9010 format(' simuan  Cladding has failed due to interaction with',
     +' grid spacer',/,' event time =',g18.10, ' axial node =',
     +i4,' component number ='i4)
                  endif
               end if
            end if
c check to see whether grid spacer should be flagged as being
c melted away.
            if(igslmp.eq.1.and.igrdsp(k,j).eq.4)then
               if(ngrid.ge.1)then
                 do140ig=1,ngrid
                   if((zcond(kki)+0.5*dzcond(kki)).gt.zgrid(ig,j) .and.
     #               (zcond(kki)-0.5*dzcond(kki)).lt.zgrid(ig,j))then
                      write(output,9020)timehy,k,zgrid(ig,j),
     #                  scd1(icomp)%cmpno
 9020 format(' simuan  Grid spacer has slumped',/ ,
     +' event time =', g18.10,' axial node =',i4,
     +' elevation (m) =',e10.4, ' component number =',i3)
                        zgrid(ig,j)=-1.
                     end if
  140             continue
               end if
            end if
  150    continue
c Calculate temperature jump due to relocating material freezing
c in axial node.
         do200nnn=1,naz
            if(idrops(nnn,j).eq.1)go to 160
            go to 200
  160       continue
            indmts=1
            if(idrpgs(nnn,j).eq.2.and.idrgsz(nnn,j).eq.1)indmts=2
          if(idrops(nnn,j).eq.3.and.indmts.eq.1) write(output,9120)
 9120 format(' *** Blockage of relocating cladding by spacer grid ***')
c         if(idrops(nnn,j).eq.2.and.indmts.eq.1) write(output,9130)
c9130 format(' *** freezing of drops of relocating cladding ***')
c         if(indmts.eq.2) write(output,9132)
c9132 format(' *** freezing of drops of relocating spacer grid ***')
c Drops have frozen in node kdrops(nnn,j) or have impacted
c spacer grid in node kdrops(nnn,j).
          if(indmts.eq.1)then
          k=kdrops(nnn,j)
          else
          k=kdrpgs(nnn,j)
          end if
c Find composition and masses of each composition before
c drops solidified in node.
            kki=(j-1)*ndax+k
            vrodhp=pi*rpel(kki)**2
            vrsthp=pitch(j)**2-vrodhp
c calculate volume average fuel temperature
            dvsum=0.0
            tmpsum=0.0
            do170m=2,nrodes(kki)
               dvrod=pi*(xcond3(m,k,j)**2-xcond3(m-1,k,j)**2)
               dvsum=dvsum+dvrod
               tmpsum=tmpsum+dvrod*0.5*(tcond3(m,k,j)+tcond3(m-1,k,j))
  170       continue
            tmpold=tmpsum/dvsum
            ruo2 = fden (tmpold,0.0)
            rzr = cden (tmpold)
c wurod is the mass of UO2 in intact rod per unit length (kg/m)
c wzrod is the mass of Zr in intact rod per unit length (kg/m)
c wuslg is the mass of UO2 in space between fuel rods (kg/m)
c wzslg is the mass of Zr in space between fuel rods (kg/m)
            wurod = ruo2 * vrodhp
            wzrod = rzr * (rcos(j)** 2- rcii(j)**2) * pi
            wuslg=0.0
            wzslg=0.0
            wuo1=wurod*dzcond(kki)
            wzr1=wzrod*dzcond(kki)
c calculate volume average fuel temperature
            dvsum=0.0
            tmpsum=0.0
            do180m=2,nrodes(kki)
               dvrod=pi*(xcond3(m,k,j)**2-xcond3(m-1,k,j)**2)
               dvsum=dvsum+dvrod
               tmpsum=tmpsum+dvrod*0.5*(tcond3(m,k,j)+tcond3(m-1,k,j))
  180       continue
            tmpold=tmpsum/dvsum
          wzr2=0.0
          wuo22=0.0
          if(indmts.eq.1)then
          wzr2=wzrdrp(nnn,j)*ndrops(nnn,j)
          wuo22=wuodrp(nnn,j)*ndrops(nnn,j)
          tmpnew=tdrops(nnn,j)
          else
          wzr2=(wzgdrp(nnn,j)+windrp(nnn,j))*ndrpgs(nnn,j)
          tmpnew=tdrpgs(nnn,j)
          end if
            wss1=0.0
            if(igrdsp(k,j).eq.1)then
            if(igrinc(k,j).eq.1)then
               wss1=wincl(k,j)
            else
       wzr1=wzr1+wincl(k,j)
            end if
            end if
            wzro1=0.0
            wzro2=0.0
            wag1=0.0
            wag2=0.0
            wss2=0.0
            wsso1=0.0
            wsso2=0.0
            wzruo1=0.0
            wzruo2=0.0
            afru1=0.33333334
            afru2=0.33333334
            afrz1 = 0.0
            afrz2 = 0.0
            wbc1 = 0.0
            wbc2 = 0.0
c calculate equilibrium temperature of mixture
            call mixtmp(wuo1, wuo22, wzr1, wzr2, wzro1, wzro2, wag1,
     +      wag2, wss1, wss2, wsso1, wsso2, wzruo1, wzruo2, afru1,
     +      afru2, afrz1, afrz2, wbc1, wbc2, tmpold, tmpnew, tmpblk)
c Set temperatures at each radial node to equilibrium
c temperature.
            if(ndbg.eq.1)then
            write(output,9030)timec,j,k
 9030 format(/,'$$$$$$$$$ Freezing of drops of relocating cladding.',
     +'  time =',e12.6,' s,  component ',i3,' axial node =',i3)
            write(output,9040)nnn,tcond3(nrods2(nnn,j),nnn,j)
 9040 format(' axial node from which material slumped =',i3,
     &       ' surface temperature of axial node from where cladding',
     &       ' slumped =',f6.1,' K')
            write(output,9050)tmpold
 9050 format(' ave. temperature of node before material slumped',
     +' into node =',e10.4,' K')
            write(output,9060)tmpnew
 9060 format(' temperature of material slumping into node =', f7.1,' K')
            write(output,9070)tmpblk
 9070 format(' temperature of node after contact with slumping',
     +' material =',e10.4,' K')
            end if
                do 190 l = 1,nrodes(kki)
                tcnd03(l,k,j) = tmpblk
  190           tcond3(l,k,j) = tmpblk
      afrz1=1.
      afru1=0.0
      dencrs=zuden(afrz1, afru1, tmpblk)
       volcs1=(wfrozr(mz-1+k)+wfrouo(mz-1+k)+winfro(k,j))/dencrs
c   skip average of characteristics of frozen drops for case of
c   impact with spacer grid.
          if(indmts.eq.2)go to 211
          idrfz2(k,j)=1
c    since all drops are assumed to have same size, simply increment
c    number of drops at this node by number of drops that froze during
c    this time step.
          ndrp1=ndrfz1(k,j)-ndrops(nnn,j)
            if(ndrp1.lt.0.0)ndrp1=0.0
          ndrp2=ndrops(nnn,j)
          ndrp3=ndrp1+ndrp2
cljs      ndrops(nnn,j)=0.0
          idrops(nnn,j)=0
          udrops(k,j)=0.0
cljs    ndrfz2(k,j) now calculated in liqsol.
cljs      ndrfz2(k,j)=ndrp3
          rdrops(k,j)=rdrops(nnn,j)
          wzrdp1=wfzzr2(k,j)
          wzrdp2=wzrdrp(nnn,j)
          wuodp1=wfzuo2(k,j)
          wuodp2=wuodrp(nnn,j)
cljs  calculate fraction of oxidation for relocated Zr at axial node
cljs    slumped Zr starts out with no weight gain of oxygen.
            wdrfz2(k,j) = ndrp1*wdrfz2(k,j)/ndrp3
          wfzsp2(k,j)=(ndrp1*wfzsp2(k,j)+ndrp2*wdspls(nnn,j))/ndrp3
          wfzuo2(k,j)=(ndrp1*wfzuo2(k,j)+ndrp2*wuodrp(nnn,j))/ndrp3
          wfzzr2(k,j)=wfzzr2(k,j) + wzrdrp(nnn,j)
cljs      fudfz2(k,j)=wfzuo2(k,j)/(wfzuo2(k,j)+wfzzr2(k,j)
cljs #    +2.0*pi*rdrops(k,j)*wdrfz2(k,j))
cljs      hfzox2(k,j)=(1.-fudfz2(k,j))*(6.45e+6)*(91.22/32.)+
cljs #    fudfz2(k,j)*(1.84e+5)*(810./32.)
          pdrfz2(k,j)=pdrfz2(k,j)+powadd(nnn,j)
          fadrop(k,j)=(ndrfz2(k,j)*2.*pi*rdrops(k,j)**2)/
     #    (2.*pi*rco(mz+k-1)*dzcond(mz+k-1))
c   compute average characteristics of frozen drops at this location
c   accounting for mixing together of previously frozen drops with those
c   that froze during this time step.
211       continue
c Because temperature jump due to material relocation is
c directly calculated now, zero out internal energy of relocated
c material.
            hadd(mz-1+k)=0.0
            haddnw(k,j)=0.0
  200    continue
c    update fraction of surface area that is covered with drops of
c    relocated material
        do222k=1,naz
        fadrop(k,j)=(ndrfz2(k,j)*2.*pi*rdrops(k,j)**2)/
     #  (2.*pi*rco(mz+k-1)*dzcond(mz+k-1)) + fadrpg(k,j)
        if(fadrop(k,j).ge.5.0)fadrop(k,j)=5.0
222     continue
c calculate heat generation from oxidation of spacer grid and
c cohesive debris.  If cohesive debris, then spacer grid
c is assumed to not oxidize.
         do240k=1,naz
            kki=(j-1)*ndax+k
            nsw=0
            qcohst(k,j)=0.0
            hgcoh1=0.0
            if(tcond3(nrodes(kki),k,j).lt.1000.0)go to 240
            if(wgbott(k,j).gt.1.e-10.and.wfrozr(kki).gt.1.e-3) nsw=1
            if(nsw.eq.0)go to 210
            ceffzr=coxwtk(tcond3(nrodes(kki),k,j))
c Next, obtain oxidation kinetics equation for UO2.
            ceffuo=24.4*exp(-26241./tcond3(nrodes(kki),k,j))
c Calculate effective oxidation kinetics constant.
            ceff=(1.-fucoht(k,j))*ceffzr + fucoht(k,j)*ceffuo
c Calculate change in weight gain.
            wgtop(k,j)=sqrt(wgtopz(k,j)**2+ceff*dt)
c Limit weight gain to maximum allowed by mass diffusion.
            nshap=0
            call oxydef(oxlis0,k,nshap)
            wmxdif=oxlis0*dt+wgtopz(k,j)
            if(wgtop(k,j).gt.wmxdif)wgtop(k,j)=wmxdif
            if(wgtop(k,j).gt.wgcoht(k,j))wgtop(k,j)=wgcoht(k,j)
c Calculate heat generation per unit surface area.
            qdkns=hefctp(k,j)*(wgtop(k,j)-wgtopz(k,j))/dt
c calculate total heat generation due to oxidation for top
c top surface of cohesive debris.
            qtotox=(pitch(j)**2-pi*rco(kki)**2)*qdkns/dzcond(kki)
            qcohst(k,j)=qcohst(k,j)+qtotox
            qoxcht(k,j)=qoxcht(k,j)+qtotox
            area1=(pitch(j)**2-pi*rco(kki)**2)
            hgcoh1=hgcoh1+area1*(wgtop(k,j)-wgtopz(k,j))/(8.*dt)
c calculate heatup from oxidation of bottom surface.
cljs    fucohb(k,j) always set to zero
cljs        ceff=(1.-fucohb(k,j))*ceffzr + fucohb(k,j)*ceffuo
            ceff = ceffzr
c Calculate change in weight gain.
            wgbot(k,j)=sqrt(wgbotz(k,j)**2+ceff*dt)
c Limit weight gain to maximum allowed by mass diffusion.
            wmxdif=oxlis0*dt+wgbotz(k,j)
            if(wgbot(k,j).gt.wmxdif)wgbot(k,j)=wmxdif
            if(wgbot(k,j).gt.wgbott(k,j))wgbot(k,j)=wgbott(k,j)
c Calculate heat generation per unit surface area.
            qdkns=hefcbt(k,j)*(wgbot(k,j)-wgbotz(k,j))/dt
c calculate total heat generation due to oxidation for bottom
c surface of cohesive debris.
            qtotox=(pitch(j)**2-pi*rco(kki)**2)*qdkns/dzcond(kki)
            qcohst(k,j)=qcohst(k,j)+qtotox
            qoxchb(k,j)=qoxchb(k,j)+qtotox
            area1=(pitch(j)**2-pi*rco(kki)**2)
            hgcoh1=hgcoh1+area1*(wgbot(k,j)-wgbotz(k,j))/(8.*dt)
            go to 220
  210       continue
c check for oxidation of Zr spacer grid.
            if(igrdsp(k,j).ne.1)go to 240
            if(igrinc(k,j).ne.0)go to 240
            ceffzr=coxwtk(tcond3(nrodes(kki),k,j))
            wgrd(k,j)=sqrt(wgrdz(k,j)** 2+ ceffzr*dt)
c Limit weight gain to maximum allowed by mass diffusion.
            nshap=0
            call oxydef(oxlis0,k,nshap)
            wmxdif=oxlis0*dt+wgrdz(k,j)
            if(wgrd(k,j).gt.wmxdif)wgrd(k,j)=wmxdif
            area1=4.*pitch(j)*thincl(k,j)
c spacer grid oxidizes from both sides; so multiply by 0.5 for
c per rod basis.
            wmxwtg=0.5*(32./91.22)*wincl(k,j)/area1
            if(wgrd(k,j).gt.wmxwtg)wgrd(k,j)=wmxwtg
            qdkns=(6.45e+6)*(91.22/32.)*(wgrd(k,j)-wgrdz(k,j))/dt
            qtotox=area1*qdkns/dzcond(kki)
            qcohst(k,j)=qcohst(k,j)+qtotox
            qgrdox(k,j)=qgrdox(k,j)+qtotox
            hgcoh1=hgcoh1+area1*(wgrd(k,j)-wgrdz(k,j))/(8.*dt)
  220       continue
cljs        hgcohs(k,j)=hgcoh1
c calculate production of hydrogen due to oxidation of grid
c spacer and cohesive debris.
            if(.not.scntrl(8))then
c Obtain steam pressure and steam temperature.
              ivol=nvad((j-1)*ndax+k)+filndx(4)
c update hydrogen source term for RELAP5.
              do 230 in = 1,noncn
                 if (in .ne. nonhy) go to 230
                 if (nsoxar.eq.1 .or. nsoxar.eq.2) cycle
                 iln = ivol + in - 1
                 gaman(iln)=gaman(iln)+ recipv(ivol)*hgcoh1*float(isgl)
                 if(gaman(iln).lt.0.0) gaman(iln)=0.0
                 enthn(iln)=uo+co*tcond3(nrodes(kki),k,j)+ do/2.0*
     +           (tcond3(nrodes(kki),k,j)-tao)**2
  230         continue
            endif
  240    continue
c nswqch = switch to model liquified zr.u.o to immediately
c quench and evaporate water when it contacts pool
c of water in fuel bundle.
c 0 = no 1 = yes
         wdtqlp(icomp)=float(nsigl1)*haddbt
         nswqch=0
         if(nswqch.eq.1)then
c store amount of thermal energy in liquified material which
c solidified in bundle.
            do 250 k=1,naz
               ztop=zcond(mz-1+k)+0.5*dzcond(mz-1+k)
               if(hadd(mz-1+k).gt.1.e-10.and.ztop.le.z2phas)then
                  qchlbn(k,icomp) = qchlbn(k,icomp) +
     #              float(nsigl1)*hadd(mz-1+k)
                  hadd(mz-1+k)=1.0
               end if
  250       continue
         end if
c determine which axial node may have made transition from rod-like
c geometry to rubble debris during time step.
c store saturation temperature at bottom of core.
         nvolin=inv+filndx(4)
         tsat=satt(nvolin)
c since tests with electrical heated rods are not designed for
c late-phase melt progression, do not initiate late-phase models;
c do not call rubtrn.
c ***   call rubtrn(j,tsat)
         do260k=1,naz
c    set default values for solidus and liquidus temperatures for
c    simulator.
         tmlsol(k,j)=2830.0
         tmlliq(k,j)=2873.0
            if(irubpp(k,j).eq.1.or.nhrdpn(j).eq.k)then
               kki=(j-1)*ndax+k
               dzfrcl(kki)=dzfrcq(k,j)
               idebcm(j)=1
               ibrch(j)=0
            end if
  260    continue
c set ibrch to node number of breach.
         call brchsw (nfi(mz),ifrag(mz),naz,ibrch(j))
c set flag if x-sectional area for balooning exceeded.
         call mxarea (naz,rocrst(mz),pitch(j),iareax)
c do not call cladding deformation model if temperatures
c out of range, no area left in which to deform, disruption
c has already taken place (any of 3 types of disruption)
         if (izrt.eq.0 .and. idsrup(j).eq.0 .and. ii(j).eq.0 .and.
     &   iareax.eq.0 .and. idebcm(j).eq.0 .and. ibrch(j).eq.0) then
           call clddfm (naz,nrcldi(mz),nrcond(mz),nrodes(mz),dt,
     &     dt, dtemp,dzcond(mz),ggivy(1,j),hfix(mz),ii(j),jiter,
     &     oxdhc,pcool,pgas(j),pitch(j),rci(mz),rcoi(mz),
     &     rcii(j),rcos(j),rl(j),tcolc(mz),tcond(n),timec,vplen(j),
     &     xcond(n),zcond(mz),vfvod(mz),hoop(mz),icladf(j),dtmxn,
     &     pcool0,pgas0,rpel(mz),tcond0(n),vtvod,qclad(mz),
     &     qout2(1,icomp,1),rfarc(1,j),iareax,ncrum(mz))
c reset all radii reference points if ballooning occurs
c to the moving rcoi.  volume is conserved.
c dir$ ivdep
cljs  testing
            do i = 1,naz
              if(nsoxar.eq.0)then
              rocrst(mz-1+i)=rfix(rocrst(mz-1+i),rcox(i),rcoi(mz-1+i) )
              rocrmx(mz-1+i) = rocrst(mz-1+i)
              radus1=rnoxd(mz-1+i)
              rnoxd(mz-1+i) = rfix(rnoxd(mz-1+i),rcox(i),rcoi(mz-1+i))
              rnalf(mz-1+i) = rfix(rnalf(mz-1+i),radus1,rnoxd(mz-1+i))
              rco(mz-1+i) = rfix(rco(mz-1+i),rcox(i),rcoi(mz-1+i))
              oxdeo(mz-1+i) = rco(mz-1+i) - rnoxd(mz-1+i)
              elseif(nsoxar.eq.1)then
              rnalf(mz-1+i) = rnoxd(mz-1+i)
              alfao(mz-1+i) = 0.0
              rcox(i) = rcoi(mz-1+i)
              arga=rco(mz-1+i)
              argb=rcox(i)
              argc=rcoi(mz-1+i)
              rotest=rfix(arga,argb,argc)
              arga=rnoxd(mz-1+i)
              argb=rcox(i)
              argc=rcoi(mz-1+i)
              rntest=rfix(arga,argb,argc)
              oxtest=rotest-rntest
              rco(mz-1+i)=rotest
              rnoxd(mz-1+i)=rntest
              oxdeo(mz-1+i)=oxtest
              rocrst(mz-1+i)=rco(mz-1+i)
              rocrmx(mz-1+i)=rocrst(mz-1+i)
              end if
            enddo
c initialized these variables for *fstate* if *freloc* no longer being
c called.
            do 280 i = 1,naz
               voidfr(i) = 0.0
               ncrum(mz-1+i) = 0
  280       continue
         endif
c if breach has just now occurred, set flag to breach node
         if ( ibrch(j) .eq.  0) then
            if(icladf(j) .ne. 0) then
               ibrch(j) = ii(j)
            endif
         endif
c if cladding deformation model no longer called due to high
c temps., set total void for gas pressure model
         if ((( izrt.gt.0 .or. iareax.gt.0) .and. ibrch(j).eq.0)
     +   .or. icladf(j) .eq.  0) then
            do 290 i = 1,naz
               vtvod(i) = 3. 14159* (rci(mz-1+i)** 2- rcii(j)**2) *
     +         dzcond(mz-1+i) + vfvod(mz-1+i)
               if ( vtvod(i) .lt.  0) vtvod(i) = 0.0
  290       continue
         endif
c calculate gas inventory in gm moles
         gasms = gasmol (ggivy(1,j), ibrch(j) ,idsrup(j) )
c calculate internal gas pressure
         call fpress (gasms,vtvod)
         call fstate (xdeltz, roliq, tzr)
c calculate nuclear heat generation
         do310i=1,naz
            apel0(i)=pi*rpel((j-1)*ndax+i)**2
          if(wremzr(mz+k-1).gt.1.e-10)then
            if(fdrmn2(k,j).lt.(1.0-0.001))then
            adiss=fdrmn2(k,j)*(apel0(k)-pi*ruliq(mz+k-1)**2)
            apel0(k)=apel0(k)-adiss
            else
            apel0(k)=pi*ruliq(mz+k-1)**2
            end if
          end if
  310    continue
         call nheat (apel0, 0, qfrell)
         call rlockf (ncrum(mz),rci(mz),naz,voidfr,rlcnda)
c calculate temperature for all intact nodes.
         icoht(j) = 0
         icohb(j) = 0
c     kmid1 = mid-plane axial node
         kmid1 = naz/2 + 1
         do 330 i = 1,naz
c skip over axial nodes that are cohesive or rubble debris.
            if (irubpp(i,j).eq. 1.or. lcrucb(i,j).ge.1) then
               nelm = numelm(mz+i-1)
               do 320 ir=1,nelm
                  effk (ir,i) = 1.00
                  effcp (ir,i) = 1.e+6
                  effgen(ir,i) = 0.0
  320          continue
               go to 330
            end if
            kaxndb=i
            call pmass( wuo2(i), wzr(i), epsz, wz, wx )
c update radial mesh
            call meshgn (nrcldi(mz-1+i), nrodes(mz-1+i), rci(mz-1+i),
     +      rco(mz-1+i), xcond3(1,i,j))
            inaz = i
            kx = mz + i - 1
            acond1=5700.0
            qcldtt=oxdhc(i)+qcdrps(i,j)+qgrdox(i,j)+qcdrgs(i,j)+
     &      qoxcht(i,j)+qoxchb(i,j)
            if(modidx(1).ne.1)then
            call effht(0.0,qcldtt,rpel(kx),ruliq(kx),rci(kx),unuc(i),
     &        effcp(1,i), effcpc(i), effgen(1,i), effk(1,i), effkc(i),
     &        effkf(i), rcii(icomp), acond1, kx)
            else
            call effhts(qcldtt,unuc(i),
     &        effcp(1,i), effgen(1,i), effk(1,i), kx)            
            end if
              if(i.eq.kmid1)then
c     store effective properties and heat generation rate at mid-plane
c     axial node
                do mm = 1,numelm2(i,j)
                effgn1(mm,j) = effgen(mm,i)
                effk1(mm,j) = effk(mm,i)
                effcp1(mm,j) = effcp(mm,i)
                end do
              end if
  330    continue
         call heatc2( j,effk,effcp,effgen,nvirn )
         do360i=1,naz
c skip over intact axial nodes and nodes that are completely
c liquefied.
            if(irubpp(i,j).eq.0)go to 360
c if natural circulation of liquefied debris, bypass call to heatdb.
            if(lcrucb(i,j).ge.1)go to 360
            call heatdb(i,j,dt,tsat)
            if(.not.scntrl(8))then
              ivol=nvad((j-1)*ndax+i)+filndx(4)
c update hydrogen source term for RELAP5.
              do 350 in = 1,noncn
                 if (in .ne. nonhy) go to 350
                 iln = ivol + in - 1
                 gaman(iln)=gaman(iln)+recipv(ivol)*hgdeb(i,j)*
     #            float(isgl)
                 if(gaman(iln).lt.0.0) gaman(iln)=0.0
                 enthn(iln)=uo+co*tcond3(nrodes(kki),k,j)+ do/2.0*
     +             (tcond3(nrodes(kki),k,j)-tao)**2
  350         continue
            endif
  360    continue
cljs        jiter = 0
cljs   For severe accident modeling, specify sausage ballooning model
cljs   (slow heatup) instead of localized ballooning model (rapid heatup
cljs   of large break LOCAs)
            jiter = 1
         do 400 i = 1,naz
            nelm = numelm(mz+i-1)
            do 390 ir = 1,nelm
               avir(ir,i) = pi*dzcond(mz+i-1)*( xcond3(ir+1,i,j)+ xcond3
     +         (ir,i,j) )*( xcond3(ir+1,i,j)-xcond3(ir,i,j) )
  390       continue
  400    continue
         do 420 i = 1,naz
            nelm = numelm(mz+i-1)
            do 410 ir = 1,nelm
               qstor(j) = qstor(j) + effcp(ir,i)*avir(ir,i)*0.5* (
     +         (tcond3(ir+1,i,j)+tcond3(ir,i,j)) - (tcnd03(ir+1,i,j)+
     +         tcnd03(ir,i,j)) )*nsigl(j)
               qedt(j) = qedt(j) + effgen(ir,i)*avir(ir,i)*dt*nsigl(j)
  410       continue
            qodt(j) = qodt(j) + (oxdhc(i)+oxdhf(i))*dzcond(mz+i-1)* dt
     +      *nsigl(j)
            qndt(j) = qndt(j) + unuc(i)*dzcond(mz+i-1)*dt*nsigl(j)
            qsdt(j) = qodt(j) + qndt(j)
  420    continue
         if (qstor0(j) .eq. 0.0) then
c calculate initial stored energy.
           do i=1,naz
             do ir=1,numelm(mz+i-1)
               qstor0(j) = qstor0(j) + effcp(ir,i) * avir(ir,i) *
     +         (tcnd03(ir+1,i,j) + tcnd03(ir,i,j))
             enddo
           enddo
           qstor0(j) = qstor0(j) * 0. 5* nsigl(j)
         endif
c set converged, shufled arrays
         itrflg = 2
         call shufl (dzcond(mz),dzfrac(m2),dzfrac(m2+ndax),fgrj(1,j),
     +   fpivrt(1,j),fpivy(1,j),movesw(mz),naz,ndisrp(mz),tfgrj,
     +   tfpivr,tfpivy,zcond(mz),ci(nn15),acae(mz),prf(mz),gsg(nn5), gou
     +   (nn6),dis(nn16),sv(nn4),taca,tprf,tgsg,tgou,tdis,tsav,tcik,
     +   itrflg)
         do 440 i = 1,naz
            movesw(mz-1+i) = 0
  440    continue
         if(.not.scntrl(9))then
            call mxctmp(naz,tsur,izrt,pcool,pgas(j),rci(mz),rco(mz))
            if(izrt.eq.1)then
               itmpmx=1
               tmpfmx=0.0
               do450i=1,naz
                  if(tcond3(nrodes(mz-1+naz),i,j).gt.tmpfmx)then
                     tmpfmx=tcond3(nrodes(mz-1+naz),i,j)
                     itmpmx=i
                  end if
  450          continue
c the 1900. in the following line is consistent with that in sub mxctmp.
               if(tmpfmx.ge.1900.and.ibrch(j).eq.0)then
                  ii(j)=itmpmx
                  icladf(j)=1
               end if
            end if
            if (afuel(mz) .lt. 1.0e-07) izrt = 1
         else
            izrt = 1
         endif
         if (izrt.eq.0 .and. idsrup(j).eq.0 .and. ibrch(j).eq.0) then
           call clddfm (naz,nrcldi(mz),nrcond(mz),nrodes(mz),dt,
     &     dt, dtemp,dzcond(mz),ggivy(1,j),hfix(mz),ii(j),jiter,
     &     oxdhc,pcool,pgas(j),pitch(j),rci(mz),rcoi(mz),
     &     rcii(j),rcos(j),rl(j),tcolc(mz),tcond(n),timec,vplen(j),
     &     xcond(n),zcond(mz),vfvod(mz),hoop(mz),icladf(j),dtmxn,
     &     pcool0,pgas0,rpel(mz),tcond0(n),vtvod,qclad(mz),
     &     qout2(1,icomp,1),rfarc(1,j),iareax,ncrum(mz))
            do i = 1,naz
              if(nsoxar.eq.0)then
              rocrst(mz-1+i)=rfix(rocrst(mz-1+i),rcox(i),rcoi(mz-1+i))
              radus1=rnoxd(mz-1+i)
              rnoxd(mz-1+i) = rfix(rnoxd(mz-1+i),rcox(i),rcoi(mz-1+i))
              rnalf(mz-1+i) = rfix(rnalf(mz-1+i),radus1,rnoxd(mz-1+i))
cljs          rocrmx(mz-1+i)=rfix(rocrmx(mz-1+i),rcox(i),rcoi(mz-1+i) )
              rocrmx(mz-1+i) = rocrst(mz-1+i)
              rco(mz-1+i) = rfix(rco(mz-1+i),rcox(i),rcoi(mz-1+i))
              oxdeo(mz-1+i) = rco(mz-1+i) - rnoxd(mz-1+i)
              elseif(nsoxar.eq.1)then
              rnalf(mz-1+i) = rnoxd(mz-1+i)
              alfao(mz-1+i) = 0.0
              rcox(i)=rcoi(mz-1+i)
              arga=rco(mz-1+i)
              argb=rcox(i)
              argc=rcoi(mz-1+i)
              rotest=rfix(arga,argb,argc)
              arga=rnoxd(mz-1+i)
              argb=rcox(i)
              argc=rcoi(mz-1+i)
              rntest=rfix(arga,argb,argc)
              oxtest=rotest-rntest
              rco(mz-1+i)=rotest
              rnoxd(mz-1+i)=rntest
              oxdeo(mz-1+i)=oxtest
              rocrst(mz-1+i)=rco(mz-1+i)
              rocrmx(mz-1+i)=rocrst(mz-1+i)
              end if
            enddo
            call fstate (xdeltz,roliq,tzr)
            do i = 1,naz
              movesw(mz-1+i) = 0
            enddo
         endif
c if breach occurred, determine what portion of cladding will
c oxidized on inside surface.
         if(icladf(j).gt.0)then
           do490i=1,naz
             if(hoop(mz+i-1).gt.epsox2) brchv(i,j)=1.0
  490      continue
         end if
c if burst just occurred, set breach flag, gap temp. and width
         if (icladf(j) .gt.  0.and. ibrch(j) .eq.  0) ibrch(j) = ii(j)
c remove grid spacers which have exceeded the melt temp.
         call gridsc
c assess the component damage state.
         call cfdamg (denuo2,dzcond(mz),naz,rco(mz),rnoxd(mz),zoxden,
     +   vfuel(m2),wbotuo(j),wbotzr(j),wfrouo(mz),wfrozr(mz),oxdwz,
     +   oxdwf(mz),wremuo(mz),wremzr(mz),wuobng(mz),wuo2,wzobng(mz),
     +   wzrbng(mz),ndisrp(mz),wuorem(mz),wuomlt(mz),nuflg,nzrflg,
     #   uo2ms(mz),uo2nm(mz),zrms(mz),zro2ms(mz))
c if burst just occurred, set breach flag to burst node.
         if(icladf(j) .gt.  0.and. ibrch(j) .eq. 0)ibrch(j)=ii(j)
         timec = timec + dt
c calculate liquefaction temperature of annaulus of dissolved
c uo2 at each axial node.
         do500i=1,naz
            if(wzr(i).gt.1.e-10)then
              call atomfr(wuo2(i),wzr(i),oxdwz(i),afracu,afracz,afraco)
            end if
  500    continue
c zero out this fission gas array for debris.
         do 510 i = 1,16
            fpary(i,j) = 0.
  510    continue
c end of component timestep loop
      endif
c compute beta zircaloy thickness and reset dzfrac,vfuel.
c dir $ivdep
      do 520 i = 1,naz
         dzfrac(m2-1+ndax+i) = dzfrac(m2-1+i)
         vfuel(m2-1+ndax+i) = vfuel(m2-1+i)
  520 continue
c compute average thermal properties and stored energy for component.
      call efprop(effcp,effk,effgen,naz,ngeom(j),numelm(mz),
     #  tcond(n),xcond(n),6,10,ifrag(mz),efrcpa(1,icomp),effka(1,icomp),
     #  efgena(1,icomp), efstor(1,icomp), efstr0(1,icomp), tcond0(n) )
c if no aerosol transport calculation has been specified, then.
        if(ndbg.eq.1)then
        write(output,9095)gaman(3860)
9095    format(' SIMUAN at end; gaman(3860)=',e10.4)
        end if
      if (filid(34).eq.0.0)return
      call fpspix('Sn  ', nsn)
      if(nsn.eq.0)return
      i34 = filndx(34)
      ispo = i34 + (nsn-1)*fpspvk(i34)
c calculate release of tin from cladding.
      do 530 i = 1, naz
         mdyn=ndax*(j-1)+i
         tcld=tcond3(nrodes(mz-1+i),i,j)
         if(tcld.lt.1000.)go to 530
         if(int(crucb).eq.1)go to 530
         if(wremzr(mdyn).gt.1.e-10)go to 530
         if(fpstt(j,i,1).lt.1.e-12)go to 530
c Calculate volume of oxidized cladding.
         vzira=pi*dzcond(mdyn)*(rnoxd(mdyn)**2-rci(mdyn)**2)
         azira=2.*pi*rnoxd(mdyn)*dzcond(mdyn)
         snrem=fpstt(j,i,1)
         isp = nvhydf(j,i) + ispo
c Calculate relap5 volume index.
         nvolin=nvad((j-1)*ndax+i)+filndx(4)
c Get concentration of tin in vapor state in coolant.
         call tinr(tcld,vzira,azira,snrem,fpvap(isp),tcolc(mdyn),pcool,
     +   snrelr, nvolin, ierr, iwarn)
         if(ierr.gt.0)then
c Print to check indexes.
            write (output,9080)ierr
 9080 format('0Error in subroutine tinr called from simuan, ierr=',i5)
            fail = .true.
         end if
c Update inventory to account for release.
         fpstt(j,i,1)=fpstt(j,i,1)-snrelr*dt
         fnsigl=float(nsigl(j))
         fpsrc(isp)=fnsigl*snrelr+fpsrc(isp)
  530 continue
      return
      end
*endif
