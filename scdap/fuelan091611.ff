*mlist
*if def,selap
       subroutine fuelan
c
c  Subroutine is the driver for the scdap fuel rod analysis.
c
c  Cognizant engineer: ewc.
c
c  Calling subroutines:  sbntac
c subroutines called:  cfdata, oxidiz, liqsol, brchsw,
c mxarea, clddfm, freloc, shufl , fgrelh,
c fgrelg, fpress, fstate, nheat , rlockf,
c meshgn, trate , mxctmp,
c gridsc, cfdamg, cfaver,        fragmt
c
cljs  RELAP5 table lookup data
       use gentblc
       use scdmod
       implicit none
       include 'comctl.h'
       include 'contrl.h'
       include 'fast.h'
       include 'scddat.h'
       include 'scntl.h'
       include 'cpmdat.h'
       include 'buntim.h'
       include 'cora.h'
       include 'farays.h'
       include 'voldat.h'
       include 'statec.h'
       include 'cons.h'
       include 'solcom.h'
       include 'nbtim.h'
       include 'cmptim.h'
       include 'iocom.h'
       include 'trnot1.h'
       include 'miscon.h'
       include 'cmatp.h'
       include 'fpnonv.h'
       include 'fpfast.h'
       include 'ptscom.h'
       include 'dbacct.h'
       include 'eht0.h'
       include 'effprp.h'
       include 'plndat.h'
       include 'tblsp.h'
       include 'balfar.h'
       include 'debout.h'
       include 'fgrcom.h'
       include 'grscgr.h'
       include 'intcom.h'
       include 'ndxara.h'
       include 'nhtara.h'
       include 'fpdkht.h'
       include 'scdads.h'
       include 'scdcom.h'
       include 'scdout.h'
       include 'scdpow.h'
       include 'trnot2.h'
       include 'ufiles.h'
       include 'slumpv.h'
       include 'blageo.h'
       include 'oxairv.h'
       real a, afracl, avir, avoidl, azira, b, c, dtemp, dzfrq0, effcp,
     & effcpc, effgen, effk, effkc, effkf, epsz, estimd, fnsigl,gasms,
     & haddbt, hremov, oxdhc, oxdhf, oxdwz,pcool0, pgas0, powad2, afrel,
     & qin, rcox, rfrces,rlcnda, roliq, slglen, snrem, snrelr, taca,
     & tcik, tcld, tdis,tfgrj, tfpivr, tfpivy, tgapbr, tgou, tgsg,
     & timdbf, tprf, tsat, tsav, tsur, tzr, tzr2,voidfr, vtvod, vzira,
     & wgapbr, wmltzo, wuo2, wuotot, wx, wz, wzr,xdeltz, ztop
       real afracu, afracz, afraco, tmpfmx, timnw1, timnw2, tsolgd,
     & tgrdlq, tfluid, gmix, sigbsr, femiss, drgap, hgapss, hgaptr,
     & tmpgap, hgprad, acond1, gasmol, rfix, gascns, pliq, radus1,
     & qcldtt, vrodhp, ruo2, rzr, wurod, wzrod, wuo1, wuo22, wzr1,
     & wzr2, wzro1, wzro2, wag1, wag2, wss1, wss2, wsso1, wsso2, wzruo1,
     & wzruo2, afru1, afru2, afrz1, afrz2, wbc1, wbc2, tmpold, tmpnew,
     & tmpblk, dvsum, tmpsum, dvrod, vrsthp, wuslg, wzslg,
     & ceffzr, ceffuo, ceff, oxlis0, wmxdif, qdkns, qtotox, wmxwtg,
     & area1, hgcoh1, apel0
       real tzrmlt,volcs1,dencrs
       real ndrp1,ndrp2,ndrp3,wzrdp1,wzrdp2,wuodp1,wuodp2,adiss
       real co, uo, do
       dimension apel0(ndax), gmix(10), effcp(ndrd,ndax), effcpc(ndax),
     & effgen(ndrd,ndax), effkc(ndax), roliq(ndax), hremov(ndax),
     & oxdhc(ndax), oxdhf(ndax), slglen(ndax), tzr(ndax), voidfr(ndax),
     & tzr2(ndax), oxdwz(ndax), dtemp(ndax), effk(ndrd,ndax),
     & afracl(ndax), avoidl(ndax), mltswz(ndax),qin(ndax), tsur(ndax),
     & xdeltz(ndax), wmltzo(ndax), rlcnda(ndax), effkf(ndax),
     & wuo2(ndax), wzr(ndax), vtvod(ndax)
       dimension tfpivr(5,ndax),tfgrj(5,ndax),tfpivy(ndax,5),rcox(ndax),
     & taca(ndax), tprf(ndax),tgsg(5,ndax),tgou(6,ndax),tdis(16,ndax),
     & tsav(4,ndax), tcik(16,ndax), avir(ndrd,ndax)
c Local variables.
       integer i, i34, iareax, ibrch0, ierr, ir, isp, ispo, itran,
     & itrflg, iwarn, izrt, j, jiter, k, kfail, kki, kx, ll, mz, m2,
     & mdyn, mltswz, n, nelm, nn4, nn5, nn6, nn15, nn16, nsn, nsswth,
     & nswqch, nuflg, nvolin, nzrflg, ig, itmpmx, igslmp, kmnpol, nnn,
     & nsw, ivol, in, iln, kdynn, m, l, nswexp
       integer indmts,nshap,ndrps1
c
       real fden,cden,coxwtk,zuden
       real pwrtotl(1),timen,tempn
       real arg1
       real poxndt
       real woxgan,woxmax
       real arga,argb,argc,rotest,rntest,oxtest
       logical lsvech
       integer intg1,intg2,indevol
       integer itab
       integer kmid1,mm
       integer ndbg
c
       logical err
c
       data sigbsr /5.6697e-8/
       data uo/1.827834e5/, co/10310.75/, do/0.52257/
       data wzr1/0.0/, wzr2/0.0/
c
       rfix(a,b,c) = sqrt(a*a - b*b + c*c)
c
       lsvech = .false.
         ndbg=0
       j = icomp
       mz = ndax*(icomp - 1) + 1
       m2 = ndax*2*(icomp - 1) + 1
       n = ndrd*ndax*(icomp - 1) + 1
       nn4 = 4*ndax*(icomp - 1) + 1
       nn5 = 5*ndax*(icomp - 1) + 1
       nn6 = 6 * ndax*(icomp - 1) + 1
       nn15 = 15*ndax*(icomp - 1) + 1
       nn16 = 16*ndax*(icomp - 1) + 1
c  Set indicator of grid spacer slumping during time step to zero.
       naxpz(j)=naz
c  Override fragmentation due to quench until debris models are
c  implemented in scdsimp.
       do i = 1,naz
         ifrag(i+mz-1) = 0
         afuel(i+mz-1) = pi*rpel(i+mz-1)**2
         oxdwz(i) = 0.0
c Initialize term that stores heat conducted from drops to
c fuel rod.
         rlcnda(i) = 1.0
         qcdrps(i,icomp)=0.0
         qcdrgs(i,icomp)=0.0
         qgrdox(i,icomp)=0.0
         qoxcht(i,icomp)=0.0
         qoxchb(i,icomp)=0.0 
c  Initialize hydrogen production rate due to oxidation of drops.
         qdrops(i,icomp)=0.0
         qdebox(i,icomp)=0.0
         qdboxm(i,icomp)=0.0
         qcohst(i,icomp)=0.0
         hgdrps(i,icomp)=0.0
         hgcohs(i,icomp)=0.0
         hgdeb(i,icomp)=0.0
c  If cladding peak temperature is greater than 1250 K, rupture
c  strain of cladding needs to be reduced to reflect strengthening
c  effect of oxide shell and low ductility of oxide shell.
c        if (tcond3(nrodes(mz-1+i),i,j).gt.1250.0) erupt = 0.02
c  Define start of time step temperatures.
         do l = 1,nrodes(mz-1+i)
           tcnd03(l,i,j)=tcond3(l,i,j)
         enddo
       enddo
       do i = 1,naz
         wuotot = wfrouo(mz+i-1) + wuobng(mz+i-1) - wuorem(mz+i-1) -
     &   wremuo(mz+i-1)
c  ifrag=3=void region.
         if (wuotot .lt. 0.01) ifrag(mz+i-1) = 3
       enddo
       idsrup(j)=0
c  Set the radial melt fraction required to cause the fuel column
c  to buckle.
       rfrces = 0.1
c  This initialization of past time step coolant pressure must be
c  moved to the dbundl subroutine.
       pcool0 = pcool
c  estimd and curtim will be dummies until disruption routines
c  are inserted.  timec in current component time and timdbf is
       estimd = 0.0
       timdbf = timdb + deltdb
       timec = timdb
c  Determine the movement of fuel in the intact rod if debris
c  regions have been formed.
       if (ntotrg .gt. 1) then
         itrflg = 0
         call shufl (dzcond(mz),dzfrac(m2),dzfrac(m2+ndax),fgrj(1,j),
     &   fpivrt(1,j), fpivy(1,j),movesw(mz),naz,ndisrp(mz),tfgrj,
     &   tfpivr, tfpivy, zcond(mz),ci(nn15),acae(mz),prf(mz),gsg(nn5),
     &   gou(nn6),dis(nn16),sv(nn4),taca,tprf,tgsg,tgou,tdis,tsav,tcik,
     &   itrflg)
         do i = 1,naz
           movesw(mz-1+i) = 0
         enddo
       endif
c  Save beginning of timestep values for i/o variables.
       call cfdata
       if (.not.lsvech) then
         do k = 1,naz
           avoidl(k) = pitch(j)**2 - pi*rcos(j)**2
           if (avoidl(k) .lt. 1.e-8) avoidl(k) = 1.e-8
           tsur(k) = tcond3(nrods2(k,icomp),k,icomp)
           tsur0(k) = tcnd03(nrods2(k,icomp),k,icomp)
           dtemp(k) = tsur(k) - tsur0(k)
         enddo
         pgas0=pgas(naz)
       endif
c  Set izrt > 0 if maximum surface temperature less 600 k or greater
c  the 2098 k or if balooning model is turned off.
       if (.not.scntrl(9)) then
         call mxctmp (naz,tsur,izrt,pcool,pgas(j),rci(mz),rco(mz))
         if (izrt .eq. 1) then
           itmpmx = 1
           tmpfmx = 0.0
           do i = 1,naz
             if (tcond3(nrodes(mz-1+naz),i,j) .gt. tmpfmx) then
               tmpfmx = tcond3(nrodes(mz-1+naz),i,j)
               itmpmx = i
             endif
           enddo
c  The following line is consistent with that in sub. mxctmp.
           if (tmpfmx.ge.1900 .and. ibrch(j).eq.0) then
             ii(j) = itmpmx
             icladf(j) = 1
cljs         imdctl(1) = ior(imdctl(1),dmwrite)
cljs         write (inpout,"('0-------- Core degradation',es14.6,' s: Fa
cljs &ilure of cladding due to high temperature under compression loadin
cljs &g, axial node ',i3,' component',i3)") timehy,itmpmx,
cljs & scd1(icomp)%cmpno
cljs         write (inpout,9010) tmpfmx
c9010  format (' temperature (K) =',f7.1,'.')
c            write(inpout,9211)j,i
c9211  format(' component number =',i3,' axial node =',i3)
           endif
         endif
         if (afuel(mz) .lt. 1.0e-07) izrt = 1
       else
         izrt = 1
       endif
c  Get power for this Scdap component.
       call tspowr
       jiter = 1
c  Turn off oxidation at node in which debris blocks out coolant.
       do i=1,naz
         if (irubpp(i,j).eq.1. or. nblkrd(i,j).eq.1.or.
     &   lcrucb(i,j).ge.1.or. dzfrcq(i,j).ge.0.99) then
           noxide(mz-1+i) = 2
         endif
       enddo
       call oxidiz (oxdeo(mz),alfao(mz),oxdwc(mz),oxdwc0,oxdhc,oxdhf,
     & rnoxd(mz),rnalf(mz),nfrslg(mz),tzr,oxdwz,daxdis(1,j),noxide(mz))
       do i=1,naz
       oxdhcc(i,icomp) = oxdhc(i)
       oxdhfc(i,icomp) = oxdhf(i)
c  Save new outer cladding radius calculated by oxidiz in separate array
c  for ref. pt. if ballooning occurs.
         rcox(i)=rcoi(mz-1+i)
c  Put outer clad radius back if greater than crust radius.
         rocrst(mz-1+i) = max(rocrst(mz-1+i),rco(mz-1+i))
c  Set metallic cladding thickness for liqsol, account for double sided
c  oxidation.
         tzr2(i) = 0.0
         if (int(brchv(i,j)) .ne. 1) then
           tzr2(i) = rnoxd(mz-1+i) - rci(mz-1+i)
         else
           tzr2(i) = 0.5*(rnoxd(mz-1+i) - rci(mz-1+i))
         endif
         if (tzr2(i) .lt. 0.0) tzr2(i) = 0.0
       enddo
       wdtqlp(icomp)=0.0
c Calculate time shift to inconel reaction caused by ZrO2 insulation on
c fuel rods.
       do i=1,naz
         k = mz - 1 + i
c Check for possibility of oxide being so thick that it never gets
c dissolved.
         if (oxdeo(k) .gt. 1.0e-4) cycle
c Skip over axial nodes that do not have inconel grid
c spacers and nodes where the grid spacer has slumped away
         if (igrdsp(i,j).lt.1 .or. igrdsp(i,j).ge.3) cycle
         if (igrinc(i,j) .eq. 0) cycle
         timnw1 = timzo2(i,j) - dt
         if (tcond3(nrodes(k),i,j) .lt. 1273.0) cycle
c Get liquidus temperature of inconel grid spacer (tgrdlq)
         call hprop (tsolgd, tgrdlq)
         if (tcond3(nrodes(k),i,j) .ge. tgrdlq) then
c Grid spacer melts during this time step
           timzo2(i,j) = timehy
           cycle
         endif
         if (tcond3(nrodes(k),i,j).le.1423.0 .or. oxdeo(k).le.3.e-5)
     &   then
           timnw2 = 3.759*((100.0*oxdeo(k)**2.1056)*
     &     exp(26595.5/tcond3(nrodes(k),i,j)))
         else
           timnw2=4.021e-6*((100.0*oxdeo(k)**1.3413)*
     &     exp(37142. 5/tcond3(nrodes(k),i,j)))
         endif
         timnw2 = timnw2 + timehy
         timzo2(i,j) = min(timnw1,timnw2)
       enddo
c  Check for failure of fuel rod cladding due to interaction with
c  Inconel grid spacer.
       do i=1,naz
c  Bypass check if grid spacer not reacting with cladding or already has
c  slumped away.
         if(igrdsp(i,j).lt.1.or.igrdsp(i,j).ge.3) cycle
c Check if the grid spacer is zircaloy (0) or Inconel (1)
         if(igrinc(i,j).eq.0) then
c Assume Zr grid spacer slumps when adjacent cladding is
c calculated to slump.
           if(wremzr(mz-1+i).gt.1.e-10) igrdsp(i,j)=2
         else
           if(timehy. ge. (timzo2(i,j) - dt)) then
             igrdsp(i,j)=2
           endif
         endif
       enddo
c  Calculate lowest axial node with molten pool.
       kmnpol=naz+1
       do i = naz,1,-1
          if (lcrucb(i,j) .eq. 1) kmnpol = i
       enddo
       call liqsol(j,denuo2,dt,dzcond(mz),faxial,naz,pcool,
     & pgas(j),pitch(j),qin,rci(mz),rl(j),rco(mz),rpel(mz),teff(mz),
     & oxdeo(mz),tsur,tsur0,tzr2,zcond(mz),zgrid(1,j),nfrslg(mz),
     & rocrmx(mz),rocrst(mz),volcrs(mz),wbotuo(j),wbotzr(j),wfrouo(mz),
     & wfrozr(mz),wremuo(mz),hadd(mz),haddbt,hremov,kfail,mltswz,
     & roliq,slglen, wuo2,wzr,fmix,nwet,avoidl,afracl,tmpfal,
     & dzfrcl(mz),vladeb(mz),ndisrp(mz),oxdwf(mz),oxdwz,stozro(mz),
     & timec,vfuel(m2),flwh2(mz),flstm(mz),burnup(mz), wuorem(mz),
     & wremzo(mz),ruomlt(mz),wuomlt(mz),wmltzo,wbotox(j), dzfrac(m2),
     & rfrces,igrdsp(1,j),wincl(1,j),thincl(1,j),winfro(1,j),
     & winliq(1,j),wzrinc(1,j),wzrgfz(1,j),igrinc(1,j),dzrinf(1,j),
     & dinzrf(1,j),daxdis(1,j),thkgpl(1,j),daxgrd(1,j),retabg(1,j),
     & thetgr(1,j),drgrdm(1,j),dia1gr(1,j),dza1gr(1,j),oxdwc(mz),
     & rnoxd(mz),rci(mz),rcoi(mz),ruliq(mz),winrem(1,j),wremzr(mz),
     & nfi(mz),wuobng(mz),unuca(1,j),powadd(1,j),kmnpol,idcomp(j),
     & kfail2(1,j))
       igslmp=2
       do k=1,naz
         if(igrdsp(k,j).eq.3)igslmp=1
       enddo
       do k=1,naz
         kki=(icomp-1)*ndax+k
         dzfrq0=dzfrcq(k,j)
         dzfrcq(k,j)=dzfrcl(mz-1+k)
c  Set indicator to show that grid spacer slumping is completed.
         if(igrdsp(k,j).eq.3)igrdsp(k,j)=4
         if(ibrch(j).eq.0)then
           if(igrdsp(k,j).eq.4.and.igrinc(k,j).eq.1)then
             if(dzrinf(k,j).ge.(tzr2(k)-1.e-6))then
c  Set fuel rod failure flags.
               ibrch(j)=1
               ii(j)=k
               icladf(j)=1
               imdctl(1) = ior(imdctl(1),dmwrite)
               write (inpout,"('0-------- Core degradation',es14.6,' s:C
     & ladding has failed due to interaction with grid spacer, axial nod
     &e ',i3,' component 'i3)") timehy,k,scd1(icomp)%cmpno
             endif
           endif
         endif
c  Check to see whether grid spacer should be flagged as being melted
c  away.
         if (igslmp.eq.1.and.igrdsp(k,j).eq.4)then
           if (ngrid.ge.1)then
             do ig = 1,ngrid
               if ((zcond2(k,icomp)+0.5*dzcond(kki)).gt.zgrid(ig,icomp)
     &         .and. (zcond2(k,j)-0.5*dzcond(kki)).lt.zgrid(ig,j))then
                 imdctl(1) = ior(imdctl(1),dmwrite)
                 write (inpout,"('0-------- Core degradation',es14.6,': 
     &Grid spacer has slumped, component ',i3,' axial node',i3)")
     &           timehy,k,scd1(icomp)%cmpno
                 write(inpout,9040) zgrid(ig,j)
 9040  format(' elevation (m) =',es12.4,'.')
                 zgrid(ig,j)=-1.
               endif
             enddo
           endif
         endif
       enddo
c  Calculate temperature jump due to relocating material freezing in
c  axial node.
       do nnn = 1,naz
         if(idrops(nnn,j).eq.1)go to 150
cljs     if(idrops(nnn,j).eq.3.and.idrpsz(nnn,j).eq.1)go to 150
cljs     if(idrops(nnn,j).eq.2.and.idrpsz(nnn,j).eq.1)go to 150
cljs     if(idrops(nnn,j).eq.4.and.idrpsz(nnn,j).eq.1)go to 150
cljs     if(idrpgs(nnn,j).eq.2.and.idrgsz(nnn,j).eq.1)go to 150
         cycle
  150    continue
         indmts=1
         if(idrpgs(nnn,j).eq.2.and.idrgsz(nnn,j).eq.1)indmts=2
         if(idrops(nnn,j).eq.3.and.indmts.eq.1) then
           imdctl(1) = ior(imdctl(1),dmwrite)
           write (inpout,9050)
 9050 format(' Blockage of relocating cladding by spacer grid')
         endif
         if(indmts.eq.1.and.idrops(nnn,j).eq.2) then
           imdctl(1) = ior(imdctl(1),dmwrite)
         endif
c        if(indmts.eq.2) write(inpout,9132)
c9132 format(' Freezing of drops of relocating spacer grid.')
c Drops have frozen in node kdrops(nnn,j) or have impacted
c spacer grid in node kdrops(nnn,j).
         if(indmts.eq.1)then
           k=kdrops(nnn,j)
         else
           k=kdrpgs(nnn,j)
         endif
         imdctl(1) = ior(imdctl(1),dmwrite)
         if(ndbg.eq.9)then
         write(inpout,9070)timehy,j,nnn,k
 9070 format(' time =',e12.6,' s;  component no. =',i3,
     & ' axial node of origin =',i3,' current axial node =',i3)
         write(output,9071)tcond3(nrods2(nnn,j),nnn,j)
9071     format(' temperature of axial node from where cladding',
     &   ' slumped =',f6.1,' K')
         end if
c Find composition and masses of each composition before
c drops solidified in node.
         kki=(j-1)*ndax+k
         vrodhp=pi*rpel(kki)**2
         vrsthp=pitch(j)**2-vrodhp
c  Calculate volume average fuel temperature.
         dvsum=0.0
         tmpsum=0.0
         do m=2,nrodes(kki)
           dvrod=pi*(xcond3(m,k,j)**2-xcond3(m-1,k,j)**2)
           dvsum=dvsum+dvrod
           tmpsum=tmpsum+dvrod*0.5*(tcond3(m,k,j)+tcond3(m-1,k,j))
         enddo
         tmpold=tmpsum/dvsum
         ruo2=fden (tmpold,0.0)
         rzr=cden (tmpold)
c  wurod is the mass of UO2 in intact rod per unit length (kg/m).
c  wzrod is the mass of Zr in intact rod per unit length (kg/m).
c  wuslg is the mass of UO2 in space between fuel rods (kg/m).
c  wzslg is the mass of Zr in space between fuel rods (kg/m).
         wurod=ruo2 * vrodhp
         wzrod=rzr * (rcos(j)** 2- rcii(j)**2) * pi
         wuslg=0.0
         wzslg=0.0
         wuo1=wurod*dzcond(kki)
         wzr1=wzrod*dzcond(kki)
c  Calculate volume average fuel temperature.
         dvsum=0.0
         tmpsum=0.0
         do m=2,nrodes(kki)
           dvrod=pi*(xcond3(m,k,j)**2-xcond3(m-1,k,j)**2)
           dvsum=dvsum+dvrod
           tmpsum=tmpsum+dvrod*0.5*(tcond3(m,k,j)+tcond3(m-1,k,j))
         enddo
         tmpold=tmpsum/dvsum
         wzr2=0.0
         wuo22=0.0
         if(indmts.eq.1)then
           wzr2=wzrdrp(nnn,j)*ndrops(nnn,j)
           wuo22=wuodrp(nnn,j)*ndrops(nnn,j)
           tmpnew=tdrops(nnn,j)
         else
           wzr2=(wzgdrp(nnn,j)+windrp(nnn,j))*ndrpgs(nnn,j)
           tmpnew=tdrpgs(nnn,j)
         endif
         wss1=0.0
         if(igrdsp(k,j).eq.1)then
           if(igrinc(k,j).eq.1)then
             wss1=wincl(k,j)
           else
             wzr1=wzr1+wincl(k,j)
           endif
         endif
         wzro1=0.0
         wzro2=0.0
         wag1=0.0
         wag2=0.0
         wss2=0.0
         wsso1=0.0
         wsso2=0.0
         wzruo1=0.0
         wzruo2=0.0
         afru1=0.33333334
         afru2=0.33333334
         afrz1=0.0
         afrz2=0.0
         wbc1=0.0
         wbc2=0.0
c  Calculate equilibrium temperature of mixture.
         call mixtmp(wuo1, wuo22, wzr1, wzr2, wzro1, wzro2, wag1, wag2,
     &   wss1, wss2, wsso1, wsso2, wzruo1, wzruo2, afru1, afru2, afrz1,
     &   afrz2, wbc1, wbc2, tmpold, tmpnew, tmpblk)
         imdctl(1) = ior(imdctl(1),dmwrite)
         if(ndbg.eq.9)then
         write(inpout,9080)tmpold
 9080 format(' avg. temperature of node before material slumped',
     &' into node =',e12.6,' K')
         write(inpout,9090)tmpnew
 9090 format(' temperature of material slumping into node =',e12.6,' K')
         write(inpout,9100)tmpblk
 9100 format(' temperature of node after contact with slumping',
     &' material =',e12.6,' K')
c Set temperatures at each radial node to equilibrium temperature.
         end if
         ndrps1=ndrops(nnn,j)
         if(indmts.eq.2)ndrps1=ndrpgs(nnn,j)
         if(ndbg.eq.9)then
         write(inpout,9110)wuo1,wuo22,wzr1,wzr2
 9110 format(' masses of rod and drop (kg); wuo1=',e10.4, ' wuo22=',e10.
     &4,' wzr1=',e10.4,' wzr2=',e10.4)
         end if
         do  l=1,nrodes(kki)
           tcnd03(l,k,j)=tmpblk
           tcond3(l,k,j)=tmpblk
         enddo
         afrz1=1.
         afru1=0.0
         dencrs=zuden(afrz1, afru1, tmpblk)
         volcs1=(wfrozr(mz-1+k)+wfrouo(mz-1+k)+winfro(k,j))/ dencrs
c  Skip average of characteristics of frozen drops for case of impact
c  with spacer grid.
         if(indmts.eq.2)go to 190
         idrfz2(k,j)=1
c  Since all drops are assumed to have same size, simply increment
c  number of drops at this node by number fo drops that froze during
c  this time step.
         ndrp1=ndrfz1(k,j)
         ndrp2=ndrops(nnn,j)
         ndrp3=ndrp1+ndrp2
cljs     ndrops(nnn,j)=0.0
         idrops(nnn,j)=0
         udrops(k,j)=0.0
cljs   ndrfz2(k,j) now calculated i liqsol.
cljs     ndrfz2(k,j)=ndrp3
         rdrops(k,j)=rdrops(nnn,j)
         wzrdp1=wfzzr2(k,j)
         wzrdp2=wzrdrp(nnn,j)
         wuodp1=wfzuo2(k,j)
         wuodp2=wuodrp(nnn,j)
cljs     wdrfz2(k,j)=(ndrp1*wdrfz2(k,j)+ndrp2*wzrdrp(nnn,j))/ndrp3
cljs     just slumped Zr has not weight gain of oxygen
         wdrfz2(k,j) = ndrp1*wdrfz2(k,j)/ndrp3
cljs   wfzsa2(k,j) applies to spalling, is not averaged over drops.
cljs     wfzsa2(k,j)=(ndrp1*wfzsa2(k,j)+ndrp2*wdrspa(nnn,j))/ndrp3
         wfzsp2(k,j)=(ndrp1*wfzsp2(k,j)+ndrp2*wdspls(nnn,j))/ndrp3
         wfzuo2(k,j)=(ndrp1*wfzuo2(k,j)+ndrp2*wuodrp(nnn,j))/ndrp3
         wfzzr2(k,j)=(ndrp1*wfzzr2(k,j)+ndrp2*wzrdrp(nnn,j))/ndrp3
         wfzzr2(k,j)=wfzzr2(k,j)+wzrdrp(nnn,j)
cljs     fudfz2(k,j)=wfzuo2(k,j)/(wfzuo2(k,j)+wfzzr2(k,j) +
cljs &   twopi*rdrops(k,j)*wdrfz2(k,j))
cljs     hfzox2(k,j)=(1.-fudfz2(k,j))*(6.45e+6)*(91.22/32.)+
cljs &   fudfz2(k,j)*(1.84e+5)*(810./32.)
         pdrfz2(k,j)=pdrfz2(k,j)+powadd(nnn,j)
         fadrop(k,j)=(ndrfz2(k,j)*2.*pi*rdrops(k,j)**2)/
     &   (2.*pi*rco(mz+k-1)*dzcond(mz+k-1))
c  Compute average characteristics of frozen drops at this location
c  accounting for mixing together of previously frozen drops with those
c  that froze during this time step.
  190    continue
c  Because temperature jump due to material relocation is directly
c  calculated now, zero out internal energy of relocated material.
         hadd(mz-1+k)=0.0
         haddnw(k,j)=0.0
         kdynn=(j-1)*ndax+nnn
         powad2=powadd(nnn,j)
         if (nspowi.eq.3 .or. nspowi.eq.1) then
           powad2 = powtot(1)*powad2
         endif
c  Area of fuel pellet in call to nheat now modified to reflect
c  removal of material due to slumping, so deactivate line below.
         powad2=powad2/dzcond(kki)
cljs  end of do loop with "go to 150" at start
       enddo
c  Fraction of surface area that is covered with drops of relocated
c  material.
       do k=1,naz
         fadrop(k,icomp)=(ndrfz2(k,icomp)*twopi*rdrops(k,icomp)**2)/
     &   (twopi*rco2(k,icomp)*dzcnd2(k,icomp)) + fadrpg(k,icomp)
         fadrop(k,icomp)=min(fadrop(k,icomp),5.0)
       enddo
c  calculate heat generation from oxidation of spacer grid and cohesive
c  debris.  If cohesive debris, then spacer grid is assumed to not
c  oxidize.
       do 240 k=1,naz
         nsw=0
         hgcoh1=0.0
         qcohst(k,j)=0.0
         if(tcond3(nrodes(kki),k,j).lt.1000.0)go to 240
         if(wgbott(k,j).gt.1.e-10.and.wfrozr(kki).gt.1.e-3) nsw=1
         if(nsw.eq.0)go to 210
         ceffzr=coxwtk(tcond3(nrodes(kki),k,j))
c  Next, obtain oxidation kinetics equation for UO2.
         ceffuo=24.4*exp(-26241./tcond3(nrodes(kki),k,j))
c  Calculate effective oxidation kinetics constant.
         ceff=(1.-fucoht(k,j))*ceffzr + fucoht(k,j)*ceffuo
c  Calculate change in weight gain.
         wgtop(k,j)=sqrt(wgtopz(k,j)**2+ceff*dt)
c  Limit weight gain to maximum allowed by mass diffusion.
         nshap=0
         call oxydef(oxlis0,k,nshap)
         wmxdif=oxlis0*dt+wgtopz(k,j)
         if(wgtop(k,j).gt.wmxdif)wgtop(k,j)=wmxdif
         if(wgtop(k,j).gt.wgcoht(k,j))wgtop(k,j)=wgcoht(k,j)
c  Calculate heat generation per unit surface area.
         qdkns=hefctp(k,j)*(wgtop(k,j)-wgtopz(k,j))/dt
c  Calculate total heat generation due to oxidation for top surface of
c  cohesive debris.
         qtotox=(pitch(j)**2-pi*rco(kki)**2)*qdkns/dzcond(kki)
         qcohst(k,j)=qcohst(k,j)+qtotox
         qoxcht(k,j)=qoxcht(k,j)+qtotox
         area1=(pitch(j)**2-pi*rco(kki)**2)
         hgcoh1=hgcoh1+area1*(wgtop(k,j)-wgtopz(k,j))/(8.*dt)
         if(hgcoh1.lt.0.0)hgcoh1=0.0
c  Calculate heatup from oxidation of bottom surface.
         ceff=(1.-fucohb(k,j))*ceffzr + fucohb(k,j)*ceffuo
c  Calculate change in weight gain.
         wgbot(k,j)=sqrt(wgbotz(k,j)**2+ceff*dt)
c  Limit weight gain to maximum allowed by mass diffusion.
         wmxdif=oxlis0*dt+wgbotz(k,j)
         if(wgbot(k,j).gt.wmxdif)wgbot(k,j)=wmxdif
         if(wgbot(k,j).gt.wgbott(k,j))wgbot(k,j)=wgbott(k,j)
c  Calculate heat generation per unit surface area.
         qdkns=hefcbt(k,j)*(wgbot(k,j)-wgbotz(k,j))/dt
c  Calculate total heat generation due to oxidation for bottom surface
c  of cohesive debris.
         qtotox=(pitch(j)**2-pi*rco(kki)**2)*qdkns/dzcond(kki)
         qcohst(k,j)=qcohst(k,j)+qtotox
         qoxchb(k,j)=qoxchb(k,j)+qtotox
         area1=(pitch(j)**2-pi*rco(kki)**2)
         hgcoh1=hgcoh1+area1*(wgbot(k,j)-wgbotz(k,j))/(8.*dt)
         if(hgcoh1.lt.0.0)hgcoh1=0.0
         go to 220
  210    continue
c  Check for oxidation of Zr spacer grid.
         if(igrdsp(k,j).ne.1)go to 240
         if(igrinc(k,j).ne.0)go to 240
         ceffzr=coxwtk(tcond3(nrodes(kki),k,j))
         wgrd(k,j)=sqrt(wgrdz(k,j)** 2+ ceffzr*dt)
c Limit weight gain to maximum allowed by mass diffusion.
         nshap=0
         call oxydef(oxlis0,k,nshap)
         wmxdif=oxlis0*dt+wgrdz(k,j)
         if(wgrd(k,j).gt.wmxdif)wgrd(k,j)=wmxdif
         area1=4.*pitch(j)*thincl(k,j)
c  Spacer grid oxidizes from both sides; so multiply by 0.5 for per rod
c  basis.
         wmxwtg=0.5*(32./91.22)*wincl(k,j)/area1
         if(wgrd(k,j).gt.wmxwtg)wgrd(k,j)=wmxwtg
         qdkns=(6.45e+6)*(91.22/32.)*(wgrd(k,j)-wgrdz(k,j))/dt
         qtotox=area1*qdkns/dzcond(kki)
         qcohst(k,j)=qcohst(k,j)+qtotox
         qgrdox(k,j)=qgrdox(k,j)+qtotox
         hgcoh1=hgcoh1+area1*(wgrd(k,j)-wgrdz(k,j))/(8.*dt)
         if(hgcoh1.lt.0.0)hgcoh1=0.0
  220    continue
cljs     hgcohs(k,j)=hgcoh1
         hgdeb(i,j)=max(hgdeb(i,j),0.0)
c  Calculate production of hydrogen due to oxidation of grid spacer and
c  cohesive debris.
         if(.not.scntrl(8))then
           ivol=nvad((j-1)*ndax+k)+filndx(4)
c  Update hydrogen source term for RELAP5.
           do in=1,noncn
             if (in .ne. nonhy) cycle
             iln=ivol + in - 1
             gaman(iln)=gaman(iln)+ recipv(ivol)*hgcoh1*float(isgl)
             if(gaman(iln).lt.0.0) gaman(iln)=0.0
             enthn(iln)=uo+co*tcond3(nrodes(kki),k,j)+ do/2.0*
     &       (tcond3(nrodes(kki),k,j)-tao)**2
           enddo
         endif
  240  continue
c  nswqch = switch to model liquified zr.u.o to immediately quench and
c  evaporate water when it contacts pool of water in fuel bundle.
c  0 = no
c  1 = yes
       wdtqlp(icomp)=float(nsigl1)*haddbt
       nswqch=0
       if(nswqch.eq.1)then
c  Store amount of thermal energy in liquified material which solidified
c  in bundle.
         do k=1,naz
           ztop=zcond(mz-1+k)+0.5*dzcond(mz-1+k)
           if(hadd(mz-1+k).gt.1.e-10.and.ztop.le.z2phas)then
             qchlbn(k,icomp)=qchlbn(k,icomp) + float(nsigl1)*hadd
     &       (mz-1+k)
             hadd(mz-1+k)=1.0
           endif
         enddo
       endif
c  Determine which axial node may have made transition from rod-like
c  geometry to rubble debris during time step.
c
c  Store saturation temperature at bottom of core.
       nvolin=inv+filndx(4)
       tsat=satt(nvolin)
c  If electrical-heated test being analyzed, do not initiate
c  late-phase melt progression models; do not call rubtrn.
       nswexp=0
c  If more than one flow channel or power calculated using RELAP5
c  reactor kinetic package, then call debris formation models.
c  This protection needed to prevent case of location being flagged as
c  debris when bundle power is high; with SCDAP power tables the power
c  at any location flagged as debris stays equal to the power at that
c  location at instant of debris.  With RELAP5 kinetic package, power
c  at location with debris changs with time.
       if(igp.eq.1.and.(nspowi.ne.3.and.nspowi.ne.1))nswexp=1
       if(.not.cora.and.nswexp.eq.0)then
         call rubtrn(j,tsat)
       else
         do k=1,naz
c  Set default values for solidus and liquidus temperatures for case of
c  rubtrn not being called to compute these values.
           tmlsol(k,j)=2830.0
           tmlliq(k,j)=2873.0
         enddo
       endif
       do k=1,naz
         if(irubpp(k,j).eq.1.or.nhrdpn(j).eq.k)then
           kki=(j-1)*ndax+k
           dzfrcl(kki)=dzfrcq(k,j)
           idebcm(j)=1
           ibrch(j)=0
         endif
       enddo
c  Set ibrch to node number of breach.
       call brchsw (nfi(mz),ifrag(mz),naz,ibrch(j))
c  Set flag if x-sectional area for balooning exceeded.
       call mxarea (naz,rocrst(mz),pitch(j),iareax)
c  Do not call cladding deformation model if temperatures out of range,
c  no area left in which to deform, disruption has already taken place
c  (any of 3 types of disruption)
       if ( izrt .eq. 0.and. idsrup(j) .eq. 0.and. ii(j) .eq. 0.and
     & .iareax.eq. 0.and.idebcm(j).eq. 0.and. ibrch(j) .eq. 0) then
         call clddfm (naz,nrcldi(mz),nrcond(mz),nrodes(mz),dt,
     &   dt,dtemp,dzcond(mz),ggivy(1,j),hfix(mz),ii(j),jiter,
     &   oxdhc, pcool,pgas(j),pitch(j),rci(mz),rcoi(mz),rcii(j),
     &   rcos(j),rl(j),tcolc(mz),tcond(n),timec,vplen(j),xcond(n),
     &   zcond(mz),vfvod(mz),hoop(mz),icladf(j),dtmxn,pcool0,pgas0,
     &   rpel(mz),tcond0(n),vtvod,qclad(mz),qout2(1,icomp,1),rfarc(1,j),
     &   iareax,ncrum(mz))
c  Reset all radii reference points if ballooning occurs to the moving
c  rcoi. Volume is conserved.
cljs Warning; why is rcoi() used instead of rco2()? Current coding
cljs can result in negative oxide thickness. rcoi(mz)=rcoi2(k,j)
cljs  testing
cljs  rcoi(mz-1+i) = end of time step outer radius of of oxide layer 
cljs                 after ballooning calculated.                
clljs                But subroutine oxidiz does not appear to update
cljs                 rcoi.
cljs   rco(mz-1+i) = outer radius of cladding, including oxide layer.
cljs  rcox(i) = end of time step outer radius of oxide layery after
cljs            oxidiz called but  before ballooning called.
cljs            right after oxidiz called, rcox(i) = rcoi(mz-1+i)
cljs   rfix(a,b,c) = sqrt(a*a-b*b+c*c)
cljs   a=start of time step value for a radius, 
cljs   b=value before ballooing of radius of oxide layer, 
cljs   c=value after ballooning of radius of oxide layer
cljs   rfix=value after ballooning of a radius accounting for
cljs        conservation of volume.
         do i=1,naz
           if(nsoxar.eq.0)then
           rocrst(mz-1+i)=rfix(rocrst(mz-1+i),rcox(i),rcoi(mz-1+i))
cljs       rocrmx(mz-1+i)=rfix(rocrmx(mz-1+i),rcox(i),rcoi(mz-1+i))
           rocrmx(mz-1+i) = rocrst(mz-1+i)
            rco(mz-1+i)=rfix(rco(mz-1+i),rcox(i),rcoi(mz-1+i))
           radus1=rnoxd(mz-1+i)
           rnoxd(mz-1+i)=rfix(rnoxd(mz-1+i),rcox(i),rcoi(mz-1+i))
           oxdeo(mz-1+i)=rco(mz-1+i) - rnoxd(mz-1+i)
cljs  for case of nsoxar = 2, oxide thinning due to ballooning not taken
cljs  into account.
           elseif(nsoxar.eq.1)then
           rnalf(mz-1+i) = rnoxd(mz-1+i)
           alfao(mz-1+i) = 0.0
           rcox(i)=rcoi(mz-1+i)
           arga=rco(mz-1+i)
           argb=rcox(i)
           argc=rcoi(mz-1+i)
           rotest=rfix(arga,argb,argc)
           arga=rnoxd(mz-1+i)
           argb=rcox(i)
           argc=rcoi(mz-1+i)
           rntest=rfix(arga,argb,argc)
           oxtest=rotest-rntest
             rco(mz-1+i)=rotest
             rnoxd(mz-1+i)=rntest
             oxdeo(mz-1+i)=oxtest
             rocrst(mz-1+i)=rco(mz-1+i)
             rocrmx(mz-1+i)=rocrst(mz-1+i)
c          end if
c end testing
           end if
         enddo
c initialized these variables for *fstate* if *freloc* no longer being
c called.
         do i=1,naz
           voidfr(i)=0.0
           ncrum(mz-1+i)=0
         enddo
       endif
c  If breach has just now occurred, set flag to breach node.
       if ( ibrch(j) .eq. 0) then
         if(icladf(j) .ne. 0) then
           ibrch(j)=ii(j)
         endif
       endif
c  If cladding deformation model no longer called due to high temps.,
c  set total void for gas pressure model.
       if ((( izrt.gt.0.or.iareax.gt.0) .and. ibrch(j).eq.0) .or.
     & icladf(j) .eq. 0) then
         do i=1,naz
           vtvod(i)=pi*(rci2(i,icomp)**2-rcii(j)**2) *
     &       dzcnd2(i,icomp)+vfvod(mz-1+i)
           vtvod(i)=max(vtvod(i),0.0)
         enddo
       endif
c  Calculate gas inventory in gm moles.
       gasms=gasmol (ggivy(1,j), ibrch(j) ,idsrup(j) )
c  Calculate internal gas pressure.
       nsswth=0
c  Calculate temperature of fluid at top axial node.
       nvolin=nvad((j-1)*ndax+naz)+filndx(4)
       tfluid=tempg(nvolin)
       if(voidg(nvolin).lt.0.1)tfluid=tempf(nvolin)
c  To avoid jump in plenue temperature when fluid void fraction exceeds
c  0.5, set fluid temperature to surace temperature of cladding at top
c  axial node.
       tfluid=tcond3(nrodes(mz-1+naz),naz,j)
       call fpress (gasms,vtvod)
       call fstate (xdeltz,roliq,tzr)
c  Calculate nuclear heat generation.
       do k=1,naz
         apel0(k)=pi*rpel((j-1)*ndax+k)**2
         if(wremzr(mz+k-1).gt.1.e-10)then
           if(fdrmn2(k,j).lt.(1.0-0.001))then
             adiss=fdrmn2(k,j)*(apel0(k)-pi*ruliq(mz+k-1)**2)
             apel0(k)=apel0(k)-adiss
           else
             apel0(k) = pi*ruliq(mz+k-1)**2
           endif
c  Calculate volume of removed fuel.
         endif
       enddo
       call nheat (apel0, 0, afrel)
       qfrel = afrel
       do k = 1,naz
         unucgm(k,j) = fracgm*unuc(k)
         if (rpel((j-1)*ndax+k) .lt. 0.2e-3) unucgm(k,j) = 0.0
         unuc(k)=unuc(k) - unucgm(k,j)
       enddo
       call rlockf (ncrum(mz),rci(mz),naz,voidfr,rlcnda)
c  Calculate temperature for all intact nodes.
       icoht(j) = 0
       icohb(j) = 0
       do i = 1,naz
c  At locations with debris or molten material, heat transfer
c  coefficients and radiation heat transfer have not been defined by
c  call to HTRC1 in SCDAD3, so set to zero here.
         if (irubpp(i,j).eq.1 .or. lcrucb(i,j).ge.1) then
           kki = (j - 1)*ndax + i
           hfixf(kki) = 0.0
           hfixg(kki) = 0.0
           scd22(i,j,1,1)%qrdsur = 0.0
         endif
       enddo
c     kmid1 = mid-plane axial node
       kmid1 = naz/2 +1
       do i=1,naz
c  Skip over axial nodes that are cohesive or rubble debris.
         if (irubpp(i,j).eq. 1.or. lcrucb(i,j).ge.1) then
           go to 400
         endif
         kaxndb=i
         call pmass( wuo2(i), wzr(i), epsz, wz, wx )
c  Update radial mesh.
         call meshgn (nrcldi(mz-1+i), nrodes(mz-1+i), rci(mz-1+i),
     &   rco(mz-1+i), xcond3(1,i,j))
         rlcond=rlcnda( i )
         inaz=i
         kx=mz + i - 1
c  Calculate conductance of fuel-cladding gap. The calculation modifies
c  the input steady-state conductance to account for ballooning of the
c  cladding and radiation heat transfer.
c  If gap conductance input, acond array stores it. If not, acond array
c  stores factor on thermal conductivity, which is a number near unity.
         if(acond(kx).lt.5.0)then
           acond1=0.0
         else
           hgapss=acond(kx)
           acond1=hgapss
           do ll=1,10
             gmix(ll)=0.0
           enddo
c  Since information not available that defines mole fractions of gas in
c  fuel-cladding gap, define mixture to be 100% He.
           gmix(1)=1.
           drgap=rci(kx)-rcii(j)
           if(drgap.gt.1.e-5)then
c  calculate temperature of gas in fuel cladding gap.
c  Note. nrcond=radial node number of pellet surface, nrcldi=node at
c  cladding inner surface.
             tmpgap = 0.5*(tcond3(nrcond(mz+i-1),i,j) +
     &       tcond3(nrcldi(mz+i-1),i,j))
             hgaptr=gascns(gmix,tmpgap,pgas(j))/drgap
c  Add on radiation heat transfer component emissivity factor femiss is
c  assumed to equal 1.
             femiss=1.
             hgprad=sigbsr*femiss*((tcond3(nrcond(mz+i-1),i,j)**2+
     &       tcond3(nrcldi(mz+i-1),i,j)**2)*
     &       (tcond3(nrcond(mz+i-1),i,j)+ tcond3(nrcldi(mz+i-1),i,j)))
             hgaptr=hgaptr+hgprad
             acond1=hgaptr
             if(acond1.gt.hgapss)acond1=hgapss
           endif
         endif
  400    continue
         if (irubpp(i,j).eq.0 .and. lcrucb(i,j).eq.0) then
c  Add to oxdhc(i) the heat input to fuel rod by drops of relocating
c  material, and spacer grid oxidation.
           qcldtt=oxdhc(i)+qcdrps(i,j)+qcdrgs(i,j)+qgrdox(i,j)+
     &     qoxcht(i,j)+qoxchb(i,j)
           if(modidx(1).ne.1)then
           call effht (0.0,qcldtt,rpel(kx),ruliq(kx),rci(kx),unuc(i),
     &     effcp(1,i), effcpc(i), effgen(1,i), effk (1,i), effkc(i),
     &     effkf(i), rcii(icomp), acond1, kx)
           else
           call effhts(qcldtt,unuc(i),effcp(1,i),
     &     effgen(1,i), effk (1,i), kx)
           end if
         if(i.eq.kmid1)then
c     store effective properties and heat generation rate at mid-plane
c     axial node
           do mm = 1,numelm2(i,j)
           effgn1(mm,j) = effgen(mm,i)
           effk1(mm,j) = effk(mm,i)
           effcp1(mm,j) = effcp(mm,i)
           end do
         end if
         else
c  Since temperature solution at nodes with debris or molten material
c  are calculated by other models and not by HEATC2, just calculate
c  dummy effective properties for these nodes.
           nelm=numelm(mz+i-1)
           do ir=1,nelm
             effk (ir,i)=1.00
             effcp (ir,i)=1.e+6
             effgen(ir,i)=0.0
           enddo
         endif
       enddo
       if(j.ne.ncmths)then
       call heatc2 (j,effk,effcp,effgen,nvirn)
       else
cljs  obtain temperature of component from RELAP5 table
       itab=ntbths
       timen = timehy
       if(timen.ne.gen(itab)%gtarg)then
       call gtpolat(gen(itab)%gtinfo,gtptr(itab)%gtbl,timen,
     &  pwrtotl(1:1),err)
         tempn = pwrtotl(1)
         gen(itab)%gtarg = timen
         gen(itab)%gtval(1) = tempn
         else
         tempn=gen(itab)%gtval(1)
         end if
          do i =1,naz
            do l=1,nrodes(mz+i-1)
             tcond3(l,i,j) = tempn
             tcnd03(l,i,j) = tempn
            end do
          end do
       end if
c  If component is representing a water rod (fuel rod without fuel),
c  then apply limit to its maximum temperature after meltdown occurs.
       afraco=0.0
       afracu=0.0
       afracz=1.0
       tzrmlt=pliq(afraco,afracu,afracz)
       do i = 1,naz
         if (rpel(mz+i-1).lt.0.21e-3 .and.
     &   tcond3(nrodes(mz+i-1),i,j).gt.tzrmlt .and.
     &   tcond3(nrodes(mz+i-1),i,j).gt.tcolc(mz+i-1) .and.
     &   idcomp(j).eq.0) then
           do l=1,nrodes(mz+i-1)
             tcond3(l,i,j)=tcolc(mz+i-1)
             tcnd03(l,i,j)=tcolc(mz+i-1)
           enddo
         endif
       enddo
       do i=1,naz
c  Calculate temperature at nodes with rubble debris.
         if(irubpp(i,j).eq.0) cycle
c  If natural circulation of liquefied debris, bypass call to heatdb.
         if(lcrucb(i,j).ge.1) cycle
         call heatdb(i,j,dt,tsat)
         hgdeb(i,j)=max(hgdeb(i,j),0.0)
         if(.not.scntrl(8))then
           ivol=nvad((j-1)*ndax+i)+filndx(4)
c update hydrogen source term for RELAP5.
           do in=1,noncn
             if (in .ne. nonhy) cycle
             iln=ivol + in - 1
             gaman(iln)=gaman(iln)+recipv(ivol)*hgdeb(i,j)*float(isgl)
             if(gaman(iln).lt.0.0) gaman(iln)=0.0
             enthn(iln)=uo+co*tcond3(nrodes(kki),k,j)+ do/2.0*
     &       (tcond3(nrodes(kki),k,j)-tao)**2
           enddo
         endif
       enddo
c  Note. HEATC2 tempertures for nodes with molten material are
c  overridden by values calculated in subroutine HEATLD.
       jiter=1
       do i = 1,naz
         nelm=numelm(mz+i-1)
         do ir = 1,nelm
           avir(ir,i) = pi*dzcond(mz+i-1)*(xcond3(ir+1,i,j) +
     &     xcond3(ir,i,j))*(xcond3(ir+1,i,j) - xcond3(ir,i,j))
         enddo
       enddo
       do i=1,naz
         nelm=numelm(mz+i-1)
         do ir=1,nelm
           qstor(j)=qstor(j) + effcp(ir,i)*avir(ir,i)*
     &     0.5*((tcond3(ir+1,i,j)+tcond3(ir,i,j)) -
     &     (tcnd03(ir+1,i,j)+ tcnd03(ir,i,j)) )*nsigl(j)
           qedt(j)=qedt(j) + effgen(ir,i)*avir(ir,i)*dt*nsigl(j)
         enddo
         qodt(j)=qodt(j)+(oxdhc(i)+oxdhf(i))*dzcond(mz+i-1)*dt*nsigl(j)
         qndt(j)=qndt(j) + unuc(i)*dzcond(mz+i-1)*dt*nsigl(j)
         qsdt(j)=qodt(j) + qndt(j)
       enddo
       if (qstor0(j) .eq. 0.0) then
c  Calculate initial stored energy.
         do i = 1,naz
           do ir = 1,numelm(mz+i-1)
             qstor0(j) = qstor0(j) + effcp(ir,i)*avir(ir,i)*
     &       (tcnd03(ir+1,i,j) + tcnd03(ir,i,j))
           enddo
         enddo
         qstor0(j)=qstor0(j) * 0. 5* nsigl(j)
       endif
c  Set converged, shufled arrays.
       itrflg=2
       call shufl (dzcond(mz),dzfrac(m2),dzfrac(m2+ndax),fgrj(1,j),
     & fpivrt(1,j),fpivy(1,j),movesw(mz),naz,ndisrp(mz),tfgrj,
     & tfpivr,tfpivy,zcond(mz),ci(nn15),acae(mz),prf(mz),gsg(nn5),
     & gou(nn6),dis(nn16),sv(nn4),taca,tprf,tgsg,tgou,tdis,tsav,tcik,
     & itrflg)
       do i=1,naz
         movesw(mz-1+i)=0
       enddo
       if(.not.scntrl(9))then
         call mxctmp(naz,tsur,izrt,pcool,pgas(j),rci(mz),rco(mz))
         if(izrt.eq.1)then
           itmpmx=1
           tmpfmx=0.0
           do i=1,naz
             if(tcond3(nrodes(mz-1+naz),i,j).gt.tmpfmx)then
               tmpfmx=tcond3(nrodes(mz-1+naz),i,j)
               itmpmx=i
             endif
           enddo
c  See subroutine mxctmp for basis of 1900.
           if(tmpfmx.ge.1900.and.ibrch(j).eq.0)then
             ii(j)=itmpmx
cljs         icladf(j)=1
cljs         imdctl(1) = ior(imdctl(1),dmwrite)
cljs         write (inpout,"('0-------- Core degradation',es14.6,' s: Fa
cljs &ilure of cladding due to high temperature under compression loadin
cljs &g, component ',i3,' axial node',i3)") timehy,i,scd1(icomp)%cmpno
cljs         write (inpout,9010) tmpfmx
           endif
         endif
         if (afuel(mz) .lt. 1.0e-07) izrt=1
       else
         izrt=1
       endif
       if(izrt.eq.0 .and. idsrup(j).eq.0.and. ibrch(j).eq.0)then
         call clddfm (naz,nrcldi(mz),nrcond(mz),nrodes(mz),dt,
     &   dt, dtemp,dzcond(mz),ggivy(1,j),hfix(mz),ii(j),jiter,
     &   oxdhc,pcool,pgas(j),pitch(j),rci(mz),rcoi(mz),rcii(j),
     &   rcos(j),rl(j),tcolc(mz),tcond(n),timec,vplen(j),xcond(n),
     &   zcond(mz),vfvod(mz),hoop(mz),icladf(j),dtmxn,pcool0,pgas0,
     &   rpel(mz),tcond0(n),vtvod,qclad(mz),qout2(1,icomp,1),rfarc(1,j),
     &   iareax,ncrum(mz))
         do i=1,naz
           if(nsoxar.eq.0)then
           rocrst(mz-1+i)=rfix(rocrst(mz-1+i),rcox(i),rcoi(mz-1+i))
cljs       rocrmx(mz-1+i)=rfix(rocrmx(mz-1+i),rcox(i),rcoi(mz-1+i))
           rocrmx(mz-1+i)=rocrst(mz-1+i)
           rco(mz-1+i)=rfix(rco(mz-1+i),rcox(i),rcoi(mz-1+i))
           radus1=rnoxd(mz-1+i)
           rnoxd(mz-1+i)=rfix(rnoxd(mz-1+i),rcox(i),rcoi(mz-1+i))
           oxdeo(mz-1+i)=rco(mz-1+i) - rnoxd(mz-1+i)
           elseif(nsoxar.eq.1)then
           rnalf(mz-1+i) = rnoxd(mz-1+i)
           alfao(mz-1+i) = 0.0
           rcox(i) = rcoi(mz-1+i)
           arga=rco(mz-1+i)
           argb=rcox(i)
           argc=rcoi(mz-1+i)
           rotest=rfix(arga,argb,argc)
           arga=rnoxd(mz-1+i)
           argb=rcox(i)
           argc=rcoi(mz-1+i)
           rntest=rfix(arga,argb,argc)
           oxtest=rotest-rntest
           rco(mz-1+i)=rotest
           rnoxd(mz-1+i)=rntest
           oxdeo(mz-1+i)=oxtest
           rocrst(mz-1+i)=rco(mz-1+i)
           rocrmx(mz-1+i)=rocrst(mz-1+i)
           end if
         enddo
         call fstate(xdeltz,roliq,tzr)
         do i=1,naz
           movesw(mz-1+i)=0
         enddo
       endif
c  Calculate transient fission product release from fuel.
       itran=1
       if (afuel(mz) .gt. 1.0e-07) then
         call fgrelh(dt,naz,tcond(n),xcond(n),nrcond(mz),fpivy(1,j),
     &    fpivrt(1,j),fparyc(1,j),fgrj(1,j),fgr(1,j), fpary(1,j),
     &    ndisrp(mz),dzcond(mz),fulden(j),pgas(j), ruliq(mz),ruliq0,
     &    ruomlt(mz),rumlt0,powtot(icomp), paxpz(1,1,j),kshapz(j),
     &    afuel(mz),grain(n),ci(nn15),acae(mz),prf(mz),gsg(nn5),
     &    gou(nn6),dis(nn16),sv(nn4),dlmo(nn4),ato(nn4),tliqs(mz),
     &    tcap(mz),grira(nn5),hh(mz),tkgs(mz),vlm(mz),kraph(j),itran,
     &    buk(mz),rxd(nn4),fgrmgo(mz), iliq(mz),cc(nn5),noxide(mz))
       endif
c  If break occurred, determine what portion of cladding will be
c  oxidized on inside surface.
       if (icladf(j).gt.0) then
         do i=1,naz
           if(hoop(mz+i-1).gt.epsox2) brchv(i,j)=1.0
c  Model double-sided oxidation after reflood.
c          ivol=nvad((j-1)*ndax+i)+filndx(4)
c          if(voidf(ivol).ge.0.001)brchv(i,j)=1.0
         enddo
       endif
c  If burst just occurred, set breach flag, gap temp. and width.
       if (icladf(j).gt. 0.and. ibrch(j).eq.0)ibrch(j)=ii(j)
       if(ibrch(j) .gt. 0) then
         tgapbr=tcond3(nrcond(mz-1+ibrch(j)),ibrch(j),j)
         wgapbr=rci(mz-1+ibrch(j)) - rpel(mz-1+ibrch(j))
       else
         tgapbr=0.0
         wgapbr=0.0
       endif
c  Calculate fission gas released into the coolant.
       call fgrelg (dt,dzcond(mz),fpary(1,j),ibrch(j),ibrch0,idsrup(j),
     & naz,pcool,rci(mz),rdlnth(j),tgapbr,wgapbr, ggivy(1,j),
     & ggrel(1,j), gasms, ggrelh(j), ggrelr(j), gsrelh(j), gsrelr(j),
     & powfdk(icomp),timec,tshtdn(j),dtfail,ndkset,vfueli(j),
     & fpivyi(j),dkgrel(j),dksrel(j),trbun(j),gs1bn(j),gs2bn(j),
     & gs3bn(j),gs4bn(j),gs5bn(j),gs6bn(j))
c  Remove grid spacers which have exceeded the melt temp.
       call gridsc
c  Assess the component damage state.
       call cfdamg (denuo2,dzcond(mz),naz,rco(mz),rnoxd(mz),zoxden,
     & vfuel(m2),wbotuo(j),wbotzr(j),wfrouo(mz),wfrozr(mz),oxdwz,
     & oxdwf(mz),wremuo(mz),wremzr(mz),wuobng(mz),wuo2,wzobng(mz),
     & wzrbng(mz),ndisrp(mz),wuorem(mz),wuomlt(mz),nuflg,nzrflg,
     & uo2ms(mz),uo2nm(mz),zrms(mz),zro2ms(mz))
c  If burst just occurred, set breach flag to burst node.
       if(icladf(j).gt. 0.and. ibrch(j).eq.0)ibrch(j)=ii(j)
       timec=timec + dt
       do i=1,naz
         if(wzr(i).gt.1.e-10)
     &    call atomfr (wuo2(i),wzr(i),oxdwz(i),afracu,afracz,afraco)
       enddo
c  Zero out this fission gas array for debris.
       do i=1,16
         fpary(i,j)=0.
       enddo
c  Reset dzfrac,vfuel.
       do i=1,naz
         dzfrac(m2-1+ndax+i)=dzfrac(m2-1+i)
         vfuel(m2-1+ndax+i)=vfuel(m2-1+i)
       enddo
c  Compute average thermal properties and stored energy for component.
       call efprop (effcp,effk,effgen,naz,ngeom(j),numelm(mz),
     & tcond(n),xcond(n),6,10,ifrag(mz),efrcpa(1,icomp),
     & effka(1,icomp),efgena(1,icomp),efstor(1,icomp),
     & efstr0(1,icomp), tcond0(n) )
c  If no aerosol transport calculation has been specified, then.
       if (filid(34) .eq. 0.0) return
       call fpspix ('Sn  ', nsn)
       if (nsn. eq. 0) return
       i34=filndx(34)
       ispo=i34 + (nsn-1)*fpspvk(i34)
c  Calculate release of tin from cladding.
       do i = 1, naz
         mdyn=ndax*(j-1)+i
         tcld=tcond3(nrodes(mz-1+i),i,j)
         if(tcld.lt.1000.) cycle
         if(int(crucb).eq.1) cycle
         if(fpstt(j,i,1).lt.1.e-12) cycle
c  Calculate volume of oxidized cladding.
         vzira=pi*dzcond(mdyn)*(rnoxd(mdyn)**2-rci(mdyn)**2)
         azira=2.*pi*rnoxd(mdyn)*dzcond(mdyn)
         snrem=fpstt(j,i,1)
         isp=nvhydf(j,i) + ispo
c  Calculate relap5 volume index.
         nvolin=nvad((j-1)*ndax+i)+filndx(4)
c  Get concentration of tin in vapor state in coolant.
         call tinr(tcld,vzira,azira,snrem,fpvap(isp),tcolc(mdyn),pcool,
     &   snrelr, nvolin, ierr, iwarn)
         if(ierr.gt.0)then
c Print to check indexes.
           write (output,9120)ierr
 9120 format('fuelan Error in subroutine tinr, ierr=',i5)
           fail=.true.
         endif
c Update inventory to account for release.
         fpstt(j,i,1)=fpstt(j,i,1)-snrelr*dt
         fnsigl=float(nsigl(j))
         fpsrc(isp)=fnsigl*snrelr+fpsrc(isp)
       enddo
       return
       end
*endif
