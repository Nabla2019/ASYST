*mlist
*if def,selap
       subroutine effht (pzroi,pzroo,rpltc,ruliql,rzroi,unuc,effcp,
     & effcpc,effgen,effk,effkc,effkf,rcldi0,acond1,kx)
!  Computes effective material properties and effective volumetric heat
!  generation for finite element heat conduction solution.
!
!  Cognizant engineer: ljs.
!
       implicit none
       integer, parameter :: kr=selected_real_kind(12,200)
       include 'scddat.h'
       include 'scdout.h'
       include 'cons.h'
       include 'intcom.h'
       include 'iocom.h'
       include 'miscon.h'
       include 'ndxara.h'
       include 'nhtara.h'
       include 'scdcom.h'
       include 'tblsp.h'
       include 'ufiles.h'
       include 'contrl.h'
       include 'fecom.h'
       include 'eht0.h'
       include 'dbacct.h'
!
!  Input variables.
!  puliq     Power generated by dissolution of uo2 at r=ruliql (w/m).
!  pzroi     Power generated at inner zr-o2 reaction front in cladding
!            at r=rzroi (W/m).
!  pzroo     Power generated at outer zr-o2 reaction front in cladding
!            at r=rnoxd (W/m).
!  rci       Radius of phase-change (melting/freezing) front (m).
!  rpltc     Cold outer radius of fuel pellet (m).
!  ruliql    Inner radius of liquified material,i.e., uo2 dissolution
!            front (m).
!  rzroi     Distance of inner zr-o2 reaction front in cladding from
!            component center (m).
!  rnoxd     Distance of outer zr-o2 reaction front in cladding from
!            component center (m) - equivalent to rnoxd.
!  unuc      Average linear nuclear heat generation in fuel region
!            (w/m).
!  acond1    Gap conductance (W/m2-K).
!
!  Output variables.
!  effcp     Effective volumetric heat capacity (J/m3-K).
!  effcpc    Effective volumetric heat capacity in cladding (J/m3-K).
!  effcpf    Effective volumetric heat capacity in fuel (J/m3-K).
!  effgen    Effective volumetric heat generation (W/m3).
!  effk      Effective thermal conductivity (W/m-K).
!  effkc     Effective thermal conductivity in cladding (W/m-K).
!  effkf     Effective thermal conductivity in fuel (W/m-K).
!  effqf     Effective volumetric heat generation (W/m3) in fuel region.
!
!  Local variables
!  inkl      Integral of inverse thermal conductivity over the
!            temperature interval of a material layer within element
!            (m-K2/W)
!  inrcl     Integral of volumetric heat capacity over the temperature
!            interval of a material layer within an element (J/m3).
!  kl        Inverse thermal conductivities at the two intervals of each
!            material layer within an element (m-K/W).
!  rcl       Volumetric heat capacities at the two interfaces of each
!            material layer within an element (J/m3-K).
!  nlay      1. number of material layers within a heat conducting
!               element.
!            2. material indicators for the material layers within a
!               heat conduction element.
!  xlay      Outer radii of material layers within the heat conduction
!            elements (m).
!
!  dtph2     Temperature interval over which a phase change occurs (K).
!  hf        Volumetric heat of fusion of zircaloy (J/m3).
!  acond     Burnup-dependent correction factor for fuel thermal
!            conductivity.
!  rlcond    Correction factor for fuel thermal conductivity due to fuel
!            relocation.
!  afulq     Atomic fraction uranium in liquid zr-u-o compound (atoms
!            uranium/atoms in compound).
!  afzlq     Atomic fraction zirconium in liquid zr-u-o compound (atoms
!            zirconium/atoms in compound).
!  afusl     Atomic fraction uranium in solid zr-u-0 compound.
!  afzsl     Atomic fraction zirconium in solid zr-u-o compound.
!
!  Local variables.
       real(kr) aclad,acond1,ael,afuell,ai,al,areaf,arean,cp0,cp1,dti,
     & dxmin,effcp(ndrd),effcpc,effgen(ndrd),effk(ndrd),effkc,effkf,
     & fadj,fnrn,hgap,inkl(50),inrcl(50),k0,k1,kgap,kl(100),pce,pzroi,
     & pzroo,rce,rcl(100),rcentd,rcldi0,rfnr,rfuel,rmatmx,ro0,ro1,rpf,
     & rpltc,ruliql,rzroi,sfnrn,t0,t1,unuc,x0,x1,xlay(50)
       real fncp,fnk,fnro,fnucr,polate,pol8
       integer i,if,ilce,im,ix,j,kx,l,la,li,ml,n,nest,nl,nl2,nlay(100),
     & nlind,nlt2,nltot,nm,nm1,np1,numlay
       real(kr) kgprad(50)
       real(kr) fsbcon,hgprad,fgpems,kgprd1
       real(kr) tdum,cndum,fdum,rdum,rdum1,rdum2,rgap1,rgap2,tgap1,tgap2 
       real(kr) thkgpr,denmsh,keffgp
       real(kr) fgems1,thkgp1
       real(kr) femiss        
       real(kr) cpdum1,cpdum2,cpave,rodum1,rodum2,roave,cpvave
c       
       real(kr) hgapi, thkgpi1,keffgpi      
c       
       real term1
       real tmpmid
       real rm1,rm2,rox,vtot,vtox,vmet,wtox,wmet,qmatav,areato
       integer ldum,mdum,laydum,imdum,nmxgap,nn1,nn2,nngap,nsw
       integer matgs1,imet,imox
       integer mshmat(ndrd)
       integer mmm
       integer iselct
       integer ndbg
       data dxmin/2.5e-6/
cljs fsbcon = Stefan-Boltzmann constant
       data fsbcon / 5.6697e-8/
cljs fgpems = emissivity factor for radiation heat transfer across gap
       data fgpems / 0.75/
!   control time for debug
!
!  Multiplier adjusts for density correction of fuel due to ballooning.
         ndbg=0
             if(ndbg.eq.1)then
             write(output,9005)timehy,kx,modidx(1)
9005         format(' EFFHT entered; timehy=',e10.4,' kx=',i5,
     &       ' modidx(1)=',i5)
             end if
         if(modidx(1).eq.1)then
         iselct = 2
         else
         iselct = 1
         end if
          if(ndbg.eq.1)then
          write(output,9007)iselct
9007      format(' EFFHT; iselct=',i5)
          end if
       select case(iselct)
       case(1)
       fadj = 1.0
cljs  initialize variables describing heat transfer across gap
       kgpshi(inaz,icomp) = 0.0
       htcgap(inaz,icomp) = 0.0
       thkgp2(inaz,icomp) = 0.0
       ishgpi(inaz,icomp) = 0  
       ishgpo(inaz,icomp) = 0  
cljs  this statement is always true
       if (radmt3(nmater(kx)+1,inaz,icomp) - ruliql .ge. e) then
         if (acond1 .lt. 5.0) then
cljs  ruliql is always less than rcldi0, so fadj always equal to 1.
           if ((idcomp(icomp).le.0 .or. idcomp(icomp).eq.6) .and.
     &     ruliql.gt.rcldi0) fadj = (rcldi0/ruliql)**2
         endif
       endif
cljs Store in local array mshmat(i) the index identifying the first
cljs material (beginning with inner radius of mesh) in mesh i.
         do i =1,numelm2(inaz,icomp)
         mshmat(i) = mshmt3(i,inaz,icomp)
         end do
!  Convert nuclear heat generation from unuc (w/m) into qmat3 (w/m3).
!  All other heat generation data in input array qmat3 (w/m) are
!  converted into qmat3 (w/m3).
       if (ngeom(icomp) .gt. 1) then
!  Fuel rod.
!  Solid fuel, no internal layer of liquified zr-u-o.
         sfnrn = 0.0_kr
         areaf = 0.0_kr
         do n = 1,nmater(kx)
           np1 = n + 1
           arean = pi*(radmt3(np1,inaz,icomp)**2 -
     &     radmt3(n,inaz,icomp)**2)
           if (imatr3(n,inaz,icomp).ge.6 .and.
     &     imatr3(n,inaz,icomp).le.8) then
!  Layer of fuel.
!  Calculation of radial peaking factors fnrn=fnrn(r=rfnr).
             rfnr = (radmt3(n,inaz,icomp) + radmt3(np1,inaz,icomp))*0.5
             fnrn = fnucr(rfnr,prdpr(1,icomp),xrdpr(1,icomp),
     &       nrdpr(icomp),zcond(kx),paxpz(1,1,icomp),naxpz(icomp),
     &       kshapz(icomp))
             sfnrn = sfnrn + fnrn*arean
             areaf = areaf + arean
             if (idcomp(icomp) .eq. 6) then
               qmat3(n,inaz,icomp) = 0.0
             else
               qmat3(n,inaz,icomp) = fnrn*unuc
             endif
!cma
cljs  electrical heating materials; 4=tungsten, 21=molybdenum,
cljs  22=copper, 23=tantalum, 24=brass, 25=molybdenum for Parameter
cljs  tests
           elseif (imatr3(n,inaz,icomp).eq.4 .or.
     &     imatr3(n,inaz,icomp).eq.21 .or. imatr3(n,inaz,icomp).eq.22 
     &     .or. imatr3(n,inaz,icomp).eq.23 .or.
     &     imatr3(n,inaz,icomp).eq.24 .or. imatr3(n,inaz,icomp).eq.25)
     &     then
!cmaend
             qmat3(n,inaz,icomp) = unuc/arean
           elseif(imatr3(n,inaz,icomp).eq.1)then
cljs  cladding Zr
             if(arean.gt.1.e-8)then
             qmat3(n,inaz,icomp)=qmat3(n,inaz,icomp)/arean
             else
             qmat3(n,inaz,icomp)=0.0
             end if
           elseif(imatr3(n,inaz,icomp).eq.5)then
cljs  cladding oxide
           qmat3(n,inaz,icomp)=qmat3(n,inaz,icomp)/arean
           else
           qmat3(n,inaz,icomp)=0.0
           endif
         enddo
!
         do n = 1,nmater(kx)
           if (imatr3(n,inaz,icomp).ge.6 .and.
     &     imatr3(n,inaz,icomp).le.8) then
             if (sfnrn .gt. 0.0)
     &       qmat3(n,inaz,icomp) = qmat3(n,inaz,icomp)/sfnrn
           endif
         enddo
       else
!  Slab geometry.
cljs  initialize radiation heat transfer in each mesh to be zero
         do n = 1,numelm(kx)
         kgprad(n)=0.0
         end do
!  Conversion from (w/m) into (w/m3).
         do n = 1,nmater(kx)
           if (qmat3(n,inaz,icomp) .gt. 0.0)
     &     qmat3(n,inaz,icomp) = qmat3(n,inaz,icomp)/
     &     ((radmt3(n+1,inaz,icomp) - radmt3(n,inaz,icomp))*
     &     slbwd(icomp))
         enddo
       endif
!  1st step.
!
!  Calculation of material properties in r-/x-direction at element
!  interfaces or (if more than 1 material within an element) at material
!  layer interfaces within the elements.
!  rcl     Vol. heat capacities (Joule/m3-K).
!  kl      Inverse thermal conductivities (m-K/W).
!
!  Calculation of integrals of rcl and 1./kl over the temperature range
!  of an element or over the temperature ranges of the material layers
!  within an element.
!  inrcl   Integrals of vol. heat capacities (Joule/m3).
!  inkl    Integrals of inverse thermal conductivities (m-K2/W).
!
!  Computation of number of material layers in a heat conduction
!  element.
!  nltot     Total number of material layers in mesh n-1.
!  xlay(n-1)    Outer radii of nltot material layers in mesh n-1.
!  nlay(n-1) = number of different materials in mesh n-1
!  nlay(ndrd+1) = material ID of first type of material in mesh
!  nlay(ndrd+2)  = material ID of second type of material in mesh
!  rcl     Volumetric heat capacities.
!  kl      Thermal conductivity.
!  incrl   Integral of volumetric heat capacity.
!  inkl    Integral of inverse thermal conductivity.
cljs initialize nlay for each mesh; code calculate properties of
cljs each mesh based on dominant material in each mesh.
         do n=1,nrodes(kx)-1
         nlay(n) = 1
         end do
       n = 2
       la = 1
       nlt2 = -1
       nltot = 0
       nlind = ndrd
       x0 = xcond3(1,inaz,icomp)
       t0 = tcond3(1,inaz,icomp)
       x1 = 0.0
       lp1: do  nm = 1,nmater(kx)
         do
         im = mshmt3(n-1,inaz,icomp)
cljs  if true, all material layers identified?
           if (n .gt. nrodes(kx)) cycle lp1
           if (x1 .ge. xcond3(nrodes(kx),inaz,icomp)) cycle lp1
!  If xcond3(n) on outer surface, force calculation of properties
!  even when radmt3(nm+1) less than xcond3(n)
!  radmt3(nm+1)=outer radius of material layer nm (defined in fstate).
           rmatmx = radmt3(nm+1,inaz,icomp)
!  Start if block AAA.
           if (xcond3(n,inaz,icomp) - rmatmx.lt.e .and. la.le.1) then
             nlay(n-1) = 1
             nlind = nlind + 1
cljs correction; add following line.
             im = mshmt3(n-1,inaz,icomp)
c????
             nlay(nlind) = im
             x1 = xcond3(n,inaz,icomp)
             t1 = tcond3(n,inaz,icomp)
             cp0 = fncp(im,t0)
             cp1 = fncp(im,t1)
             ro0 = fnro(im,t0)
             ro1 = fnro(im,t1)
cljs  start of block of coding setting values to variables for
cljs  calculating radiation heat transfer across gap in shroud
               if(ro0.gt.10.0)then
               nmxgap=0
               kgprad(n-1)=0.0
               else
cljs           material in this mesh "n-1" is a gas
cljs  set up variables for calculating effective thermal conductivity
cljs  due to radiation heat transfer across gap
                 if(nmxgap.eq.0)then
cljs  first mesh in gas gap                            
                  matgs1=mshmt3(n-1,inaz,icomp)
                  rgap1=xcond3(n-1,inaz,icomp)
                  tgap1=tcond3(n-1,inaz,icomp)
                  ishgpi(inaz,icomp) = n-1
cljs  identify outer most mesh in gap
                 nn1=n
                 nn2=nrodes(kx)   
                 nsw=0
                   do nngap=nn1,nn2
                     if(nsw.eq.0)then                              
                       if(mshmt3(nngap,inaz,icomp).eq.matgs1)then
                       nmxgap=nngap
                       rgap2=xcond3(nngap+1,inaz,icomp)
                       tgap2=tcond3(nngap+1,inaz,icomp)
                       hgprad=fgpems*fsbcon*(tgap2**2 + tgap1**2)*
     &                 (tgap2 + tgap1)
                         if((rgap2-rgap1).ge.1.e-6)then
                         kgprd1=hgprad*(rgap2 - rgap1)
                         else
cljs    for case of closed gap, set radiation conductivity to nominal
cljs    value.
                         kgprd1=0.1
                         end if
                       ishgpo(inaz,icomp) = nngap
                       htcgap(inaz,icomp) = hgprad
                       thkgp2(inaz,icomp) = rgap2 - rgap1
                       else
                       nsw=1
                       end if
                     end if
                   end do
                 end if
               kgprad(n-1)=kgprd1
                 if((n-1) .eq. ishgpi(inaz,icomp))then
                 kgpshi(inaz,icomp) = kgprad(n-1)
                 end if
               end if
cljs    end of block of coding setting variables for calculating
cljs    radiation heat transfer across gap
             if (im.ge.6 .and. im.le.8) then
               ro0 = fadj*ro0
               ro1 = fadj*ro1
             endif
             k0 = 1.0_kr/fnk(im,t0,kx)
             k1 = 1.0_kr/fnk(im,t1,kx)
!   If acond1 > 5.0, then model which uses user-defined steady-state
!   conductance and transient conductance based on transient size of
!   fuel-cladding gap is applied.
cljs         if ((im.eq.6 .or. im.eq.7) .and. acond1.ge.5.0) then
             if (im.eq.7 .and. acond1.ge.5.0) then
               hgap = acond1
               if (xcond3(n,inaz,icomp).gt.
     &         radmt3(nm+1,inaz,icomp) - 1.e-6 .and.
     &         xcond3(n,inaz,icomp).lt.radmt3(nm+1,inaz,icomp) + 1.e-6)
     &         then
!  Apply gap resistance for outside surface of gap element.
                 kgap = hgap*(xcond3(n,inaz,icomp) -
     &           xcond3(n-1,inaz,icomp))
                 k0 = 1.0/kgap
                 k1 = 1.0/kgap
!  Apply heat capacity and density for gas in gas gap.
                 cp1 = 5.e4
                 ro1 = 4.
                 cp0 = cp1
                 ro0 = ro1
               endif
             endif
             nlt2 = nlt2 + 2
             nltot = nltot + 1
             rcl(nlt2) = ro0*cp0
             rcl(nlt2+1) = ro1*cp1
             kl(nlt2) = k0
             kl(nlt2+1) = k1
             if (abs(t1 - t0) .gt. 1.e- 4) then
               inrcl(nltot) = abs((rcl(nlt2) +
     &         rcl(nlt2+1))*(t1 - t0))*0.5
               inkl(nltot) = abs((k0 + k1)*(t1 - t0))*0.5
             else
               inrcl(nltot) = rcl(nlt2)
               inkl(nltot) = kl(nlt2)
             endif
             xlay(nltot) = x1
             x0 = x1
             t0 = t1
             n = n + 1
             cycle
!  Branch in if block AAA.
cljs  Since SCDAP material layout assumes only one dominant material
cljs  per radial mesh, this coding should never be reached. The
cljs  of a cladding radial mesh partially containing an oxide layer
cljs  can be modeled much simpler and without requiring the coding
cljs  below.
           else
             nm1 = n - 1
             x1 = radmt3(nm+1,inaz,icomp)
!  Begin if block BBB.
             if (x1 .gt. xcond3(n,inaz,icomp)) then
               nlay(n-1) = la
               nlind = nlind + 1
c????
               nlay(nlind) = im
               x1 = xcond3(n,inaz,icomp)
               t1 = tcond3(n,inaz,icomp)
               cp0 = fncp(im,t0)
               cp1 = fncp(im,t1)	
               ro0 = fnro(im,t0)
               ro1 = fnro(im,t1)
               if (im.ge.6 .and. im.le.8) then
                 ro0 = fadj*ro0
                 ro1 = fadj*ro1
               endif
               k0 = 1./fnk(im,t0,kx)
               k1 = 1./fnk(im,t1,kx)
cljs  nlt2 has initial value of -1
               nlt2 = nlt2 + 2
               nltot = nltot + 1
               rcl(nlt2) = ro0*cp0
               rcl(nlt2+1) = ro1*cp1
               kl(nlt2) = k0
               kl(nlt2+1) = k1
               if (abs(t1 - t0) .gt. 1.e-4) then
                 inrcl(nltot) = abs((rcl(nlt2)+rcl(nlt2+1))*(t1-t0))*0.5
                 inkl(nltot) = abs((k0 + k1)*(t1 - t0))*0.5
               else
                 inrcl(nltot) = rcl(nlt2)
                 inkl(nltot) = kl(nlt2)
               endif
               xlay(nltot) = x1
               x0 = x1
               t0 = t1
               la = 1
               n = n + 1
               cycle
!  Branch in if block BBB.
             else
!  Begin if block CCC.
               t1 = tcond3(nm1,inaz,icomp) +
     &         (tcond3(n,inaz,icomp) - tcond3(nm1,inaz,icomp))*
     &         (x1 - xcond3(nm1,inaz,icomp))/
     &         (xcond3(n,inaz,icomp) - xcond3(nm1,inaz,icomp))
               if (x1 .gt. xcond3(nm1,inaz,icomp)) then
                 cp0 = fncp(im,t0)
                 cp1 = fncp(im,t1)	
                 ro0 = fnro(im,t0)
                 ro1 = fnro(im,t1)
                 if (im.ge.6 .and. im.le.8) then
                   ro0 = fadj*ro0
                   ro1 = fadj*ro1
                 endif
                 k0 = 1.0/fnk(im,t0,kx)
                 k1 = 1.0/fnk(im,t1,kx)
                 nlt2 = nlt2 + 2
                 nltot = nltot + 1
                 rcl(nlt2) = ro0*cp0
                 rcl(nlt2+1) = ro1*cp1
                 kl(nlt2) = k0
                 kl(nlt2+1) = k1
                 if (abs(t1 - t0) .gt. 1.e-4) then
                   inrcl(nltot) = abs((rcl(nlt2) + rcl(nlt2+1))*
     &             (t1 - t0))*0.5
                   inkl(nltot) = abs((k0 + k1)*(t1 - t0))*0.5
                 else
                   inrcl(nltot) = rcl(nlt2)
                   inkl(nltot) = kl(nlt2)
                 endif
                 xlay(nltot) = x1
                 x0 = x1
                 t0 = t1
                 nlay(n-1) = la
                 nlind = nlind +1
c????
                 nlay(nlind) = im
                 la = la +1
!  Branch in if block CCC.
               else
                 x0 = x1
                 t0 = t1
                 la = 1
!  End if block CCC.
               endif
!  End if block BBB.
             endif
!  End if block AAA.
           endif
           exit
         enddo
       enddo lp1
!  End of 1st step.
!  2nd step.
!  Calculation of effective material properties (effcp,effk).
!  Calculation of effective vol. heat generations (effgen) due to
!  given vol. heat generation data for nmater(kx) material layers,
!  qmat3(nm, nm=1...nmater(kx)), and due to chemical energy per unit
!  length (W/m).
!
!  Calculation of effective material properties effcp and effk.
       if (ngeom(icomp) .le. 1) then
!  One-dimensional cartesian geomatry.
         j = 0
         do i = 1,numelm(kx)
cljs  nlay(i) = total number of material layers in mesh i
           li = nlay(i)
           effcp(i) = 0.0
           effk(i) = 0.0
           dti = tcond3(i+1,inaz,icomp) - tcond3(i,inaz,icomp)
           if (abs(dti) .ge. 1.e-4) then
             do l = 1,li
cljs  j is sum of material layers in each mesh beginning with mesh "1"
               j = j + 1
               effcp(i) = effcp(i) + inrcl(j)
               effk(i) = effk(i) +inkl(j)
             enddo
             effcp(i) = effcp(i)/abs(dti)
             effk(i) = effk(i)/abs(dti)
             effk(i) = 1.0/effk(i)
             effk(i)=effk(i)+kgprad(i)
           else
             x0 = xcond3(i,inaz,icomp)
             do l = 1,li
               j = j + 1
               al = max(xlay(j) - x0,dxmin)
               effcp(i) = effcp(i) + al*inrcl(j)
               effk(i) = effk(i) + al*inkl(j)
               x0 = xlay(j)
             enddo
             ai = max(xcond3(i+1,inaz,icomp) - xcond3(i,inaz,icomp),
     &       dxmin)
             effcp(i) = effcp(i)/ai
             effk(i) = effk(i)/ai
             effk(i) = 1.0/effk(i)
             effk(i)=effk(i)+kgprad(i)
           endif
cljs  identify material at radial mesh i
           rdum=0.5*(xcond3(i,inaz,icomp)+xcond3(i+1,inaz,icomp))
           laydum=1
             do mdum=1,nmater(kx)
               if(rdum.ge.radmt3(mdum,inaz,icomp).and.
     &         rdum.le.radmt3(mdum+1,inaz,icomp))then
               laydum=mdum
               end if
             end do
         enddo
       else
!  One-dimensional cylindrical geometry.
       keffgp = 0.0  
       htcgap(inaz,icomp) = acond1
           if(modidx(1) .eq. 1)then
             if((idcomp(icomp).eq.0.and.imatr3(2,inaz,icomp).eq.9)
     &       .or. idcomp(icomp) .eq.6)then
             if (modidx(6) .eq. 0) then
               call gaphtc(hgap,keffgp,thkgp1,mshmat,inaz)      
             else
               call gaphtc2(hgap,hgapi,keffgp,keffgpi,thkgp1,thkgpi1,
     &             mshmat,inaz)             
             endif
               if(ndbg.eq.1)then
               write(output,9105)hgap,keffgp
9105           format(' EFFHT; GAPHTC called; hgap=',e10.4,
     &         ' keffgp=',e10.4)
               end if
             end if
           end if
         j = 0
         do i = 1,numelm(kx)
           li = nlay(i)
           effcp(i) = 0.0
           effk(i) = 0.0
           dti = tcond3(i+1,inaz,icomp) - tcond3(i,inaz,icomp)
           if (abs(dti) .ge. 1.e-4) then
             x0 = xcond3(i,inaz,icomp)
             do l = 1,li
               j = j + 1
               al = (xlay(j)+x0)*max(xlay(j) - x0,dxmin)
               effcp(i) = effcp(i) + al*inrcl(j)
               effk(i) = effk(i) + al*inkl(j)
               x0 = xlay(j)
             enddo
             ai = (xcond3(i+1,inaz,icomp) + xcond3(i,inaz,icomp))*
     &       (max(xcond3(i+1,inaz,icomp) - xcond3(i,inaz,icomp),dxmin))
             effcp(i) = effcp(i)/(ai*abs(dti))
               if(keffgp .ge. 0.00001 .and.                              
     &         i .eq. nrcond2(inaz,icomp))then
cljs    use calculated effective thermal conductivity for gap, which
cljs    includes radiation heat transfer
               effk(i) = keffgp
               thkgp2(inaz,icomp) = thkgp1
               htcgap(inaz,icomp) = hgap
               kgpshi(inaz,icomp) = effk(i)
               else
               effk(i) = effk(i)/(ai*abs(dti))
               effk(i) = 1.0/effk(i) 
                 if(i .eq. nrcond2(inaz,icomp))then
                 kgpshi(inaz,icomp) = effk(i)
                 end if
               end if
           else
cljs case virtually no temperature gradient
             x0 = xcond3(i,inaz,icomp)
             do l = 1,li
               j = j + 1
               al = (xlay(j) + x0)*max(xlay(j) - x0,dxmin)
               effcp(i) = effcp(i) + al*inrcl(j)
               effk(i) = effk(i) + al*inkl(j)
               x0 = xlay(j)
             enddo
             ai = (xcond3(i+1,inaz,icomp) + xcond3(i,inaz,icomp))*
     &       (max(xcond3(i+1,inaz,icomp) - xcond3(i,inaz,icomp),dxmin))
             effcp(i) = effcp(i)/ai
               if(keffgp .ge. 0.00001 .and.
     &         i .eq. nrcond2(inaz,icomp))then
cljs   use calculated effective thermal conductivity for gap
               effk(i) = keffgp
               htcgap(inaz,icomp) = hgap
               thkgp2(inaz,icomp) = thkgp1
               kgpshi(inaz,icomp) = effk(i)
               else
               effk(i) = effk(i)/ai
               effk(i) = 1.0/effk(i)
                 if(i .eq. nrcond2(inaz,icomp))then
                 kgpshi(inaz,icomp) = effk(i)
                 end if
               end if
           endif
         enddo
       endif
!  Calculation of effective vol. heat generations.
       if (ngeom(icomp) .le. 1) then
         l = 0
         ml = 1
         x0 = xcond3(1,inaz,icomp)
         do i = 1,numelm(kx)
           numlay = nlay(i)
           effgen(i) = 0.0
           do nl = 1,numlay
             l = l + 1
             al = max(xlay(l) - x0,dxmin)
             if (xlay(l) - radmt3(ml+1,inaz,icomp) .gt. e) ml = ml + 1
             effgen(i) = effgen(i) + al*qmat3(ml,inaz,icomp)
             x0 = xlay(l)
           enddo
           ai = max(xcond3(i+1,inaz,icomp) - xcond3(i,inaz,icomp),dxmin)
           effgen(i) = effgen(i)/ai
         enddo
       else
         l = 0
         ml = 1
         x0 = xcond3(1,inaz,icomp)
         do i = 1,numelm(kx)
           numlay = nlay(i)
           effgen(i) = 0.
           do nl = 1,numlay
             l = l + 1
             al = (xlay(l) + x0)*max(xlay(l) - x0,dxmin)
!  radmt3(ml+1)=outer radius of material layer for which power factors
!  are being calculated.
!  Note. Fuel material layer is considered to extend to inside radius of
!  cladding.  Outermost element of fuel material layer has inside radius
!  equal to as-fabricated fuel pellet radius and ouside radius equal to
!  inside radius of cladding.
!
!  x0=inner radius of finite element under consideration.
!  xlay(l)=outer radius of element for which effgen is being calculated.
             if (xlay(l) .gt. radmt3(ml+1,inaz,icomp)) ml= ml + 1
             effgen(i) = effgen(i) + al*qmat3(ml,inaz,icomp)
             x0 = xlay(l)
           enddo
           ai = (xcond3(i+1,inaz,icomp) + xcond3(i,inaz,icomp))*
     &     (max(xcond3(i+1,inaz,icomp) - xcond3(i,inaz,icomp),dxmin))
           effgen(i) = effgen(i)/ai
!  Adjust effgen to account for radial variation in power in fuel
!  region.
!  rcentd=radius of centroid of element i.
           rcentd = sqrt(0.5*(xcond3(i+1,inaz,icomp)**2 +
     &     xcond3(i,inaz,icomp)**2))
           nest = nrdpr(icomp)/2
           rpf = pol8(prdpr(1,icomp),xrdpr(1,icomp),rcentd,nrdpr(icomp),
     &     nest)
           effgen(i) = rpf*effgen(i)
         enddo
       endif
!  Chemical energy sources.
       if (pzroi.ne.0. .or. pzroo.ne.0. .or. puliq.ne.0.) then
         ilce = 0
         do
           ilce = ilce + 1
           if (ilce .ge. 4) exit
           select case (ilce)
           case (1)
             if (pzroo .eq. 0.0) cycle
             rce = rnoxd(kx)
             pce = pzroo
           case (2)
             if (pzroi .eq. 0.0) cycle
             rce = rzroi
             pce = pzroi
           case (3)
             if (puliq .eq. 0.0) exit
             rce = ruliql
             pce = puliq
           end select
!  Add chemical energy sources to effective volumetric heat sources.
           ix = nrodes(kx)
cljs add; 08/18/10
cljs  oxidation heat generation added at outermost cladding mesh
           ix = ix -1
               if (ngeom(icomp) .eq. 1) then
c       shroud
                 ael = (xcond3(ix+1,inaz,icomp) -
     &           xcond3(ix,inaz,icomp))*slbwd(icomp)
               else
c       rods
                 ael = pi*(xcond3(ix+1,inaz,icomp)**2 -
     &           xcond3(ix,inaz,icomp)**2)
               endif
cljs   convert oxidation heat generation from W/m to W/m3
               pce = pce/ael
               effgen(ix) = effgen(ix) + pce
cljs end add, 08/18/10
cljs The term puliq (power absorbed by dissolution) is always zero,
cljs so bypass do loop incrementally increasing efgen based on 
cljs puliq
         enddo
       endif
!  End of 2nd step.
!  3rd step.
!  Calculation of effective material properties for fuel region--
!  effcpf, effkf.
!  Calculation of effective material properties for clad region--
!  effcpc, effkc.
!  Calculation of effective vol. heat generation in fuel region--
!  effqf.
       effcpf(kx) = 0.
       effkf = 0.0
       effcpc = 0.0
       effkc = 0.0
       effqf(kx) = 0.0
       rfuel = rpltc
!  If dissolution of fuel by cladding, then fuel and cladding are in
!  contact.
       if (ruliql .lt. (rpltc - 1.e-5)) rfuel = rci(kx)
       if (radmt3(nmater(kx)+1,inaz,icomp) - rfuel .ge. e) then
         x0 = 0.0
         im = 0
         do
           im = im +1
           if (radmt3(im+1,inaz,icomp) .ge. rfuel) exit
         enddo
! im: number of material layers within the fuel region (xcond3(1),rfu.
         if (ngeom(icomp) .le. 1) then
! One-dimensional cartesian geometry.
           do nl = 1,nltot
             nl2 = 2*nl - 1
             x1 = xlay(nl)
             if (x1 .le. rfuel) then
               effcpf(kx) = effcpf(kx) +
     &         (rcl(nl2) + rcl(nl2+1))*(x1 - x0)*0.5
               effkf = effkf + (kl(nl2) + kl(nl2+1))*(x1 - x0)*0.5
               x0 = x1
             else
               effcpc = effcpc + (rcl(nl2) + rcl(nl2+1))*(x1 - x0)*0.5
               effkc = effkc + (kl(nl2) + kl(nl2+1))*(x1 - x0)*0.5
               x0 = x1
             endif
           enddo
           afuell = rfuel - xcond3(1,inaz,icomp)
           aclad = xcond3(nrodes(kx),inaz,icomp) - rfuel
           effcpf(kx) = effcpf(kx)/afuell
           effkf = afuell/effkf
           effcpc = effcpc/aclad
           effkc = aclad/effkc
           do if = 1,im
             effqf(kx) = effqf(kx) + qmat3(if,inaz,icomp)*
     &       (radmt3(if+1,inaz,icomp) - radmt3(if,inaz,icomp))
           enddo
           effqf(kx) = effqf(kx)/afuell
         else
!  One-dimensional cylindrical geometry.
           do nl = 1,nltot
             nl2 = 2*nl - 1
             x1 = xlay(nl)
             if (x1 .le. rfuel) then
               effcpf(kx) = effcpf(kx) +
     &         (rcl(nl2) + rcl(nl2+1))*(x1*x1 - x0*x0)*0.5
               effkf = effkf + (kl(nl2) + kl(nl2+1))*(x1*x1 - x0*x0)*0.5
               x0 = x1
             else
               effcpc = effcpc +
     &         (rcl(nl2) + rcl(nl2+1))*(x1*x1 - x0*x0)*0.5
               effkc = effkc + (kl(nl2) + kl(nl2+1))*(x1*x1 - x0*x0)*0.5
               x0 = x1
             endif
           enddo
           afuell = rfuel**2 - xcond3(1,inaz,icomp)**2
           aclad = xcond3(nrodes(kx),inaz,icomp)**2 - rfuel**2
           effcpf(kx) = effcpf(kx)/afuell
           effkf = afuell/effkf
           effcpc = effcpc/aclad
           effkc = aclad/effkc
           do if = 1,im
             effqf(kx) = effqf(kx) + qmat3(if,inaz,icomp)*
     &       (radmt3(if+1,inaz,icomp)**2 - radmt3(if,inaz,icomp)**2)
           enddo
           effqf(kx) = effqf(kx)/afuell
         endif
       endif
!  End of 3rd step.
       return
       case(2)
         do i =1,numelm2(inaz,icomp)
         mshmat(i) = mshmt3(i,inaz,icomp)
           if(ndbg.eq.1)then
           write(output,9011)i,mshmat(i)
9011       format(' EFFHTSM at start; i=',i5,' mshmat=',i5)
           end if
         end do
         if(ngeom(icomp).eq.1)then
cljs  initialize variables describing heat transfer across gap in shroud
         kgpshi(inaz,icomp) = 0.0
         htcgap(inaz,icomp) = 0.0
         thkgp2(inaz,icomp) = 0.0
         ishgpi(inaz,icomp) = 0  
         ishgpo(inaz,icomp) = 0  
         matgs1 = 9999
         nngap = 0
         end if
cljs calculate variables for effective thermal conductivity of
cljs gap in shroud insulating fuel bundle
       if(ngeom(icomp).eq.1)then
         do i =1, numelm2(inaz,icomp)
         im = mshmt3(i,inaz,icomp)
         t0 = tcond3(i,inaz,icomp)
         t1 = tcond3(i+1,inaz,icomp)
               if(ndbg.eq.1)then
               write(output,9034)i,im
9034           format(' k and cp for shroud; i=',i5,' im=',i5)
               end if
         cp0 = fncp(im,t0)
         cp1 = fncp(im,t1)	
         ro0 = fnro(im,t0)
         ro1 = fnro(im,t1)
cljs  start of block of coding setting values to variables for
cljs  calculating radiation heat transfer across gap in shroud
               if(ro0.gt.10.0)then
               nmxgap=0
               kgprad(i)=0.0
               else
cljs           material in this mesh "m-1" is a gas
cljs  set up variables for calculating effective thermal conductivity
cljs  due to radiation heat transfer across gap
                 if(nmxgap.eq.0)then
cljs  first mesh in gas gap                            
                  matgs1=mshmt3(i,inaz,icomp)
                  rgap1=xcond3(i,inaz,icomp)
                  tgap1=tcond3(i,inaz,icomp)
                  ishgpi(inaz,icomp) = i   
cljs  identify outer most mesh in gap
                 nn1=i
                 nn2=nrodes(kx)-1   
                 nsw=0
                   do nngap=nn1,nn2
                     if(nsw.eq.0)then                              
                       if(mshmt3(nngap,inaz,icomp).eq.matgs1)then
                       nmxgap=nngap
                       rgap2=xcond3(nngap+1,inaz,icomp)
                       tgap2=tcond3(nngap+1,inaz,icomp)
                       hgprad=fgpems*fsbcon*(tgap2**2 + tgap1**2)*
     &                 (tgap2 + tgap1)
                         if((rgap2-rgap1).ge.1.e-6)then
                         kgprd1=hgprad*(rgap2 - rgap1)
                         else
cljs    for case of closed gap, set radiation conductivity to nominal
cljs    value.
                         kgprd1=0.1
                         end if
                       ishgpo(inaz,icomp) = nngap
                       htcgap(inaz,icomp) = hgprad
                       thkgp2(inaz,icomp) = rgap2 - rgap1
                       else
                       nsw=1
                       end if
                     end if
                   end do
                 end if
               kgprad(i)=kgprd1
                   if(ndbg.eq.1)then
                   write(output,9030)i,kgprad(i)
9030               format(' EFFHTSM; i=',i5,' kgprad(i)=',i5)
                   end if
                 if(i .eq. ishgpi(inaz,icomp))then
                 kgpshi(inaz,icomp) = kgprad(i)
                 end if
               end if
         end do
c  end of block for effective k for gap in shroud
       end if
             if(ndbg.eq.1)then
             write(output,9031)matgs1,nngap
9031         format(' EFFHTSM after shroud case; matgs1=',i5,
     &       ' nngap=',i5)
             end if
         do i = 1,numelm(kx)
         im = mshmat(i)
         tmpmid = 0.5*(tcond3(i+1,inaz,icomp) +
     &            tcond3(i,inaz,icomp))
           if(ndbg.eq.1)then
           write(output,9033)i,im,tmpmid
9033       format(' EFFHTSM loop for effective properties; i=',i5,
     &     ' im=',i5,' tmpmid=',e10.4)
           end if
cljs  if mesh models gas gap between fuel and cladding, then calculate
cljs  gap heat transfer.
           if(ngeom(icomp).eq.1.and.i.ge.matgs1.and.i.le.nngap)then
cljs   gap in insulating shroud
           effk(i) = kgprd1
! error?
!           effcp(i) = fnro(im,tmpmid)           
	   effcp(i) = fncp(im,tmpmid)
           elseif(ngeom(icomp).eq.2.and.im.eq.9)then
             if (modidx(6) .eq. 0) then
cljs   gap between fuel and cladding
               call gaphtc(hgap,keffgp,thkgp1,mshmat,inaz)
               htcgap(inaz,icomp) = thkgp1
               thkgp2(inaz,icomp) = thkgp1
               kgpshi(inaz,icomp) = keffgp 
               effk(i) = keffgp
               effcp(i) = fnro(im,tmpmid)
             else
               if(i.lt.nrcond2(inaz,icomp))then
chm   inner gap (between fuel and heater)
                 call gaphtc2(hgap,hgapi,keffgp,keffgpi,thkgp1,thkgpi1,
     &           mshmat,inaz)
                 htcgap(inaz,icomp) = hgapi    
                 thkgp2(inaz,icomp) = thkgpi1
                 kgpshi(inaz,icomp) = keffgpi 
                 effk(i) = keffgpi
	         effcp(i) = fncp(im,tmpmid)*fnro(im,tmpmid)
               elseif(i.ge.nrcond2(inaz,icomp))then
chm   outer gap (between fuel and cladding OR heater and cladding)
                 call gaphtc2(hgap,hgapi,keffgp,keffgpi,thkgp1,thkgpi1,
     &           mshmat,inaz)
                 htcgap(inaz,icomp) = hgap    
                 thkgp2(inaz,icomp) = thkgp1
                 kgpshi(inaz,icomp) = keffgp 
                 effk(i) = keffgp
	         effcp(i) = fncp(im,tmpmid)*fnro(im,tmpmid)
c              if(ndbg.eq.1)then
c               dum1=fncp(im,tmpmid)
c               dum2=fnro(im,tmpmid)
c               write(output,9036)i,im,dum1,dum2
c9036           format(' EFFHTS for gap in rod; i=',i5,' im=',i5,
c     &          ' cp=',e10.4,' rho=',e10.4)
c             end if
               end if           	     
             endif
           elseif(im.eq.5.or.im.eq.1)then
cljs add modification for cladding with oxide layer
cljs  weight thermal properties according to volumes of metallic Zr and
cljs  oxidized Zr in mesh
            imox = 5
            imet = 1
            rox = rnoxd((icomp-1)*ndax + inaz)
            rm1 = xcond3(i,inaz,icomp)
            rm2 = xcond3(i+1,inaz,icomp)
             if(rox.lt.rm1)then
cljs  mesh fully oxidized
             effk(i) = fnk(imox,tmpmid,kx)
             effcp(i) = fnro(imox,tmpmid)
             elseif(rox.gt.rm2)then
cljs  mesh fully metallic
             effk(i) = fnk(imet,tmpmid,kx)
             effcp(i) = fnro(imet,tmpmid)
             else
cljs   mesh contains layer of metallic Zr and layer of oxidized Zr
               if(ngeom(icomp).eq.2)then
               vtox = rm2*rm2 - rox*rox
               vtot = rm2*rm2 - rm1*rm1
               vmet = rox*rox - rm1*rm1
               else
               vtox = rm2 - rox
               vtot = rm2 - rm1
               vmet = rox - rm1
               end if
             wtox = vtox/vtot
             wmet = vmet/vtot
             effcp(i) = wtox*fnro(imox,tmpmid) +
     &                  wmet*fnro(imet,tmpmid)
             effk(i) = 1./(wmet*(1./fnk(imet,tmpmid,kx)) +
     &                 wtox*(1./fnk(imox,tmpmid,kx)))
             end if
           else
           effcp(i) = fnro(im,tmpmid)            
           effk(i) = fnk(im,tmpmid,kx)
           end if
         end do
             if(ndbg.eq.1)then
               do i=1,numelm2(inaz,icomp)
               write(output,9041)i,effk(i),effcp(i),effgen(i)
9041           format(' EFFHTSM after main loop; i=',i5,
     &         ' effk=',e10.4,' effcp=',e10.4,' effgen=',e10.4)
               end do
             end if
       do i=1,numelm2(inaz,icomp)
       effgen(i) = 0.0
       end do
cljs  input nuclear or electrical heat generation
       if (ngeom(icomp) .gt. 1) then
!  Fuel rod or simulator rod
cljs  start do01
           im = mshmat(1)
cljs  if02
           if(mshmat(1).ge.6.and.mshmat(1).le.8)then
cljs  fuel rod
           areato = pi*(xcond3(nrcond2(1,icomp),inaz,icomp)**2 -
     &              xcond3(1,inaz,icomp)**2)
           qmatav = unuc/areato
             if(ndbg.eq.1)then
             write(output,9052)mshmat(1),nrcond2(1,icomp),
     &       unuc
9052         format(' EFFHTSM fuel rod; mshmat(1)=',i5,
     &       ' nrcond2=',i5,' unuc=',e10.4)
             end if
           elseif(im.eq.4 .or.
     &     im.eq.21 .or. im.eq.22
     &     .or. im.eq.23 .or.
     &     im.eq.24.or.im.eq.25)then
           areato = pi*(xcond3(nsimot(inaz,icomp)+1,inaz,icomp)**2 -
     &              xcond3(1,inaz,icomp)**2)
           qmatav = unuc/areato
             if(ndbg.eq.1)then
             write(output,9053)mshmat(1),nsimot(inaz,icomp),areato,
     &       unuc
9053         format(' EFFHTSM simulator; mshmat(1)=',i5,
     &       ' nsimot=',i5,' areaot=',e10.4,' unuc=',e10.4)
             end if
           else
           qmatav = 0.0
           end if
         do i = 1,numelm2(inaz,icomp)
              if(ndbg.eq.1)then
              write(output,9013)i,mshmat(i)
9013          format(' EFFHTSM for rods, i=',i5,' mshmat(i)=',i5)
              end if
         im = mshmat(i)
cljs  if03
           if(im.eq.6 .or. im.eq.7 .or. im.eq.8)then
           rfnr = 0.5*(xcond3(i,inaz,icomp) + xcond3(i+1,inaz,icomp))
           fnrn = fnucr(rfnr,prdpr(1,icomp),xrdpr(1,icomp),
     &     nrdpr(icomp),zcond(kx),paxpz(1,1,icomp),naxpz(icomp),
     &     kshapz(icomp))
           effgen(i) = fnrn*qmatav
             if(ndbg.eq.1)then
             write(output,9051)i,fnrn,qmatav,effgen(i)
9051         format(' EFFHTSM for fuel, i=',i5,
     &       ' fnrn=',e10.4,' qmatav=',e10.4,' effgen=',e10.4)
             end if
           elseif(im.eq.4 .or. im.eq.21 .or. im.eq.22
     &     .or. im.eq.23 .or. im.eq.23 .or. im.eq.25)then
cljs    no radial power distribution for electrical heat element.
           effgen(i) = qmatav
             if(ndbg.eq.1)then
             write(output,9042)i,qmatav,effgen(i)
9042         format(' EFFHTSM for simulator, i=',i5,                   
     &       ' qmatav=',e10.4,' effgen=',e10.4)
             end if
           else
cljs     mesh does not include nuclear fuel or electrical heating
cljs     material
           effgen(i) = 0.0
           end if
         end do
       end if
!  Chemical energy sources.
       if (pzroo.ne.0.) then
cljs account for heat generation due to oxidation.
cljs oxidation heat generation is put into outermost mesh
             pce = pzroo
!  Add chemical energy sources to effective volumetric heat sources.
           ix = nrodes(kx) -1
cljs  oxidation heat generation added at outermost cladding mesh
               if (ngeom(icomp) .eq. 1) then
c       shroud
                 ael = (xcond3(ix+1,inaz,icomp) -
     &           xcond3(ix,inaz,icomp))*slbwd(icomp)
               else
c       rods
                 ael = pi*(xcond3(ix+1,inaz,icomp)**2 -
     &           xcond3(ix,inaz,icomp)**2)
               endif
cljs   convert oxidation heat generation from W/m to W/m3
            pce = pce/ael
            effgen(ix) = effgen(ix) + pce
                 if(ndbg.eq.1)then
                 write(output,9045)ix,pzroo,pce,effgen(ix)
9045             format(' EFFHTSM for oxidation heat; ix=',i5,
     &           ' pzroo=',e10.4,' pce=',e10.4,' effgen=',e10.4)
                 end if
       end if
       return
       end select
       end
*endif
