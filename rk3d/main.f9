       MODULE rk3dcode
$if def,3dkin
!23456789012345678901234567890123456789012345678901234567890123456789012
!                                                                      C
!           COPYRIGHT BY NORTH CAROLINA STATE UNIVERSITY, 1993         C
!                                                                      C
!                                                                      C
!   3DKIN  :  A NEUTRON DIFFUSION KINETIC EQUATION CODE               C
!  ========      WITH FDM AND NODAL OPTIONS, SOLVES                    C
!                  I   )  EIGEN VALUE PROBLEM [EVP]                    C
!                  II  ) STEADY-STATE FIXED SOURCE PROBLEM [FSP]       C
!                  III ) TRANSIENT FIXED SOURCE PROBLEM [FSP]          C
!                                                                      C
!              VERSION 1.0 (6/1/89) ORIGINAL VERSION                   C
!                  (1) EVP STEADY-STATE PROBLEM                        C
!                  (2) CLOSED CHANNEL T-H FEEDBACK                     C
!                  (3) COMPUTATIONAL PERFORMANCE TUNNING               C
!                  (4) VECTORIZATION/MULTITASKING                      C
!                  (5) CONTROL ROD MODEL                               C
!                       PAUL J. TURINSKY                               C
!                       SUNG-KYUNG ZEE                                 C
!                       RIFAT M. ALCHALABI                             C
!                                                                      C
!              VERSION 2.0 (3/20/91) ADDITION                          C
!                  (1) FSP STEADY-STATE PROBLEM                        C
!                  (2) FSP TRANSIENT PROBLEM                           C
!                  (3) DECAY-HEAT MODEL                                C
!                  (4) POWER LEVEL/CRITICALITY SEARCH                  C
!                       PAUL J. TURINSKY                               C
!                       RIFAT M. ALCHALABI                             C
!                                                                      C
!              VERSION 3.0 (12/15/91) MODIFICATION                     C
!                  (1) NON-LINEAR NEM IMPLIMENTATION                   C
!                  (2) FOUR GROUP TREATMENT                            C
!                       PAUL J. TURINSKY                               C
!                       PHILIPPE ENGRAND                               C
!                                                                      C
!              VERSION 3.1 (2/17/92) CORRECTION                        C
!                  (1) ONE-NODE TREATEMENT ( EDGE NODES )              C
!                       PAUL J. TURINSKY                               C
!                       FRANCOIS-XAVIER FAURE                          C
!                                                                      C
!              VERSION 3.2 (5/15/92) MODIFICATION                      C
!                  (1) TRANSFORMING TO PRODUCTION GRADE CODE           C
!                       PAUL J. TURINSKY                               C
!                       RIFAT M. ALCHALABI                             C
!                                                                      C
!              VERSION 3.3 (7/31/92) MODIFICATION/CORRECTION           C
!                  (1) CODE RESTRUCTURING.                             C
!                  (2) AXIAL-SOLVER & 2D INDICIES COLLAPSING           C
!                       PAUL J. TURINSKY                               C
!                       RIFAT M. ALCHALABI                             C
!                       HISHAM N. SARSOUR                              C
!                                                                      C
!              VERSION 4.0 (2/2/92) MODIFICATIONS/CORRECTIONS          C
!                  (1) HEX-CART GEOMETRY INTEGRATION                   C
!                  (2) CORRECTION OF BUGS IDENTIFIED BY LANL           C
!                  (3) MODIFICATIONS & CORRECTIONS BY NCSU             C
!                  (4) I/O  MODIFICATIONS                              C
!                  (5) MICROSCOPIC DEPLETION TREATMENT                 C
!                       PAUL J. TURINSKY                               C
!                       HISHAM N. SARSOUR                              C
!                       RIFAT M. ALCHALABI                             C
!                       FRANCOIS-XAVIER FAURE                          C
!                                                                      C
!              VERSION 4.1 (5/17/92) MODIFICATIONS/CORRECTIONS         C
!                  (1) A ARRAY ADOPTATION                              C
!                  (2) MODIFICATIONS & CORRECTIONS BY NCSU             C
!                  (3) I/O  MODIFICATIONS/EXPANSION                    C
!                  (4) MODIFY TH PROPERTIES DEFINITION                 C
!                       PAUL J. TURINSKY                               C
!                       RIFAT M. ALCHALABI                             C
!                       WEIPING GUO                                    C
!                                                                      C
!              VERSION 5.0 (6/10/94) MODIFICATIONS/CORRECTIONS         C
!                  (1) FIXED-SOURCE SCALE FACTOR REACTIVATED           C
!                  (2) TWO-PHASE FLOW HEM MODEL USING SETS METHOD      C
!                  (3) POLNOMIAL CROSS-SECTION MODEL                   C
!                  (4) CORRECTIONS OF MICROSCOPIC DEPLETION OPTION     C
!                  (5) ADDED TRANSIENT RESTART CAPABILITY              C
!                  (6) DISTINCT MODERATOR FROM COOLANT OPTION          C
!                  (7) SOLUBLE POISON LOCATION OPTION                  C
!                                                                      C
!              ****NOTE ITEMES (6) & (7) DEACTIVATED WITHIN CODE****   C
!              ****SINCE NO T-H MODEL FOR MODERATOR DISTINCT FROM***   C
!              ****COOLANT IS CURRENTLY AVAILABLE.  INTENT IS FOR***   C
!              ****FUTURE LINKAGE OF 3DKIN TO SYSTEM T-H CODE.*****   C
!              ****TO ACTIVATE, SEARCH FOR 'CMOD' COMMENT LINES*****   C
!              ****TO DETERMINE SOURCE CODE CHANGES NECESSARY.******   C
!                       PAUL J. TURINSKY                               C
!                       WEIPING GUO                                    C
!                                                                      C
!              VERSION 5.0.1 (1/19/96) MODIFICATIONS/CORRECTIONS       C
!                  (1) CHANGED ftime.f FROM FUNCTION TO SUBROUTINE     C
!                  (2) CORRECTED inpedit.f & inital.f TO WRITE         C
!                        RESTART FILE TYPE AFTER READ IN               C
!                  (3) CORRECTED inpedit.f TO PASS GMASS THROUGH       C
!                        thermo.fcb                                    C
!                  (4) CORRECTED geometry.f TO HANDLE OFFSET FUEL      C
!                        BUNDLES                                       C
!                  (5) CORRECTED slowtran.f TO CORRECT ERROR IN        C
!                        CALLING ARUGMENTS TO outpcrt.f                C
!                  (6) CORRECTED nonnemc.f,nonnemh.f,nonplmc.f,        C
!                        nonplmh.f, nononeh.f AND nontwoh.f FOR        C
!                        MISTAKES RELATED TO EFFECTIVE SOURCE          C
!                  (7) CORRECTED nonnemh.f FOR MISTAKE IN NUMBER       C
!                        MULTIPLYING AXIAL LEAKAGE POLYNOMIAL FIT      C
!                        COEFFICIENT IN ODD MOMENT BALANCE EQUATION    C
!                  (8) DELETED RKXU AND RKUX VECTORS SINCE NOT USED    C
!                      WHICH IMPACTED pointer.f, nonplmh.f, nonnemh.f  C
!                      outin.f, outintr.f & varlen.fcb                 C
!                  (9) REVERSED IXY & IZ LOOP ORDER IN sorce.f &       C
!                      sorce0.f TO INCREASE COMPUTATIONAL SPEED        C
!                  (10)DELETED RAWXV, BAWXV & YAWXV IN adjoint.f       C
!                      outin.f, pointer.f, slowtran.f steadyn.f        C
!                      transit.f, tridia0.f and varlen.fcb SINCE       C
!                      NOT USED.                                       C
!                  (11)FINALN CORRECTED TO LFINALN IN varlen.fcb       C
!                  (12)CHANGED DFACT & EXPLAMD, BOTH REAL*8, STARTING  C
!                      POSITIONS IN 'A' ARRAY SO ALWAYS ODD # TO       C
!                      AVOID ALIGNMENT PROBLEM ON DEC ALPHASTATION     C
!                  (13)FNOLDT ASSIGNMENT MOVED FROM update.f TO        C
!                      precr.f TO CORRECT ERROR IN USING PAST TIME     C
!                      VALUE OF FISSION DENSITY IN CI CALCULATION      C
!                  (14)EXTRAPOLATE FLUX, FISSION SOURCE & POWER        C
!                      DENSITY TO NEW TIME STEP ASSUMING EXPONENTIAL   C
!                      INCORPORATED INTO outintr.f & update.f          C
!                  (15)MOVE update.f CALL IN transit.f SO OLD FISSION  C
!                      SOURCE NOT OVERWRITTEN PRIOR TO precr.f CALL    C
!                  (16)DETERMINE FREQUENCY OF NEM UPDATES BASED UPON   C
!                      L2 FISSION SOURCR RELATIVE ERROR REDUCTION      C
!                      (EPSNEM), BOUNDED BY AN UPPER LIMIT (NNEM)      C
!                  (17)SCALED L2 NORM OF FISSION SOURCE TERMS TO AVOID C
!                      OVERFLOW FOR TRANSIENTS IN chebytr.f            C
!                  (18)IN echoinp.f AND outpoint.f THE VARIABLE        C
!                      IXPRBLANK defined to have value > 0 SINCE       C
!                      < 0 RANGE OF ABLANK CAUSES PROBLEM ON DEC ALPHA C
!                  (19)NXSTARTP & NXENDP ARRAYS CHANGED TO VARIABLE    C
!                      DIMENSIONS IN echoinp.f & pointer.f DUE TO      C
!                      SUN SPARC COMPATABILITY PROBLEM                 C
!                  (20)CHANGED pointer.f & inpdata.f SUCH THAT ALL     C
!                      POINTERS ARE INITIALIZED TO AVOID SUN PROBLEM   C 
!                       PAUL J. TURINSKY                               C
!                                                                      C
!              VERSION 5.0.2 (4/1/96) MODIFICATIONS/CORRECTIONS        C
!                  (1) ADDED WEILANDT SHIFT CAPABILITY                 C
!                  (2) ADDED FIXED FLUX EXTRAPOLATION FOR WEILANDT     C
!                      AND NO CHEBYSHEV OUTER ITERATION OPTIONS        C
!                  (3) ALLOWED TRANSIENT IMPLICIT OR EXPLICT T-H       C
!                  (4) CLEANED UP INPUT CHECKING ON ALPHANUMERICS      C
!                  (5) CHANGED WHEN LSORB0 CALLED                      C
!                  (6) CLEANED outin.f, outinadj.f, outintr.f,         C
!                      cheby1.f & chebytr.f CODING UP                  C
!                  (7) OPTION OF CONVERGENCE W/ OR W/O COEFFICIENT     C
!                      MATRIX UPDATE                                   C
!                  (8) ADDED RUNNING CPU TIME EDIT                     C
!                  (9) CORRECTED AXIAL ADFS SO EITHER PURE RODDED OR   C
!                      UNRODDED BASED UPON WHETHER ROD THROUGH SURFACE C
!                       PAUL J. TURINSKY                               C
!                  (10)ADDED anmerge.f SO THAT WARNING MESSAGES IN     C
!                      REGARD TO DEFINING AN ALPHANUMERIC STRING       C
!                      BEYOND ONE LINE VIA CONTINUATION MARK ARE NOT   C
!                      OBTAINED                                        C
!                  (11)ADDED OPTION THAT CONROL FILE NAME CAN BE       C
!                      SPECIFIED AT EXECUTION TIME WITH DEFAULT NAME   C
!                      '3DKIN.CNTL'                                   C
!                  (12)ADDED OPTION OF JUST READING AND WRITTING THE   C
!                      INPUT FILES                                     C
!                  (13)REMOVED ALL temp*.fcb FILES VIA MERGE/NEW NAME  C
!                  (14)ADDED lsorb0 CPU TIME TO INNER ITERATIONS &     C
!                      REMOVED FROM OUTER ITERATIONS                   C
!                  (15)CORRECTED geometry.f TO CORRECT ERROR IN        C
!                      CALCULATING END OF FUEL WHEN NMULZ > 1          C
!                                                                      C
!              VERSION 5.0.2.1 (5/1/97) MODIFICATIONS/CORRECTIONS      C
!                  (1) CORRECTED ERROR IN nonnemh.f BY REMOVING        C
!                      A(LEXCN) FROM nontwoc CALL                      C
!
!              VERSION 5.0.3 (2001) MODIFICATIONS/CORRECTIONS          C
!                  IMELDA ARIANI                                       C
!                  (1) MODIFIED ROUTINES TO RUN ON VISUAL FORTRAN (PC) C
!                  (2) CLEANED UP UNUSED ARRAYS IN SEVERAL ROUTINES    C
!                  (3) CORRECTED BUGS IN HEXAGONAL GEOMETRY            C
!                      xsfdbk.f, geometry.f                            C
!
!              VERSION 5.2.0 (2001) 
!                  IMELDA ARIANI
!                  (1) CONFORMAL MAPPING BASED HEXAGONAL NODAL METHOD
!                      WITH INTRANODE BURNUP GRADIENT TREATMENT 
!                      AND PIN POWER RECONSTRUCTION
!                  (2) ALLOW READ OF INITIAL NODE EXPOSURE 
!                      & ISOTOPIC NUMBER DENSITIES
!                  (3) REFERENCE SOLUBLE POISON CONCENTRATION IS NOW
!                           CROSS SECTION TYPE DEPENDENT
!
!              VERSION 5.2.1 (2001) 
!                  IMELDA ARIANI
!                  corrected bugs from V5.2.0
!                  Affected routines:
!                  chain.f, burnnode.f, file_numden.f, geometry.f, 
!                  main.f, nonnemh.f, starter.f
!                  
!23456789012345678901234567890123456789012345678901234567890123456789012
!
!
!      PROGRAM MAIN
      include 'param.fcb'
      include 'array.fcb'
      include 'burn.fcb'
      include 'che.fcb'
      include 'cntl.fcb'
      include 'cntl2.fcb'
      include 'dataf.fcb'
      include 'crod.fcb'
      include 'perttr.fcb'
      include 'varlen.fcb'
      include 'varlens.fcb'
      include 'adj.fcb'
      include 'depletepc.fcb'
      include 'tim.fcb'
      include 'timetr.fcb'
      include 'nemcnt.fcb'
      include 'xeopt.fcb'
      include 'pinpow.fcb'

       CHARACTER*40 VERSION
$endif
       LOGICAL :: fcallss = .true.
      
       CONTAINS
       SUBROUTINE rrk3d
$if def,3dkin
!
!     THIS PROGRAM IS THE MAIN PROGRAM FOR 3DKIN
!
      USE iss_rk3d_int,   ONLY: rel_nod_proc !vmq
      
      issmerged = .true.  !vmq
      
      tranrk = .false.    !vmq

      repeat = .false.    !vmq
      
      firstrepeat = .false. !vmq
      
      repeattr    = .false. !vmq
      
      fcallflag   = .false. !vmq
      
      convrk3d    = .false. !vmq
      
      TOTIME = 0.0 !vmq
      TREND = 0.0  !vmq
      TRSTRT = 0.0 !vmq

!     
!-----SETTING 3DKIN VERSION NUMBER
!     
      VERSION = '========> VERSION NO. V1.1 <========'
!     
      WRITE (6,1)
      WRITE (6,2)
      WRITE (6,*)'            '
      WRITE (6,92)VERSION
      WRITE (6,*)'            '
      WRITE (6,*)'            '
      
      MAXMEM = NMAXMEM
      MAXBYTE = 1000000
!     
!-----------------------------------------------------------------
!     
!------STARTING THE CLOCK [ CPU TIME ]
      
      CALL GTIME(TIMESTART)
!     
!-----CALLING THE INPUT PROCESSING SUBROUTINES
!     
      CALL INPDATA
      WRITE(6,*)'FINISHED READING ALL INPUT'
!     
!     COMPUTE GEOMETRY PARAMETERS
!     
      IK=5
      CALL POINTER3D(IK,IOERROR)

! !vmq no imicro      IF(IRSTRT.NE.'Y'.AND.IMICRO.EQ.'Y')
! !vmq no imicro     $  CALL FILE_NUMDEN(A(LANUMDEN3DTN),AINT(LNXSTARTN),AINT(LNXENDN),
! !vmq no imicro     &  AINT(LNCOL2DTN),AINT(LNCOLZTN))
            
      CALL GEOMETRY(A(LDXN),A(LDYN),A(LDZN),
     &  A(LDDXN),A(LDDYN),A(LDDZN),A(LDISTN),
     &  AINT(LLRODN),AINT(LNCOLXYN),AINT(LNCOLZN),
     &  AINT(LNSPACXN),AINT(LNSPACYN),AINT(LNSPACZN),AINT(LIBIYNDELN),
     &  AINT(LIBIXWDELN),AINT(LNBCYYENDN),AINT(LNBCYYSTARTN),
     &  AINT(LNBCXXENDN),AINT(LNBCXXSTARTN),AINT(LIBIXWN),
     &  AINT(LNXSTARTBN),AINT(LNXENDBN),AINT(LIBIYNN),AINT(LNBCN),
     &  AINT(LNXSTARTN),AINT(LNXENDN),AINT(LNDNUMN),AINT(LNYSTARTN),
     &  AINT(LNYENDN),AINT(LNCOL2DN),AINT(LNCOL2DTN),
     &  AINT(LNCOLZTN),AINT(LLSEXT2DTN),AINT(LLROD2DTN),AINT(LLROD2DN),
     &  AINT(LLSEXT2DN),AINT(LLSEXTZTN),AINT(LLSEXTZN),
     &  AINT(LLSEXTRN),AC(LABCYDELN),AINT(LNBCXENDN),AINT(LNYENDBN),
     &  AINT(LNBCYENDN),AINT(LIBIYN),AINT(LNBCYSTARTN),
     &  AINT(LIBIXN),AINT(LNBCXSTARTN),AC(LABCXDELN),AINT(LNYSTARTBN),
     &  A(LFRACTBN),AINT(LIBPITCHXHN),AINT(LIBPITCHYHN),AINT(LNREF2DN),
     &  AINT(LNROT2DN),AINT(LNREFN),AINT(LNROTN),AINT(LNREF2DTN),
     &  AINT(LNROT2DTN),AINT(LNTOPZN),AINT(LNTOPZTN),AINT(LIBIXXN),
     &  AINT(LIBIYYN),AINT(LNBCXRSTARTN),AINT(LNBCYRSTARTN),
     &  AINT(LNCOLORN),A(LEXP3DN),A(LEXP3DTN),A(LEXPINITN),
     $  A(LANUMDEN3DTN),A(LANUMDEN3DN),A(LANUMDENN),A(LBUSURFN),
     $  A(LBUSURF3DN),A(LBUSURF3DTN))

      IK=6

      CALL POINTER3D(IK,IOERROR)
!     
!.... SETTING THE BURNUP COUNTER TO ONE
!     
      IBU = 1
      IBUCURRENT = 0 !vmq
      IONCE = 0 !vmq
!     
!------WRITING THE INPUT ATTRIBUTES INTO A FILE
!     
      CALL INPEDIT(A(LAVBUN),AC(LISAVEN),AC(LOUTN),
     &  A(LTIMETRN),A(LPMTN),A(LTINTN),A(LGMINTN),A(LZBTN),
     &  A(LTIMEPRN),A(LTIMESPN),A(LDELTN),A(LTIMEFPN),A(LPRFPN),
     &  A(LPMFPN),A(LTINFPN),A(LZBFPN))
      IF(AL3.EQ.'YS') THEN
       WRITE(6,1059)
       RETURN !GOTO 1993  ! vmq  return and close calculation (next feature to do)
      ENDIF
      
      CALL CONVER(A(LZBN),A(LDISTN),A(LDXN),A(LDYN),A(LDZN),
     & A(LVOLUN),A(LAREAN),AINT(LNXSTARTN),AINT(LNXENDN),AINT(LNDNUMN),
     & A(LRHOWREFN),A(LRHOWMREFN) )
      
      IF(NSHAP.EQ.'CART') THEN
       CALL GASCATC(
     &   AINT(LIRPLANN),AINT(LIBPLANN),AINT(LIRPLN),AINT(LIBPLN),
     &   AINT(LNXSTARTN),AINT(LNXENDN),AINT(LNDNUMN) )
      ELSE
       CALL GASCATH(AINT(LIRPLANN),AINT(LIBPLANN),AINT(LIRPLN),
     &   AINT(LIBPLN),AINT(LIYPLANN),AINT(LIYPLN),
     &   AINT(LNXSTARTN),AINT(LNXENDN),AINT(LNDNUMN) )
      ENDIF
      
      IK=7
      CALL POINTER3D(IK,IOERROR)

      CALL REL_NOD_PROC
      
 1    FORMAT (/T24,'"PLEASE DO NOT DISTURB !"')
 2    FORMAT (/T24,'"3DKIN IS EXECUTING...."',$/)
 92   FORMAT(T16,A40)
 
 1059 FORMAT(// ' 3DKIN INPUT EDIT CHECK RUN COMPLETED.')
$endif
       END SUBROUTINE rrk3d

       SUBROUTINE irk3d
$if def,3dkin
      CALL INITAL(A(LBUNODEN),A(LEXPINITN),A(LDLNN),A(LDLLN),
     $  A(LDLWN),A(LDLNVN),A(LDLNUN),A(LFRACTN),
     &  A(LDIN),A(LDU38N),A(LDPU39N),A(LDPU40N),A(LDPU41N),
     &  A(LDU35N),A(LDLFP1N),A(LDLFP2N),A(LDPU42N),A(LFNSWTN),
     &  A(LFNOLDTN),A(LDZN),A(LAREAN),
     &  A(LWTFRRIN),A(LDXEN),A(LDION),A(LDPMN),A(LDSMN),A(LSWOLDN),
     &  A(LSWN),A(LSWSN),A(LGGMKN),A(LTAVFN),A(LHEFFN),A(LRHOWN),
     &  A(LRTN),AINT(LNCOLXYN),AINT(LNCOLZN),A(LALPHATN),A(LFUFRN),
     &  A(LVOLUN),A(LTCOLCN),A(LDOPLN),A(LUNEWN),A(LDU36N),
     &  A(LDU34N),A(LDBPN),A(LCIN),A(LHEATFLUXN),
     &  A(LPWRDNN),A(LWOMN),A(LWOMON),AINT(LITRRN),A(LFNPPOTN),
     &  A(LTTCOLINN),A(LTMODCN),A(LDAM41N))

      CLOSE(79)
      
      IF(IRSTRT .EQ. 'Y') CLOSE(UNIT=9)
!     
!     DO NOT INITIALIZE ERRATN & FLAMDA FOR RESTART CASE
!     
      IF(IRSTRT .EQ. 'N') THEN
       ERRATN=1.0
       FLAMDA=1.0
      ENDIF
$endif
       END SUBROUTINE irk3d

       SUBROUTINE eigencalc
$if def,3dkin
      USE iss_rk3d_int,   ONLY: rel2rk3d,rk3d2rel
      include 'contrl.h'
!     
!------START BURNING THE FUEL ( IF IBURN = 'Y' )
!     
! 2000 CONTINUE !vmq
      CALL rel2rk3d
      IF (repeat) GOTO 2000 !vmq
      IF(fcallss) THEN !vmq
       ALOGPC='PREDICTOR'
       ASAVPC='N' 
       CALL DEPLETE(A(LUPUDENN),A(LDELBUN),A(LBUNODEN),
     &   A(LDU38N),A(LDPU39N),A(LDPU40N),
     &   A(LDPU41N),A(LDU35N),A(LDLFP1N),A(LDLFP2N),A(LDPU42N),
     &   A(LFU5N),A(LFU8N),A(LFPU9N),
     &   A(LFPU0N),A(LFPU1N),A(LFPU2N),A(LRELPWRN),
     &   A(LSWN),A(LCARON),A(LRNFRON),A(LPFRON),
     &   A(LBUBOSN),
     &   A(LU5AN),A(LU8AN),A(LP9AN),A(LP0AN),A(LP1AN),A(LP2AN),
     &   A(LFLN),A(LRNUU5N),A(LRNUU8N),A(LRNUP9N),A(LRNUP0N),
     & A(LRNUP1N),A(LRNUP2N),AINT(LNCOLXYN),AINT(LNCOLZN),AINT(LNMAXN),
     &   A(LFRACTBN),A(LRELPWROLDN),A(LSWOLDN),A(LVOLUN),A(LTPFN),
     &   A(LDU35OLDN),A(LDU38OLDN),A(LDPU39OLDN),A(LDPU40OLDN),
     &   A(LDPU41OLDN),A(LDPU42OLDN),A(LDLFP1OLDN),A(LDLFP2OLDN),
     &   A(LFUFRN),
     &   A(LFU5PYRON),A(LFU8PYRON),A(LFPU9PYRON),A(LFPU0PYRON),
     &   A(LFPU1PYRON),A(LFPU2PYRON),A(LU5APYRON),A(LU8APYRON),
     &   A(LP9APYRON),A(LP0APYRON),A(LP1APYRON),A(LP2APYRON),
     &   A(LRFPA1PYRON),A(LRFPA2PYRON),
     &   A(LFU5PYRIN),A(LFU8PYRIN),A(LFPU9PYRIN),A(LFPU0PYRIN),
     &   A(LFPU1PYRIN),A(LFPU2PYRIN),A(LU5APYRIN),A(LU8APYRIN),
     &   A(LP9APYRIN),A(LP0APYRIN),A(LP1APYRIN),A(LP2APYRIN),
     &   A(LRFPA1PYRIN),A(LRFPA2PYRIN),
     &   A(LRHOWN),A(LRHOWREFN),
     &   A(LTCOLCN),A(LTCOLREFN),A(LDOPLN),A(LRNFRIN),
     &   A(LPFRIN),A(LCARIN),A(LFRACTN),A(LTTCOLINN),
     &   A(LDBPN),A(LDBPOLDN),A(LBPAPYRON),A(LBPAPYRIN),A(LBPAN),
     &   A(LFU6N),A(LU6AN),A(LDU36N),A(LDU36OLDN),A(LRNUU6N),
     &   A(LFU6PYRON),A(LU6APYRON),A(LFU6PYRIN),A(LU6APYRIN),
     &   A(LFU4N),A(LU4AN),A(LDU34N),A(LDU34OLDN),A(LRNUU4N),
     &   A(LFU4PYRON),A(LU4APYRON),A(LFU4PYRIN),A(LU4APYRIN),
     &   A(LRHOWMREFN),
     &   A(LANUMDENN),
     $   AINT(LINITNDN),A(LREFBN),A(LDAM41N),
     $   A(LDAM41OLDN),A(LFAM1PYRON),A(LFAM1PYRIN),A(LA1APYRON),
     $   A(LA1APYRIN),A(LFAM1N),A(LA1AN),A(LRNUA1N),A(LDSMN))

! !vmq no hex      IF(NSHAP.EQ.'HEXA'.AND.HEXBUGRAD.EQ.'Y')THEN
! !vmq no hex       CALL DEPLETES(A(LDU34SN),A(LDU35SN),A(LDU36SN),A(LDU38SN),
! !vmq no hex    $   A(LDPU39SN),A(LDPU40SN),A(LDPU41SN),A(LDPU42SN),A(LDAM41SN),
! !vmq no hex    $   A(LDBPSN),A(LANUMDENSN),A(LDU34OLDSN),A(LDU35OLDSN),
! !vmq no hex    $   A(LDU36OLDSN),A(LDU38OLDSN),A(LDPU39OLDSN),A(LDPU40OLDSN),
! !vmq no hex    $   A(LDPU41OLDSN),A(LDPU42OLDSN),A(LDAM41OLDSN),A(LDBPOLDSN),
! !vmq no hex    $   A(LFU4PYROSN),A(LFU5PYROSN),A(LFU6PYROSN), A(LFU8PYROSN), 
! !vmq no hex    $   A(LFPU9PYROSN),A(LFPU0PYROSN), A(LFPU1PYROSN), 
! !vmq no hex    $   A(LFPU2PYROSN),A(LFAM1PYROSN), 
! !vmq no hex    $   A(LFU4PYRISN),A(LFU5PYRISN),
! !vmq no hex    $   A(LFU6PYRISN),A(LFU8PYRISN), A(LFPU9PYRISN), 
! !vmq no hex    $   A(LFPU0PYRISN),A(LFPU1PYRISN), A(LFPU2PYRISN), 
! !vmq no hex    $   A(LFAM1PYRISN),A(LSWN), A(LSWSN), A(LSWOLDSN),
! !vmq no hex    $   A(LFU4SN),A(LFU5SN),A(LFU6SN),A(LFU8SN),A(LFPU9SN),A(LFPU0SN),
! !vmq no hex    $   A(LFPU1SN),A(LFPU2SN),A(LFAM1SN),A(LU4AN),A(LU5AN),A(LU6AN),
! !vmq no hex    $   A(LU8AN),A(LP9AN),A(LP0AN),A(LP1AN),A(LP2AN),A(LA1AN),
! !vmq no hex    $   A(LFLN),A(LCAROSN),A(LCARISN),A(LRNFROSN),A(LRNFRISN),
! !vmq no hex    $ A(LPFROSN),A(LPFRISN),AINT(LNCOLXYN),AINT(LNMAXN),AINT(LNCOLZN),
! !vmq no hex    $   A(LDELBUN),A(LDLFP1N),A(LDLFP2N),A(LDLFP1OLDN),A(LDLFP2OLDN),
! !vmq no hex    $   A(LRELPWRSN),A(LRELPWROLDSN),A(LU4APYRON),A(LU5APYRON),
! !vmq no hex    $   A(LU6APYRON),A(LU8APYRON),A(LP9APYRON),A(LP0APYRON),
! !vmq no hex    $   A(LP1APYRON),A(LP2APYRON),A(LA1APYRON),A(LU4APYRIN),
! !vmq no hex    $   A(LU5APYRIN),A(LU6APYRIN),A(LU8APYRIN),A(LP9APYRIN),
! !vmq no hex    $   A(LP0APYRIN),A(LP1APYRIN),A(LP2APYRIN),A(LA1APYRIN),
! !vmq no hex    $   A(LFUFRN),A(LFRACTBN),A(LFRACTN),A(LRHOWN),A(LRHOWREFN),
! !vmq no hex    $   A(LTCOLCN),A(LTCOLREFN),A(LREFBN),A(LDOPLN),A(LTTCOLINN),
! !vmq no hex    $   A(LRHOWMREFN),A(LVOLUN),A(LRNUU4N),A(LRNUU5N),A(LRNUU6N),
! !vmq no hex    $   A(LRNUU8N),A(LRNUP9N),A(LRNUP0N),A(LRNUP1N),A(LRNUP2N),
! !vmq no hex    $   A(LRNUA1N),A(LTPFN),A(LRFPA1PYRON),A(LRFPA2PYRON),
! !vmq no hex    $   A(LRFPA1PYRIN),A(LRFPA2PYRIN),A(LBPAPYRON),A(LBPAPYRIN),
! !vmq no hex    $   A(LBPAN),A(LBUSURFN))
! !vmq no hex      ENDIF
      

!     
!---- SKIP STEADY-STATE INITIATION IF TRANSIENT RESTART BASIS
!     
       IF(ITRAN.EQ.'Y'.AND.IRSTRT.EQ.'Y'
     &   .AND.IRSTRTB.EQ.'TR') THEN
        tranrk = .true.  !vmq
        LTHSHORT = 1
        CALL XSFDBK(
     &   A(LDCLN),A(LDLNN),A(LDCWN),A(LDCNVN),A(LDCNUN),A(LDLLN),
     &   A(LDLWN),A(LDCNN),A(LDLNVN),A(LDLNUN),A(LRIVELON),
     &   A(LRNURON),
     &   A(LRNURIN),A(LB2N),
     &   A(LDOPLN),A(LRHOWN),A(LDXEN),A(LDSMN),
     &   A(LDXN),A(LDYN),A(LDZN),A(LVOLUN),A(LAWXN),A(LAWUN),A(LAWVN),
     &   A(LAWZN),A(LAWYN),A(LBWYN),A(LBWXN),A(LBWUN),A(LBWVN),
     &   A(LBWZN),A(LAQN),A(LTCDN),A(LTCAN),A(LTCRN),A(LTNFN),A(LTPFN),
     &   A(LTXTN),A(LSIGDSNN),
     &   A(LBETAN),A(LBETAMIN),A(LXHIPN),A(LXHIPMIN),
     &   A(LBETATN),A(LXHIDMIN),A(LBETATLAMN),A(LFU5N),A(LFU8N),
     &   A(LFPU9N),A(LFPU0N),A(LFPU1N),
     &   A(LFPU2N),A(LSWN),A(LDU38N),A(LDPU39N),A(LDPU40N),A(LDPU41N),
     &   A(LDU35N),A(LDPU42N),A(LRNUU5N),A(LRNUU8N),A(LRNUP9N),
     &   A(LRNUP0N),A(LRNUP1N),A(LRNUP2N),AINT(LNCOLXYN),AINT(LNCOLZN),
     &   AINT(LNBCN),AINT(LNXSTARTN),AINT(LNXENDN),AINT(LNDNUMN),
     &   AINT(LNMAXN),A(LXXEABN),A(LXSMABN),A(LRNUN),A(LTCOLCN),
     &   A(LFRACTN),A(LRHOWREFN),A(LTCOLREFN),
     &   A(LGIN),A(LGXN),A(LGPN),A(LGINMIN),
     &   A(LGXNMIN),A(LGPNMIN),A(LFU5PYRON),A(LFU8PYRON),A(LFPU9PYRON),
     &   A(LFPU0PYRON),A(LFPU1PYRON),A(LFPU2PYRON),
     &   A(LFU5PYRIN),A(LFU8PYRIN),A(LFPU9PYRIN),
     &   A(LFPU0PYRIN),A(LFPU1PYRIN),A(LFPU2PYRIN),
     &   LTHSHORT,A(LTTCOLINN),A(LFU6N),A(LDU36N),A(LRNUU6N),
     &   A(LFU6PYRON),A(LFU6PYRIN),A(LFU4N),A(LDU34N),A(LRNUU4N),
     &   A(LFU4PYRON),A(LFU4PYRIN),A(LRHOWMREFN),
     &   A(LREFBN),
     &   A(LDAM41N),A(LFAM1N),A(LFAM1PYRON),A(LFAM1PYRIN),A(LRNUA1N),
     $   A(LALAMDATN),A(LALAMDAMIN),A(LBFACTN),
     $   A(LTXTON),A(LTNFON),A(LTPFON))
       
        CALL STARTER(A(LALAMDATN),A(LBETAN),A(LCIN),
     &   A(LALPHAN),A(LZETAN),A(LDIN),A(LALPHATN),
     &   A(LPWRDNOLDN),A(LPWRDNN),A(LHEFFOLDN),A(LTCOLCOLDN),
     &   A(LTAVFOLDN),A(LRHOWOLDN),A(LTAVFN),A(LHEFFN),A(LRHOWN),
     &   A(LTCOLCN),A(LFNOLDTN),A(LFNSWTN),A(LHEATFLUXN),A(LSWN),
     &   A(LSWOLDN),A(LAREAN),AINT(LNCOLXYN),AINT(LNCOLZN),A(LTPFN),
     &   A(LTTCOLINOLDN),A(LUOLDN),A(LUNEWN),A(LDU34N),
     &   A(LDU35N),A(LDU38N),A(LDPU39N),A(LDPU40N),A(LDPU41N),
     &   A(LDPU42N),A(LFU4N),A(LFU5N),A(LFU8N),A(LFPU9N),
     &   A(LFPU0N),A(LFPU1N),A(LFPU2N),A(LALPHAIN),AINT(LNMAXN),
     &   A(LDU36N),A(LFU6N),A(LTTCOLINN))

        RETURN
       ENDIF                                                  
      ENDIF !vmq
!---- SELECTING THE XENON-SMARIUM OPTION
!     
!
 2000 CONTINUE !vmq     
! !vmq  no slowtran    GOTO (651,651,651,654,654,651),IXE(IBU)
!     
! !vmq  no slowtran 651  CONTINUE
      CALL STEADYN(
     &  A(LRIVELON),A(LTNFN),A(LDLNN),A(LDLLN),A(LDLWN),A(LDLNVN),
     &  A(LDLNUN),A(LSWN),A(LVOLUN),A(LFNPPOTN),A(LFNSWTN),
     &  A(LAVBUN),A(LBUPMN),A(LPPMN),AINT(LITRRN),A(LWOMN))
     
      IF (repeat) GOTO 2001 !vmq      

      IF(IBURN.EQ.'Y') THEN
       IF(ADEPL.EQ.'PRED') THEN
        ALOGPC='PREDICTOR'
       ELSE
        ALOGPC='CORRECTOR'
       ENDIF
       ASAVPC='Y'

       CALL DEPLETE(A(LUPUDENN),A(LDELBUN),A(LBUNODEN),
     &   A(LDU38N),A(LDPU39N),A(LDPU40N),
     &   A(LDPU41N),A(LDU35N),A(LDLFP1N),A(LDLFP2N),A(LDPU42N),
     &   A(LFU5N),A(LFU8N),A(LFPU9N),
     &   A(LFPU0N),A(LFPU1N),A(LFPU2N),A(LRELPWRN),
     &   A(LSWN),A(LCARON),A(LRNFRON),A(LPFRON),
     &   A(LBUBOSN),
     &   A(LU5AN),A(LU8AN),A(LP9AN),A(LP0AN),A(LP1AN),A(LP2AN),
     &   A(LFLN),A(LRNUU5N),A(LRNUU8N),A(LRNUP9N),A(LRNUP0N),
     & A(LRNUP1N),A(LRNUP2N),AINT(LNCOLXYN),AINT(LNCOLZN),AINT(LNMAXN),
     &   A(LFRACTBN),A(LRELPWROLDN),A(LSWOLDN),A(LVOLUN),A(LTPFN),
     &   A(LDU35OLDN),A(LDU38OLDN),A(LDPU39OLDN),A(LDPU40OLDN),
     &   A(LDPU41OLDN),A(LDPU42OLDN),A(LDLFP1OLDN),A(LDLFP2OLDN),
     &   A(LFUFRN),
     &   A(LFU5PYRON),A(LFU8PYRON),A(LFPU9PYRON),A(LFPU0PYRON),
     &   A(LFPU1PYRON),A(LFPU2PYRON),A(LU5APYRON),A(LU8APYRON),
     &   A(LP9APYRON),A(LP0APYRON),A(LP1APYRON),A(LP2APYRON),
     &   A(LRFPA1PYRON),A(LRFPA2PYRON),
     &   A(LFU5PYRIN),A(LFU8PYRIN),A(LFPU9PYRIN),A(LFPU0PYRIN),
     &   A(LFPU1PYRIN),A(LFPU2PYRIN),A(LU5APYRIN),A(LU8APYRIN),
     &   A(LP9APYRIN),A(LP0APYRIN),A(LP1APYRIN),A(LP2APYRIN),
     &   A(LRFPA1PYRIN),A(LRFPA2PYRIN),
     &   A(LRHOWN),A(LRHOWREFN),
     &   A(LTCOLCN),A(LTCOLREFN),A(LDOPLN),A(LRNFRIN),
     &   A(LPFRIN),A(LCARIN),A(LFRACTN),A(LTTCOLINN),
     &   A(LDBPN),A(LDBPOLDN),A(LBPAPYRON),A(LBPAPYRIN),A(LBPAN),
     &   A(LFU6N),A(LU6AN),A(LDU36N),A(LDU36OLDN),A(LRNUU6N),
     &   A(LFU6PYRON),A(LU6APYRON),A(LFU6PYRIN),A(LU6APYRIN),
     &   A(LFU4N),A(LU4AN),A(LDU34N),A(LDU34OLDN),A(LRNUU4N),
     &   A(LFU4PYRON),A(LU4APYRON),A(LFU4PYRIN),A(LU4APYRIN),
     &   A(LRHOWMREFN),
     &   A(LANUMDENN),
     $   AINT(LINITNDN),A(LREFBN),A(LDAM41N),
     $   A(LDAM41OLDN),A(LFAM1PYRON),A(LFAM1PYRIN),A(LA1APYRON),
     $   A(LA1APYRIN),A(LFAM1N),A(LA1AN),A(LRNUA1N),A(LDSMN))

! !vmq no hex      IF(NSHAP.EQ.'HEXA'.AND.HEXBUGRAD.EQ.'Y')THEN
! !vmq no hex       CALL DEPLETES(A(LDU34SN),A(LDU35SN),A(LDU36SN),A(LDU38SN),
! !vmq no hex     $  A(LDPU39SN),A(LDPU40SN),A(LDPU41SN),A(LDPU42SN),A(LDAM41SN),
! !vmq no hex     $  A(LDBPSN),A(LANUMDENSN),A(LDU34OLDSN),A(LDU35OLDSN),
! !vmq no hex     $  A(LDU36OLDSN),A(LDU38OLDSN),A(LDPU39OLDSN),A(LDPU40OLDSN),
! !vmq no hex     $  A(LDPU41OLDSN),A(LDPU42OLDSN),A(LDAM41OLDSN),A(LDBPOLDSN),
! !vmq no hex     $  A(LFU4PYROSN),A(LFU5PYROSN),A(LFU6PYROSN), A(LFU8PYROSN), 
! !vmq no hex     $  A(LFPU9PYROSN),A(LFPU0PYROSN), A(LFPU1PYROSN), 
! !vmq no hex     $  A(LFPU2PYROSN),A(LFAM1PYROSN), 
! !vmq no hex     $  A(LFU4PYRISN),A(LFU5PYRISN),
! !vmq no hex     $  A(LFU6PYRISN),A(LFU8PYRISN), A(LFPU9PYRISN), 
! !vmq no hex     $  A(LFPU0PYRISN),A(LFPU1PYRISN), A(LFPU2PYRISN), 
! !vmq no hex     $  A(LFAM1PYRISN),A(LSWN), A(LSWSN), A(LSWOLDSN),
! !vmq no hex     $  A(LFU4SN),A(LFU5SN),A(LFU6SN),A(LFU8SN),A(LFPU9SN),A(LFPU0SN),
! !vmq no hex     $  A(LFPU1SN),A(LFPU2SN),A(LFAM1SN),A(LU4AN),A(LU5AN),A(LU6AN),
! !vmq no hex     $  A(LU8AN),A(LP9AN),A(LP0AN),A(LP1AN),A(LP2AN),A(LA1AN),
! !vmq no hex     $  A(LFLN),A(LCAROSN),A(LCARISN),A(LRNFROSN),A(LRNFRISN),
! !vmq no hex     $ A(LPFROSN),A(LPFRISN),AINT(LNCOLXYN),AINT(LNMAXN),AINT(LNCOLZN),
! !vmq no hex     $  A(LDELBUN),A(LDLFP1N),A(LDLFP2N),A(LDLFP1OLDN),A(LDLFP2OLDN),
! !vmq no hex     $  A(LRELPWRSN),A(LRELPWROLDSN),A(LU4APYRON),A(LU5APYRON),
! !vmq no hex     $  A(LU6APYRON),A(LU8APYRON),A(LP9APYRON),A(LP0APYRON),
! !vmq no hex     $  A(LP1APYRON),A(LP2APYRON),A(LA1APYRON),A(LU4APYRIN),
! !vmq no hex     $  A(LU5APYRIN),A(LU6APYRIN),A(LU8APYRIN),A(LP9APYRIN),
! !vmq no hex     $  A(LP0APYRIN),A(LP1APYRIN),A(LP2APYRIN),A(LA1APYRIN),
! !vmq no hex     $  A(LFUFRN),A(LFRACTBN),A(LFRACTN),A(LRHOWN),A(LRHOWREFN),
! !vmq no hex     $  A(LTCOLCN),A(LTCOLREFN),A(LREFBN),A(LDOPLN),A(LTTCOLINN),
! !vmq no hex     $  A(LRHOWMREFN),A(LVOLUN),A(LRNUU4N),A(LRNUU5N),A(LRNUU6N),
! !vmq no hex     $  A(LRNUU8N),A(LRNUP9N),A(LRNUP0N),A(LRNUP1N),A(LRNUP2N),
! !vmq no hex     $  A(LRNUA1N),A(LTPFN),A(LRFPA1PYRON),A(LRFPA2PYRON),
! !vmq no hex     $  A(LRFPA1PYRIN),A(LRFPA2PYRIN),A(LBPAPYRON),A(LBPAPYRIN),
! !vmq no hex     $  A(LBPAN),A(LBUSURFN))
! !vmq no hex
! !vmq no hex      ENDIF

      ENDIF
!
!     CALCULATE PIN-WISE POWER IF DESIRED
!
! !vmq no hex       IF(NSHAP.EQ.'HEXA'.AND.PPR.EQ.'Y')THEN
! !vmq no hex C !vmq       WRITE(6,*)'PERFORMING PIN POWER RECONSTRUCTION'
! !vmq no hex        CALL NORM(A(LVOLUN),A(LFNSWTN),
! !vmq no hex      &   A(LSWN),A(LSWSN),A(LTNFN),A(LTPFN),
! !vmq no hex      &   A(LFRACTBN),AINT(LNCOLXYN),AINT(LNCOLZN)  )
! !vmq no hex        IF(IBU.EQ.1.AND.FPIN.NE.'Y')
! !vmq no hex      $  CALL PINLOC(A(LPINLOCRN),A(LPINLOCTN))
! !vmq no hex C------CORNER POINT VALUES
! !vmq no hex        CALL XSECBUC(A(LBUN),A(LSIGN),A(LCPADFN),A(LCPADFRDN),A(LFFN),
! !vmq no hex      $   A(LFFVN),A(LFFRDN),A(LFFVRDN),A(LBUNODEN),A(LBUBOSN),
! !vmq no hex      $   A(LCPADFVN),A(LCPADFVRDN),AINT(LNCOLXYN),AINT(LNCOLZN),
! !vmq no hex      &   AINT(LNMAXN),AINT(LNREFN),AINT(LNROTN))
! !vmq no hex        CALL CORNERFLX(A(LSWCN),A(LSWN),A(LSWSN),A(LFRACTN),A(LADFSVN),
! !vmq no hex      $   A(LADFSVRDN),A(LSWSHETN),A(LCPADFVN),A(LCPADFVRDN),
! !vmq no hex      $   AINT(LNXSTARTN),AINT(LNXENDN),AINT(LNDNUMN),AINT(LNCOLXYN),
! !vmq no hex      &   AINT(LNCOLZN),AINT(LNBCN),PPRERROR)
! !vmq no hex        IF(PPRERROR.EQ.1)THEN
! !vmq no hex         WRITE(6,*)'*********************************************'
! !vmq no hex         WRITE(6,*)'FATAL ERROR: NO RADIAL REFLECTORS IN THE CORE'
! !vmq no hex         WRITE(6,*)'PIN POWER RECONSTRUCTION NOT ALLOWED'
! !vmq no hex         WRITE(6,*)'*********************************************'
! !vmq no hex         WRITE(55,*)'*********************************************'
! !vmq no hex         WRITE(55,*)'FATAL ERROR: NO RADIAL REFLECTORS IN THE CORE'
! !vmq no hex         WRITE(55,*)'PIN POWER RECONSTRUCTION NOT ALLOWED'
! !vmq no hex         WRITE(55,*)'*********************************************'
! !vmq no hex        ELSE
! !vmq no hex C-----COLLAPSE XS AND FLUXES TO NG=2 IF NG>2
! !vmq no hex         IF(NG.GT.2)THEN
! !vmq no hex          CALL PINCOLLAP(A(LSWN),A(LSWSN),A(LSWCN),A(LTPFN),A(LTPFSN),
! !vmq no hex      $     A(LCOLSWSN),A(LCOLSWCN),A(LCOLTPFN),A(LCOLTPFSN),
! !vmq no hex      $     A(LCOLTNFN),A(LCOLTXTN),A(LCOLTCDN),A(LTNFN),A(LTXTN),
! !vmq no hex      $     A(LTCDN),A(LCOLSIGDSNN),A(LSIGDSNN),A(LXHIPN),A(LCOLXHIPN),
! !vmq no hex      $     AINT(LNCOLXYN),AINT(LNCOLZN))
! !vmq no hex          CALL PINPOWER(A(LCOLTXTN),A(LCOLTCDN),A(LCOLTNFN),
! !vmq no hex      $     A(LCOLTPFN),A(LCOLSIGDSNN),A(LSWN),A(LCOLSWSN),
! !vmq no hex      $     A(LCOLSWCN),A(LPINLOCRN),A(LPINLOCTN),A(LAMAXPINN),
! !vmq no hex      $     A(LAMAXPELLETN),A(LRELPWRN),AINT(LNCOLXYN),AINT(LNCOLZN),
! !vmq no hex      $     A(LCOLTPFSN),A(LFFVN),A(LFFVRDN),A(LFRACTN),
! !vmq no hex      $     A(LRPOWN),(LPPOWN),A(LDZN),A(LCOLXHIPN),
! !vmq no hex      $     AINT(LNDNUMN),AINT(LNXSTARTN),AINT(LNXENDN))
! !vmq no hex         ELSE
! !vmq no hex          CALL PINPOWER(A(LTXTN),A(LTCDN),A(LTNFN),A(LTPFN),A(LSIGDSNN),
! !vmq no hex      $     A(LSWN),A(LSWSN),A(LSWCN),A(LPINLOCRN),A(LPINLOCTN),
! !vmq no hex      $     A(LAMAXPINN),A(LAMAXPELLETN),A(LRELPWRN),AINT(LNCOLXYN),
! !vmq no hex      $     AINT(LNCOLZN),A(LTPFSN),A(LFFVN),A(LFFVRDN),A(LFRACTN),
! !vmq no hex      $     A(LRPOWN),A(LPPOWN),A(LDZN),A(LXHIPN),
! !vmq no hex      $     AINT(LNDNUMN),AINT(LNXSTARTN),AINT(LNXENDN))
! !vmq no hex         ENDIF
! !vmq no hex        ENDIF
! !vmq no hex       ENDIF
!     
!---- WRITING THE OUTPUT FILE (INCLUDE RESTART FILE "
!     FOR ISAVE(IBU)='Y')
!     
      CALL OUTPUTSS
     &  (A(LTPFN),A(LRELPWRN),A(LDXEN),A(LDION),A(LDPMN),A(LDSMN),
     &  A(LAVBUN),A(LDELBUN),A(LBUNODEN),A(LVOLUN),A(LSWN),
     &  A(LFNSWTN),A(LZBN),A(LTCOLCN),A(LTAVFN),A(LUNEWN),A(LRHOWN),
     &  A(LDLNN),A(LDLLN),A(LDLWN),A(LDLNVN),A(LDLNUN),A(LDU38N),
     &  A(LDPU39N),A(LDPU40N),A(LDPU41N),A(LDU35N),A(LDLFP1N),
     &  A(LDLFP2N),A(LDPU42N),AC(LISAVEN),AC(LOUTN),AINT(LNCOLXYN),
     &  AINT(LNCOLZN),AINT(LNXSTARTBN),AINT(LNXENDBN),AINT(LNXSTARTN),
     &  AINT(LNXENDN),AINT(LNDNUMN),A(LFRACTBN),A(LDU36N),
     &  A(LDU34N),A(LDBPN),A(LDOPLN),A(LTMODCN),A(LRHOWMN)
     $  ,A(LAKINFN),A(LTNFN),A(LTCRN),A(LTCAN),A(LTCDN),A(LTXTN)
     $  ,A(LXXEABN),A(LXSMABN),A(LDAM41N))


! !vmq no slowtran      GOTO 9080
! !vmq no slowtran      
! !vmq no slowtran 654  CONTINUE
! !vmq no slowtran      
! !vmq no slowtran      CALL SLOWTRAN(A(LRIVELON),
! !vmq no slowtran     &  A(LTNFN),A(LDLWN),A(LDLLN),A(LDLNN),A(LDLNVN),A(LDLNUN),
! !vmq no slowtran     &  A(LFNSWTN),A(LFNPPOTN),A(LSWN),A(LVOLUN),A(LZBN),A(LTIMEFPN),
! !vmq no slowtran     &  A(LPRFPN),A(LPMFPN),A(LTINFPN),A(LZBFPN),A(LDELTFPN),
! !vmq no slowtran     &  A(LAVBUN),A(LBUPMN),A(LPPMN),AC(LISAVEN),AINT(LITRRN),A(LWOMN))
! !vmq no slowtran      
!
 9080 CONTINUE
      
      IF (IBURN.EQ.'N') GOTO 2002 !vmq 2001 changed to 2002
      NBUP1=NBU+1
      IBU=IBU+1
      IRSTRT='N'
      GOTO 2001  !vmq    posible goto 2001
      
!     
!-----EXIT THE BURNUP LOOP
!     

 2002 CONTINUE
!     
!------DO THE ADJOINT CALCULATION IF [ IADJ.EQ.'Y' ]
!     
      IF(IADJ.EQ.'Y') THEN
       CALL ADJOINT(
     &   A(LBETATN),A(LBETATLAMN),A(LVOLUN),A(LFNSWTN),
     &   A(LFNPPOTN),A(LSWN),A(LXHIPN) )
       
       CALL OUTPUTAD(
     &   A(LAVBUN),A(LDZN),A(LVOLUN),A(LSWN),A(LZBN),
     &   AINT(LNXSTARTN),AINT(LNXENDN),A(LZN),A(LFRACTBN), 
     &   A(LFLUX1DN),A(LFLUX2DN),AINT(LNDNUMN) )
      ENDIF
! 
!------SKIP THE TRANSIENT CALCULATIONS IF [ ITRAN.NE.'Y' ]
!     
      IF(ITRAN.NE.'Y') GOTO 2001 ! GOTO 1993 vmq       !vmq
      ITC   = 1                                    !vmq
      IPR   = 1                                    !vmq
      ITR   = 1                                    !vmq
      IFIRST= 1                                    !vmq
                                                   !vmq
!-----RESEAT THE TRANSIENT ELAPSED TIME [ SECONDS ] !vmq
                                                   !vmq
      TIMEELAPS  = 0.0                             !vmq
      TIMEELAPSO = 0.0                             !vmq
!
 1992 CONTINUE
      INEM  = 0
      NDTSTEPS=0
      KKCTRT=0
      KSTRT=0
      NCALNONT=0
      RTRECTRT=0
      RTOUTTRT=0
      TRTNCPUT=0
      OUTOTTRT=0
      TXSFDTRT=0
      TTHTRT=0
      TSCALTRT=0
! !vmq     IF(CRTON.EQ.'Y') THEN
! !vmq      WRITE(6,*)'          '
! !vmq      WRITE(6,*)'          '
! !vmq      WRITE(6,*)'          '
       WRITE(6,*)'          '
       WRITE(6,*)
     &   ' ####### START OF THE TRANSIENT SOLUTION OR 3DKIN #######'
       WRITE(6,*)'          '
! !vmq      WRITE(6,*)'          '
! !vmq     ENDIF
      IPRINT = 1 !vmq
! !vmq
 2001 CONTINUE !vmq             
       CALL rk3d2rel !vmq
       succes = 999   !vmq       
       IF (convrk3d) THEN !vmq
         succes = 0 !vmq
         convrk3d = .false. ! vmq
       ENDIF  !vmq
       RETURN ! GOTO 1993  ! vmq
$endif
       END SUBROUTINE eigencalc

       SUBROUTINE trn3d
$if def,3dkin
!     
!------START THE TRANSIENT CPU TIME CLOCK
!
      USE iss_rk3d_int,   ONLY: rel2rk3d,coupdone !vmq
      include 'contrl.h'
      call rel2rk3d   !vmq
      if (repeattr) GOTO 2999 !vmq      
      CALL GTIME(TRSTRT)
!     
!--------------------THE START OF THE TRANSIENT ------------------
!     
 2999 CONTINUE !vmq
      CALL TRANSIT(ITRANMORE,AINT(LITRRN),A(LWOMN))
 
      NDTSTEPS=NDTSTEPS+1 
      KKCTRT=KKCTRT+KKCTR
      KSTRT=KSTRT+(KSTR+1)
      NCALNONT=NCALNONT+NCALNON
      RTRECTRT=RTRECTRT+RTRECTR
      RTOUTTRT=RTOUTTRT+RTOUTTR
      TRTNCPUT=TRTNCPUT+TRTNCPU
      OUTOTTRT=OUTOTTRT+OUTOTTR
      TXSFDTRT=TXSFDTRT+TXSFDTR
      TTHTRT=TTHTRT+TTHTR
      TSCALTRT=TSCALTRT+TSCALTR
      
!      IF(ITRANMORE.EQ.1)GOTO 1990
      succes = 999   !vmq       
      IF (convrk3d) THEN  ! vmq
        succes = 0 !vmq
        convrk3d = .false. ! vmq
      ENDIF  !vmq
      IF (coupdone) THEN ! vmq
!     
!--------------------THE END OF THE TRANSIENT ------------------
!     
        CALL GTIME(TREND)
!     
!------STOP THE TRANSIENT CPU TIME CLOCK
!     
        TOTIME = TREND-TRSTRT
      
! !vmq       IF(CRTON.EQ.'Y') THEN
! !vmq        WRITE(6,*)' '
! !vmq        WRITE(6,*)'CPU TIME IN TRANSIENT : ',TOTIME,' SEC'
! !vmq        WRITE(6,*)' '
! !vmq       ENDIF

        WRITE(55,300)
        WRITE(55,61) NDTSTEPS
        WRITE(55,63) KKCTRT,FLOAT(KKCTRT)/NDTSTEPS
        WRITE (55,44) KSTRT,FLOAT(KSTRT)/NDTSTEPS
        IF(IMETHOD .EQ. 2) THEN
         WRITE(55,950) NCALNONT,FLOAT(NCALNONT)/NDTSTEPS
        ENDIF
        WRITE (55,43) RTRECTRT,RTRECTRT/NDTSTEPS
        PKKCTRT=FLOAT(KKCTRT)/FLOAT(KSTRT)
        WRITE(55,62) PKKCTRT
        WRITE (55,42) RTRECTRT/KSTRT
        WRITE(55,35) RTOUTTRT,RTOUTTRT/NDTSTEPS
        IF(IMETHOD .EQ. 2 .AND. NCALNONT .GT. 0) THEN
         PKKCTRT=FLOAT(KSTRT)/FLOAT(NCALNONT)
         WRITE(55,64) PKKCTRT
        ENDIF
        WRITE(55,36) RTOUTTRT/KSTRT
        IF(IMETHOD .EQ. 2) THEN
         WRITE(55,960) TRTNCPUT,TRTNCPUT/NDTSTEPS
         IF(NCALNON.GT.0) THEN
          WRITE(55,955) TRTNCPUT/NCALNONT
         ENDIF
        ENDIF
        WRITE(55,50) OUTOTTRT,OUTOTTRT/NDTSTEPS
        WRITE(55,37) TXSFDTRT,TXSFDTRT/NDTSTEPS
        WRITE(55,38) TTHTRT,TTHTRT/NDTSTEPS
        WRITE(55,39) TSCALTRT,TSCALTRT/NDTSTEPS
      
 50     FORMAT( /1x,'TOTAL LOOP CPU TIME                     = '
     &  ,F9.2,2X,F9.2/)
 36     FORMAT( /1x,'AVERAGE OUTER STEP CPU TIME PER OUTER   = '
     &  ,F9.2/)
 35     FORMAT( /1x,'TOTAL OUTER CPU TIME                    = '
     &  ,F9.2,2X,F9.2/)
 37     FORMAT( /1x,'TOTAL X-SECTION UPDATE CPU TIME         = '
     &  ,F9.2,2X,F9.2/)
 38     FORMAT( /1x,'TOTAL T-H SOLVE CPU TIME                = '
     &  ,F9.2,2X,F9.2/)
 39     FORMAT( /1x,'TOTAL SCALE FACTOR ACCEL. CPU TIME      = '
     &  ,F9.2,2X,F9.2/)
 960    FORMAT( /1x,'TOTAL CPU TIME IN THE NODAL ROUTINES    = '
     &  ,F9.2,2X,F9.2/)
 955    FORMAT( /1x,'AVERAGE NODAL CPU TIME PER NEM UPDATE   = '
     &  ,F9.2/)
 950    FORMAT( /1x,'TOTAL NUMBER OF NEM UPDATES             = '
     &  ,I9,2X,F9.1/)
 42     FORMAT( /1x,'AV. INNER STEP CPU TIME PER OUTER STEP  = '
     &  ,F9.2/)
 62     FORMAT( /1x,'AVERAGE NUMBER OF INNER ITERS PER OUTER = '
     &  ,F9.1/)
 64     FORMAT( /1x,'AV. NUMBER OF OUTER ITER PER NEM UPDATE = '
     &  ,F9.1/)
 43     FORMAT( /1x,'TOTAL CPU TIME FOR INNER STEPS ONLY     = '
     &  ,F9.2,2X,F9.2/)
 61     FORMAT( /1x,'TOTAL # OF TIME STEPS                   = '
     &  ,I9/)
 63     FORMAT( /1x,'TOTAL # OF INNER ITERATION STEPS        = '
     &  ,I9,2X,F9.1/)
 44     FORMAT( /1x,'TOTAL # OF OUTER ITERATION STEPS        = '
     &  ,I9,2X,F9.1/)
 300    FORMAT(////T12,'(( TOTAL TRANSIENT CPU TIME ( SEC ) EDIT ))'/
     &  /T46,'  TOTAL  PER TIME STEP'/)
      
      ENDIF  !vmq
$endif
       END subroutine trn3d

       SUBROUTINE end3d
$if def,3dkin
      
      WRITE(6,1060)
      
      CALL GTIME(TIMEEND)
!     
!     PRINT OUT DATA NEEDED FOR THE NEXT CYCLE --- MICRO RUN ONLY
!    
      IF(OEOC.EQ.'Y')THEN
       CALL OUTEOC(A(LBUNODEN),AINT(LNDNUMN),AINT(LNXSTARTN),
     $   AINT(LNXENDN),A(LDZN),A(LDU34N),A(LDU35N),A(LDU36N),A(LDU38N),
     $   A(LDPU39N),A(LDPU40N),A(LDPU41N),A(LDPU42N),
     $   A(LDLFP1N),A(LDLFP2N),A(LDBPN),A(LDAM41N),A(LDSMN))
      ENDIF
      
      RTMAIN = TIMEEND-TIMESTART
      WRITE(55,56) RTMAIN
      WRITE(6,56) RTMAIN
      
 56   FORMAT( //1x,'#########################################'
     *  ,'###############################'//
     *  1x,'TOTAL CODE CPU TIME                     = ',
     *  F9.2)
      
 1060 FORMAT(// ' 3DKIN TERMINATED IN NORMAL FASHION.')
       RETURN
$endif
       END SUBROUTINE end3d
!
       END MODULE rk3dcode
